<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>libica.app.gds API documentation</title>
<meta name="description" content="gds module …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>libica.app.gds</code></h1>
</header>
<section id="section-intro">
<p>gds module</p>
<p>ImplNote:
Consider implementation here should be reusable application specific routines for GDS common use cases.
Consider not to re-do libgds SDK generality.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;gds module

ImplNote:
Consider implementation here should be reusable application specific routines for GDS common use cases.
Consider not to re-do libgds SDK generality.
&#34;&#34;&#34;
import gzip
import logging
from tempfile import NamedTemporaryFile
from typing import List
from urllib.parse import urlparse

import requests

from libica.app import configuration
from libica.openapi import libgds

logger = logging.getLogger(__name__)


def get_gds_uri(gds_volume_name, gds_path):
    return f&#34;gds://{gds_volume_name}{gds_path}&#34;  # note gds path start with /


def parse_path(gds_path):
    gds_url_obj = urlparse(gds_path)
    return gds_url_obj.netloc, gds_url_obj.path


def check_file(gds_path) -&gt; list:
    &#34;&#34;&#34;See check_path

    NOTE: This is for &#34;error checking&#34; use case, hence, it may raise FileNotFoundError

    :param gds_path:
    :return:
    &#34;&#34;&#34;
    vol, path = parse_path(gds_path)
    return check_path(vol, path)


def check_path(volume_name: str, path: str) -&gt; list:
    &#34;&#34;&#34;Use cases
    This behave like UNIX `ls` command whereas you can check an absolute path to file or a directory.
    You can use it to check whether a file exist in GDS because it raises FileNotFoundError.
    Otherwise, it return file(s) found.

    NOTE: This wrap get_file_list but more strict to raise FileNotFoundError if zero match.

    :param volume_name:
    :param path:
    :return: List of libgds.FileResponse objects
    :rtype: list[FileResponse]
    &#34;&#34;&#34;

    files = get_file_list(volume_name=volume_name, path=path)
    if len(files) == 0:
        raise FileNotFoundError(f&#34;Could not get file: gds://{volume_name}{path}&#34;)
    return files


def get_gds_file_to_bytes(gds_volume_name: str, gds_path: str) -&gt; bytes:
    &#34;&#34;&#34;
    get_object_to_bytes API, with on-the-fly gzip detection and decompression

    :param gds_volume_name:
    :param gds_path:
    :return bytes: bytes from the decompressed GDS File body
    &#34;&#34;&#34;
    try:
        ntf = download_gds_file(gds_volume_name, gds_path)
        if gds_path.endswith(&#34;.gz&#34;):
            obj_bytes = gzip.decompress(ntf.read())
        else:
            obj_bytes = ntf.read()
        ntf.close()
        return obj_bytes
    except Exception as e:
        message = f&#34;Failed on reading the specified GDS File ({get_gds_uri(gds_volume_name, gds_path)})&#34;
        raise FileNotFoundError(f&#34;{message} Exception: {e}&#34;)


def get_file_list(volume_name: str, path: str = &#34;/*&#34;) -&gt; list:
    return get_files_list(volume_name=volume_name, paths=[path])


def get_files_list(volume_name: str, paths=None) -&gt; list:
    &#34;&#34;&#34;Use cases
    Get file listing for given volume_name and paths.
    If path are not specified, it will return listing of all files under given volume_name.
    Listing is recursive in nature for a volume or folder path.
    You can still specify an absolute path for a file.
    PreSignedUrl is always included.

    :param volume_name:
    :param paths: default list all
    :return: List of libgds.FileResponse objects
    :rtype: list[FileResponse]
    &#34;&#34;&#34;

    if paths is None:
        paths = [&#34;/*&#34;]

    items = []

    with libgds.ApiClient(configuration(libgds)) as api_client:
        files_api = libgds.FilesApi(api_client)
        try:
            page_token = None
            while True:
                file_list: libgds.FileListResponse = files_api.list_files(
                    volume_name=[volume_name],
                    path=paths,
                    include=&#34;presignedUrl,totalItemCount&#34;,
                    page_size=1000,
                    page_token=page_token,
                )

                items.extend(file_list.items)

                page_token = file_list.next_page_token
                if not file_list.next_page_token:
                    break
            # while end

        except libgds.ApiException as e:
            logger.info(&#34;Exception when calling FilesApi: %s\n&#34; % e)

    return items


def download_gds_file(volume_name: str, path: str) -&gt; (NamedTemporaryFile, None):
    &#34;&#34;&#34;Retrieve _single_ GDS file

    It collects matching path (expect single file) through get_file_list.
    Hence, there should only be one item in the list.
    Then, we use the requests library to download the gds file from presigned URL to temporary storage.
    The downloaded file is back by NamedTemporaryFile and, therefore will be deleted once it goes &#39;out of scope&#39;.

    NOTE:
    It is caller responsibility to provide an absolute path to a file for the path parameter.
    If multiple files are found, it warns and return None.

    It is recommend to close NamedTemporaryFile after use.
    For example, work within closing context manager like so.
        with closing(ntf) as f:
            with open(f.name, newline=&#39;&#39;) as csv_file:
                csv_reader = csv.reader(csv_file, delimiter=&#39;,&#39;)
                ...
                ...

    :param volume_name:
    :param path: the GDS path of the file to download
    :return NamedTemporaryFile: or None if file is not found or multiple files are found
    &#34;&#34;&#34;

    logger.info(f&#34;Downloading file from GDS: gds://{volume_name}{path}&#34;)

    file_list = get_file_list(volume_name=volume_name, path=path)

    if not len(file_list) == 1:
        logger.warning(f&#34;Please specify a single file. Found {len(file_list)} files at gds://{volume_name}{path}&#34;)
        return None

    if len(file_list) == 0:
        logger.warning(f&#34;File not found: gds://{volume_name}{path}&#34;)
        return None

    file: libgds.FileResponse = file_list[0]

    gds_req = requests.get(file.presigned_url)

    ntf = NamedTemporaryFile()
    with open(ntf.name, &#39;wb&#39;) as f:
        f.write(gds_req.content)

    return ntf


def presign_gds_file(file_id: str, volume_name: str, path_: str, presigned_url_mode: str = &#34;Attachment&#34;) -&gt; (bool, str):
    with libgds.ApiClient(configuration(libgds)) as gds_client:
        files_api = libgds.FilesApi(gds_client)
        try:
            file_details: libgds.FileResponse = files_api.get_file(file_id=file_id,
                                                                   presigned_url_mode=presigned_url_mode)
            return True, file_details.presigned_url
        except libgds.ApiException as e:
            message = f&#34;Failed to sign the specified GDS file (gds://{volume_name}{path_}). Exception - {e}&#34;
            logger.error(message)
            return False, message


def get_files_from_gds_by_suffix(location: str, file_suffix: str) -&gt; List[str]:
    &#34;&#34;&#34;
    Use case:
        For given gds://vol/path/to/folder find file end with extension defined in file_suffix e.g. &#39;.bam&#39;
        Collect all found and return a list [&#39;gds://location/1.bam&#39;, ...]
    &#34;&#34;&#34;
    volume_name, path_ = parse_path(location)

    file_list = []

    with libgds.ApiClient(configuration(libgds)) as api_client:
        files_api = libgds.FilesApi(api_client)
        try:
            page_token = None
            while True:
                file_list_response: libgds.FileListResponse = files_api.list_files(
                    volume_name=[volume_name],
                    path=[f&#34;{path_}/*&#34;],
                    page_size=1000,
                    page_token=page_token,
                )

                for item in file_list_response.items:
                    file_: libgds.FileResponse = item

                    if file_.name.endswith(file_suffix):
                        file_list.append(f&#34;gds://{file_.volume_name}{file_.path}&#34;)

                page_token = file_list_response.next_page_token
                if not file_list_response.next_page_token:
                    break
            # while end

        except libgds.ApiException as e:
            logger.error(f&#34;Exception when calling list_files: \n{e}&#34;)

    return file_list</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="libica.app.gds.check_file"><code class="name flex">
<span>def <span class="ident">check_file</span></span>(<span>gds_path) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>See check_path</p>
<p>NOTE: This is for "error checking" use case, hence, it may raise FileNotFoundError</p>
<p>:param gds_path:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_file(gds_path) -&gt; list:
    &#34;&#34;&#34;See check_path

    NOTE: This is for &#34;error checking&#34; use case, hence, it may raise FileNotFoundError

    :param gds_path:
    :return:
    &#34;&#34;&#34;
    vol, path = parse_path(gds_path)
    return check_path(vol, path)</code></pre>
</details>
</dd>
<dt id="libica.app.gds.check_path"><code class="name flex">
<span>def <span class="ident">check_path</span></span>(<span>volume_name: str, path: str) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Use cases
This behave like UNIX <code>ls</code> command whereas you can check an absolute path to file or a directory.
You can use it to check whether a file exist in GDS because it raises FileNotFoundError.
Otherwise, it return file(s) found.</p>
<p>NOTE: This wrap get_file_list but more strict to raise FileNotFoundError if zero match.</p>
<p>:param volume_name:
:param path:
:return: List of libgds.FileResponse objects
:rtype: list[FileResponse]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_path(volume_name: str, path: str) -&gt; list:
    &#34;&#34;&#34;Use cases
    This behave like UNIX `ls` command whereas you can check an absolute path to file or a directory.
    You can use it to check whether a file exist in GDS because it raises FileNotFoundError.
    Otherwise, it return file(s) found.

    NOTE: This wrap get_file_list but more strict to raise FileNotFoundError if zero match.

    :param volume_name:
    :param path:
    :return: List of libgds.FileResponse objects
    :rtype: list[FileResponse]
    &#34;&#34;&#34;

    files = get_file_list(volume_name=volume_name, path=path)
    if len(files) == 0:
        raise FileNotFoundError(f&#34;Could not get file: gds://{volume_name}{path}&#34;)
    return files</code></pre>
</details>
</dd>
<dt id="libica.app.gds.download_gds_file"><code class="name flex">
<span>def <span class="ident">download_gds_file</span></span>(<span>volume_name: str, path: str) ‑> (<function NamedTemporaryFile at 0x10a11dbd0>, None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve <em>single</em> GDS file</p>
<p>It collects matching path (expect single file) through get_file_list.
Hence, there should only be one item in the list.
Then, we use the requests library to download the gds file from presigned URL to temporary storage.
The downloaded file is back by NamedTemporaryFile and, therefore will be deleted once it goes 'out of scope'.</p>
<p>NOTE:
It is caller responsibility to provide an absolute path to a file for the path parameter.
If multiple files are found, it warns and return None.</p>
<p>It is recommend to close NamedTemporaryFile after use.
For example, work within closing context manager like so.
with closing(ntf) as f:
with open(f.name, newline='') as csv_file:
csv_reader = csv.reader(csv_file, delimiter=',')
&hellip;
&hellip;</p>
<p>:param volume_name:
:param path: the GDS path of the file to download
:return NamedTemporaryFile: or None if file is not found or multiple files are found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_gds_file(volume_name: str, path: str) -&gt; (NamedTemporaryFile, None):
    &#34;&#34;&#34;Retrieve _single_ GDS file

    It collects matching path (expect single file) through get_file_list.
    Hence, there should only be one item in the list.
    Then, we use the requests library to download the gds file from presigned URL to temporary storage.
    The downloaded file is back by NamedTemporaryFile and, therefore will be deleted once it goes &#39;out of scope&#39;.

    NOTE:
    It is caller responsibility to provide an absolute path to a file for the path parameter.
    If multiple files are found, it warns and return None.

    It is recommend to close NamedTemporaryFile after use.
    For example, work within closing context manager like so.
        with closing(ntf) as f:
            with open(f.name, newline=&#39;&#39;) as csv_file:
                csv_reader = csv.reader(csv_file, delimiter=&#39;,&#39;)
                ...
                ...

    :param volume_name:
    :param path: the GDS path of the file to download
    :return NamedTemporaryFile: or None if file is not found or multiple files are found
    &#34;&#34;&#34;

    logger.info(f&#34;Downloading file from GDS: gds://{volume_name}{path}&#34;)

    file_list = get_file_list(volume_name=volume_name, path=path)

    if not len(file_list) == 1:
        logger.warning(f&#34;Please specify a single file. Found {len(file_list)} files at gds://{volume_name}{path}&#34;)
        return None

    if len(file_list) == 0:
        logger.warning(f&#34;File not found: gds://{volume_name}{path}&#34;)
        return None

    file: libgds.FileResponse = file_list[0]

    gds_req = requests.get(file.presigned_url)

    ntf = NamedTemporaryFile()
    with open(ntf.name, &#39;wb&#39;) as f:
        f.write(gds_req.content)

    return ntf</code></pre>
</details>
</dd>
<dt id="libica.app.gds.get_file_list"><code class="name flex">
<span>def <span class="ident">get_file_list</span></span>(<span>volume_name: str, path: str = '/*') ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file_list(volume_name: str, path: str = &#34;/*&#34;) -&gt; list:
    return get_files_list(volume_name=volume_name, paths=[path])</code></pre>
</details>
</dd>
<dt id="libica.app.gds.get_files_from_gds_by_suffix"><code class="name flex">
<span>def <span class="ident">get_files_from_gds_by_suffix</span></span>(<span>location: str, file_suffix: str) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Use case:
For given gds://vol/path/to/folder find file end with extension defined in file_suffix e.g. '.bam'
Collect all found and return a list ['gds://location/1.bam', &hellip;]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_files_from_gds_by_suffix(location: str, file_suffix: str) -&gt; List[str]:
    &#34;&#34;&#34;
    Use case:
        For given gds://vol/path/to/folder find file end with extension defined in file_suffix e.g. &#39;.bam&#39;
        Collect all found and return a list [&#39;gds://location/1.bam&#39;, ...]
    &#34;&#34;&#34;
    volume_name, path_ = parse_path(location)

    file_list = []

    with libgds.ApiClient(configuration(libgds)) as api_client:
        files_api = libgds.FilesApi(api_client)
        try:
            page_token = None
            while True:
                file_list_response: libgds.FileListResponse = files_api.list_files(
                    volume_name=[volume_name],
                    path=[f&#34;{path_}/*&#34;],
                    page_size=1000,
                    page_token=page_token,
                )

                for item in file_list_response.items:
                    file_: libgds.FileResponse = item

                    if file_.name.endswith(file_suffix):
                        file_list.append(f&#34;gds://{file_.volume_name}{file_.path}&#34;)

                page_token = file_list_response.next_page_token
                if not file_list_response.next_page_token:
                    break
            # while end

        except libgds.ApiException as e:
            logger.error(f&#34;Exception when calling list_files: \n{e}&#34;)

    return file_list</code></pre>
</details>
</dd>
<dt id="libica.app.gds.get_files_list"><code class="name flex">
<span>def <span class="ident">get_files_list</span></span>(<span>volume_name: str, paths=None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Use cases
Get file listing for given volume_name and paths.
If path are not specified, it will return listing of all files under given volume_name.
Listing is recursive in nature for a volume or folder path.
You can still specify an absolute path for a file.
PreSignedUrl is always included.</p>
<p>:param volume_name:
:param paths: default list all
:return: List of libgds.FileResponse objects
:rtype: list[FileResponse]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_files_list(volume_name: str, paths=None) -&gt; list:
    &#34;&#34;&#34;Use cases
    Get file listing for given volume_name and paths.
    If path are not specified, it will return listing of all files under given volume_name.
    Listing is recursive in nature for a volume or folder path.
    You can still specify an absolute path for a file.
    PreSignedUrl is always included.

    :param volume_name:
    :param paths: default list all
    :return: List of libgds.FileResponse objects
    :rtype: list[FileResponse]
    &#34;&#34;&#34;

    if paths is None:
        paths = [&#34;/*&#34;]

    items = []

    with libgds.ApiClient(configuration(libgds)) as api_client:
        files_api = libgds.FilesApi(api_client)
        try:
            page_token = None
            while True:
                file_list: libgds.FileListResponse = files_api.list_files(
                    volume_name=[volume_name],
                    path=paths,
                    include=&#34;presignedUrl,totalItemCount&#34;,
                    page_size=1000,
                    page_token=page_token,
                )

                items.extend(file_list.items)

                page_token = file_list.next_page_token
                if not file_list.next_page_token:
                    break
            # while end

        except libgds.ApiException as e:
            logger.info(&#34;Exception when calling FilesApi: %s\n&#34; % e)

    return items</code></pre>
</details>
</dd>
<dt id="libica.app.gds.get_gds_file_to_bytes"><code class="name flex">
<span>def <span class="ident">get_gds_file_to_bytes</span></span>(<span>gds_volume_name: str, gds_path: str) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>get_object_to_bytes API, with on-the-fly gzip detection and decompression</p>
<p>:param gds_volume_name:
:param gds_path:
:return bytes: bytes from the decompressed GDS File body</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gds_file_to_bytes(gds_volume_name: str, gds_path: str) -&gt; bytes:
    &#34;&#34;&#34;
    get_object_to_bytes API, with on-the-fly gzip detection and decompression

    :param gds_volume_name:
    :param gds_path:
    :return bytes: bytes from the decompressed GDS File body
    &#34;&#34;&#34;
    try:
        ntf = download_gds_file(gds_volume_name, gds_path)
        if gds_path.endswith(&#34;.gz&#34;):
            obj_bytes = gzip.decompress(ntf.read())
        else:
            obj_bytes = ntf.read()
        ntf.close()
        return obj_bytes
    except Exception as e:
        message = f&#34;Failed on reading the specified GDS File ({get_gds_uri(gds_volume_name, gds_path)})&#34;
        raise FileNotFoundError(f&#34;{message} Exception: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="libica.app.gds.get_gds_uri"><code class="name flex">
<span>def <span class="ident">get_gds_uri</span></span>(<span>gds_volume_name, gds_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gds_uri(gds_volume_name, gds_path):
    return f&#34;gds://{gds_volume_name}{gds_path}&#34;  # note gds path start with /</code></pre>
</details>
</dd>
<dt id="libica.app.gds.parse_path"><code class="name flex">
<span>def <span class="ident">parse_path</span></span>(<span>gds_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_path(gds_path):
    gds_url_obj = urlparse(gds_path)
    return gds_url_obj.netloc, gds_url_obj.path</code></pre>
</details>
</dd>
<dt id="libica.app.gds.presign_gds_file"><code class="name flex">
<span>def <span class="ident">presign_gds_file</span></span>(<span>file_id: str, volume_name: str, path_: str, presigned_url_mode: str = 'Attachment') ‑> (<class 'bool'>, <class 'str'>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def presign_gds_file(file_id: str, volume_name: str, path_: str, presigned_url_mode: str = &#34;Attachment&#34;) -&gt; (bool, str):
    with libgds.ApiClient(configuration(libgds)) as gds_client:
        files_api = libgds.FilesApi(gds_client)
        try:
            file_details: libgds.FileResponse = files_api.get_file(file_id=file_id,
                                                                   presigned_url_mode=presigned_url_mode)
            return True, file_details.presigned_url
        except libgds.ApiException as e:
            message = f&#34;Failed to sign the specified GDS file (gds://{volume_name}{path_}). Exception - {e}&#34;
            logger.error(message)
            return False, message</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="libica.app" href="index.html">libica.app</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="libica.app.gds.check_file" href="#libica.app.gds.check_file">check_file</a></code></li>
<li><code><a title="libica.app.gds.check_path" href="#libica.app.gds.check_path">check_path</a></code></li>
<li><code><a title="libica.app.gds.download_gds_file" href="#libica.app.gds.download_gds_file">download_gds_file</a></code></li>
<li><code><a title="libica.app.gds.get_file_list" href="#libica.app.gds.get_file_list">get_file_list</a></code></li>
<li><code><a title="libica.app.gds.get_files_from_gds_by_suffix" href="#libica.app.gds.get_files_from_gds_by_suffix">get_files_from_gds_by_suffix</a></code></li>
<li><code><a title="libica.app.gds.get_files_list" href="#libica.app.gds.get_files_list">get_files_list</a></code></li>
<li><code><a title="libica.app.gds.get_gds_file_to_bytes" href="#libica.app.gds.get_gds_file_to_bytes">get_gds_file_to_bytes</a></code></li>
<li><code><a title="libica.app.gds.get_gds_uri" href="#libica.app.gds.get_gds_uri">get_gds_uri</a></code></li>
<li><code><a title="libica.app.gds.parse_path" href="#libica.app.gds.parse_path">parse_path</a></code></li>
<li><code><a title="libica.app.gds.presign_gds_file" href="#libica.app.gds.presign_gds_file">presign_gds_file</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>