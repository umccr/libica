<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>libica.openapi.v3.rest API documentation</title>
<meta name="description" content="ICA Rest API â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>libica.openapi.v3.rest</code></h1>
</header>
<section id="section-intro">
<p>ICA Rest API</p>
<p>This API can be used to interact with Illumina Connected Analytics.<br> <h2>Authentication</h2> <p> Authentication to the
API can be done in multiple ways:<br> <ul><li>For the entire API, except for the POST /tokens endpoint: API-key + JWT</li> <li>Only for the POST /tokens endpoint: API-key + Basic Authentication</li></ul> </p> <p> <h4>API-key</h4> API keys are managed within the Illumina portal where you can manage your profile after you have logged on. The API-key has to be provided in the X-API-Key header parameter when executing API calls to ICA. In the background, a JWT will be requested at the IDP of Illumina to create a session. A good practice is to not use the API-key for every API call, but to first generate a JWT and to use that for authentication in subsequent calls.<br> </p> <p> <h4>JWT</h4> To avoid using an API-key for each call, we recommend to request a JWT via the POST /tokens endpoint
using this API-key. The JWT will expire after a pre-configured period specified by a tenant administrator through the IAM console in the Illumina portal. The JWT is the preferred way for authentication.<br>A not yet expired, still valid JWT could be refreshed using the POST /tokens:refresh endpoint.<br>Refreshing the JWT is not possible if the JWT was generated by using an API-key.<br> </p> <p> <h4>Basic Authentication</h4> Basic authentication is only supported by the POST /tokens endpoint for generating a JWT. Use "Basic base64encoded(emailaddress:password)" in the "Authorization" header parameter for this authentication method. In case having access to multiple tenants using the same email-address, also provide the "tenant" request parameter to indicate what tenant you would like to request a JWT for. </p> <p> <h2>Compression</h2> If the API client provides request header 'Accept-Encoding' with value 'gzip', then the API applies GZIP compression on the JSON response. This significantly reduces the size and thus the download time of the response, which results in faster end-to-end API calls. In case of compression, the API also provides response header 'Content-Encoding' with value 'gzip', as indication for the client that decompression is required. </p> </p>
<p>The version of the OpenAPI document: 3
Generated by OpenAPI Generator (<a href="https://openapi-generator.tech">https://openapi-generator.tech</a>)</p>
<p>Do not edit the class manually.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="libica.openapi.v3.rest.is_socks_proxy_url"><code class="name flex">
<span>def <span class="ident">is_socks_proxy_url</span></span>(<span>url)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_socks_proxy_url(url):
    if url is None:
        return False
    split_section = url.split(&#34;://&#34;)
    if len(split_section) &lt; 2:
        return False
    else:
        return split_section[0].lower() in SUPPORTED_SOCKS_PROXIES</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="libica.openapi.v3.rest.RESTClientObject"><code class="flex name class">
<span>class <span class="ident">RESTClientObject</span></span>
<span>(</span><span>configuration)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RESTClientObject:

    def __init__(self, configuration) -&gt; None:
        # urllib3.PoolManager will pass all kw parameters to connectionpool
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501

        # cert_reqs
        if configuration.verify_ssl:
            cert_reqs = ssl.CERT_REQUIRED
        else:
            cert_reqs = ssl.CERT_NONE

        pool_args = {
            &#34;cert_reqs&#34;: cert_reqs,
            &#34;ca_certs&#34;: configuration.ssl_ca_cert,
            &#34;cert_file&#34;: configuration.cert_file,
            &#34;key_file&#34;: configuration.key_file,
            &#34;ca_cert_data&#34;: configuration.ca_cert_data,
        }
        if configuration.assert_hostname is not None:
            pool_args[&#39;assert_hostname&#39;] = (
                configuration.assert_hostname
            )

        if configuration.retries is not None:
            pool_args[&#39;retries&#39;] = configuration.retries

        if configuration.tls_server_name:
            pool_args[&#39;server_hostname&#39;] = configuration.tls_server_name


        if configuration.socket_options is not None:
            pool_args[&#39;socket_options&#39;] = configuration.socket_options

        if configuration.connection_pool_maxsize is not None:
            pool_args[&#39;maxsize&#39;] = configuration.connection_pool_maxsize

        # https pool manager
        self.pool_manager: urllib3.PoolManager

        if configuration.proxy:
            if is_socks_proxy_url(configuration.proxy):
                from urllib3.contrib.socks import SOCKSProxyManager
                pool_args[&#34;proxy_url&#34;] = configuration.proxy
                pool_args[&#34;headers&#34;] = configuration.proxy_headers
                self.pool_manager = SOCKSProxyManager(**pool_args)
            else:
                pool_args[&#34;proxy_url&#34;] = configuration.proxy
                pool_args[&#34;proxy_headers&#34;] = configuration.proxy_headers
                self.pool_manager = urllib3.ProxyManager(**pool_args)
        else:
            self.pool_manager = urllib3.PoolManager(**pool_args)

    def request(
        self,
        method,
        url,
        headers=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ):
        &#34;&#34;&#34;Perform requests.

        :param method: http request method
        :param url: http request url
        :param headers: http request headers
        :param body: request json body, for `application/json`
        :param post_params: request post parameters,
                            `application/x-www-form-urlencoded`
                            and `multipart/form-data`
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        &#34;&#34;&#34;
        method = method.upper()
        assert method in [
            &#39;GET&#39;,
            &#39;HEAD&#39;,
            &#39;DELETE&#39;,
            &#39;POST&#39;,
            &#39;PUT&#39;,
            &#39;PATCH&#39;,
            &#39;OPTIONS&#39;
        ]

        if post_params and body:
            raise ApiValueError(
                &#34;body parameter cannot be used with post_params parameter.&#34;
            )

        post_params = post_params or {}
        headers = headers or {}

        timeout = None
        if _request_timeout:
            if isinstance(_request_timeout, (int, float)):
                timeout = urllib3.Timeout(total=_request_timeout)
            elif (
                    isinstance(_request_timeout, tuple)
                    and len(_request_timeout) == 2
                ):
                timeout = urllib3.Timeout(
                    connect=_request_timeout[0],
                    read=_request_timeout[1]
                )

        try:
            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
            if method in [&#39;POST&#39;, &#39;PUT&#39;, &#39;PATCH&#39;, &#39;OPTIONS&#39;, &#39;DELETE&#39;]:

                # no content type provided or payload is json
                content_type = headers.get(&#39;Content-Type&#39;)
                if (
                    not content_type
                    or re.search(&#39;json&#39;, content_type, re.IGNORECASE)
                ):
                    request_body = None
                    if body is not None:
                        request_body = json.dumps(body)
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == &#39;application/x-www-form-urlencoded&#39;:
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=False,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif content_type == &#39;multipart/form-data&#39;:
                    # must del headers[&#39;Content-Type&#39;], or the correct
                    # Content-Type which generated by urllib3 will be
                    # overwritten.
                    del headers[&#39;Content-Type&#39;]
                    # Ensures that dict objects are serialized
                    post_params = [(a, json.dumps(b)) if isinstance(b, dict) else (a,b) for a, b in post_params]
                    r = self.pool_manager.request(
                        method,
                        url,
                        fields=post_params,
                        encode_multipart=True,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                # Pass a `string` parameter directly in the body to support
                # other content types than JSON when `body` argument is
                # provided in serialized form.
                elif isinstance(body, str) or isinstance(body, bytes):
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=body,
                        timeout=timeout,
                        headers=headers,
                        preload_content=False
                    )
                elif headers[&#39;Content-Type&#39;].startswith(&#39;text/&#39;) and isinstance(body, bool):
                    request_body = &#34;true&#34; if body else &#34;false&#34;
                    r = self.pool_manager.request(
                        method,
                        url,
                        body=request_body,
                        preload_content=False,
                        timeout=timeout,
                        headers=headers)
                else:
                    # Cannot generate the request from given parameters
                    msg = &#34;&#34;&#34;Cannot prepare a request message for provided
                             arguments. Please check that your arguments match
                             declared content type.&#34;&#34;&#34;
                    raise ApiException(status=0, reason=msg)
            # For `GET`, `HEAD`
            else:
                r = self.pool_manager.request(
                    method,
                    url,
                    fields={},
                    timeout=timeout,
                    headers=headers,
                    preload_content=False
                )
        except urllib3.exceptions.SSLError as e:
            msg = &#34;\n&#34;.join([type(e).__name__, str(e)])
            raise ApiException(status=0, reason=msg)

        return RESTResponse(r)</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="libica.openapi.v3.rest.RESTClientObject.request"><code class="name flex">
<span>def <span class="ident">request</span></span>(<span>self, method, url, headers=None, body=None, post_params=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request(
    self,
    method,
    url,
    headers=None,
    body=None,
    post_params=None,
    _request_timeout=None
):
    &#34;&#34;&#34;Perform requests.

    :param method: http request method
    :param url: http request url
    :param headers: http request headers
    :param body: request json body, for `application/json`
    :param post_params: request post parameters,
                        `application/x-www-form-urlencoded`
                        and `multipart/form-data`
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    &#34;&#34;&#34;
    method = method.upper()
    assert method in [
        &#39;GET&#39;,
        &#39;HEAD&#39;,
        &#39;DELETE&#39;,
        &#39;POST&#39;,
        &#39;PUT&#39;,
        &#39;PATCH&#39;,
        &#39;OPTIONS&#39;
    ]

    if post_params and body:
        raise ApiValueError(
            &#34;body parameter cannot be used with post_params parameter.&#34;
        )

    post_params = post_params or {}
    headers = headers or {}

    timeout = None
    if _request_timeout:
        if isinstance(_request_timeout, (int, float)):
            timeout = urllib3.Timeout(total=_request_timeout)
        elif (
                isinstance(_request_timeout, tuple)
                and len(_request_timeout) == 2
            ):
            timeout = urllib3.Timeout(
                connect=_request_timeout[0],
                read=_request_timeout[1]
            )

    try:
        # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
        if method in [&#39;POST&#39;, &#39;PUT&#39;, &#39;PATCH&#39;, &#39;OPTIONS&#39;, &#39;DELETE&#39;]:

            # no content type provided or payload is json
            content_type = headers.get(&#39;Content-Type&#39;)
            if (
                not content_type
                or re.search(&#39;json&#39;, content_type, re.IGNORECASE)
            ):
                request_body = None
                if body is not None:
                    request_body = json.dumps(body)
                r = self.pool_manager.request(
                    method,
                    url,
                    body=request_body,
                    timeout=timeout,
                    headers=headers,
                    preload_content=False
                )
            elif content_type == &#39;application/x-www-form-urlencoded&#39;:
                r = self.pool_manager.request(
                    method,
                    url,
                    fields=post_params,
                    encode_multipart=False,
                    timeout=timeout,
                    headers=headers,
                    preload_content=False
                )
            elif content_type == &#39;multipart/form-data&#39;:
                # must del headers[&#39;Content-Type&#39;], or the correct
                # Content-Type which generated by urllib3 will be
                # overwritten.
                del headers[&#39;Content-Type&#39;]
                # Ensures that dict objects are serialized
                post_params = [(a, json.dumps(b)) if isinstance(b, dict) else (a,b) for a, b in post_params]
                r = self.pool_manager.request(
                    method,
                    url,
                    fields=post_params,
                    encode_multipart=True,
                    timeout=timeout,
                    headers=headers,
                    preload_content=False
                )
            # Pass a `string` parameter directly in the body to support
            # other content types than JSON when `body` argument is
            # provided in serialized form.
            elif isinstance(body, str) or isinstance(body, bytes):
                r = self.pool_manager.request(
                    method,
                    url,
                    body=body,
                    timeout=timeout,
                    headers=headers,
                    preload_content=False
                )
            elif headers[&#39;Content-Type&#39;].startswith(&#39;text/&#39;) and isinstance(body, bool):
                request_body = &#34;true&#34; if body else &#34;false&#34;
                r = self.pool_manager.request(
                    method,
                    url,
                    body=request_body,
                    preload_content=False,
                    timeout=timeout,
                    headers=headers)
            else:
                # Cannot generate the request from given parameters
                msg = &#34;&#34;&#34;Cannot prepare a request message for provided
                         arguments. Please check that your arguments match
                         declared content type.&#34;&#34;&#34;
                raise ApiException(status=0, reason=msg)
        # For `GET`, `HEAD`
        else:
            r = self.pool_manager.request(
                method,
                url,
                fields={},
                timeout=timeout,
                headers=headers,
                preload_content=False
            )
    except urllib3.exceptions.SSLError as e:
        msg = &#34;\n&#34;.join([type(e).__name__, str(e)])
        raise ApiException(status=0, reason=msg)

    return RESTResponse(r)</code></pre>
</details>
<div class="desc"><p>Perform requests.</p>
<p>:param method: http request method
:param url: http request url
:param headers: http request headers
:param body: request json body, for <code>application/json</code>
:param post_params: request post parameters,
<code>application/x-www-form-urlencoded</code>
and <code>multipart/form-data</code>
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.</p></div>
</dd>
</dl>
</dd>
<dt id="libica.openapi.v3.rest.RESTResponse"><code class="flex name class">
<span>class <span class="ident">RESTResponse</span></span>
<span>(</span><span>resp)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RESTResponse(io.IOBase):

    def __init__(self, resp) -&gt; None:
        self.response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = None

    def read(self):
        if self.data is None:
            self.data = self.response.data
        return self.data

    def getheaders(self):
        &#34;&#34;&#34;Returns a dictionary of the response headers.&#34;&#34;&#34;
        return self.response.headers

    def getheader(self, name, default=None):
        &#34;&#34;&#34;Returns a given response header.&#34;&#34;&#34;
        return self.response.headers.get(name, default)</code></pre>
</details>
<div class="desc"><p>The abstract base class for all I/O classes.</p>
<p>This class provides dummy implementations for many methods that
derived classes can override selectively; the default implementations
represent a file that cannot be read, written or seeked.</p>
<p>Even though IOBase does not declare read, readinto, or write because
their signatures will vary, implementations and clients should
consider those methods part of the interface. Also, implementations
may raise UnsupportedOperation when operations they do not support are
called.</p>
<p>The basic type used for binary data read from or written to a file is
bytes. Other bytes-like objects are accepted as method arguments too.
In some cases (such as readinto), a writable object is required. Text
I/O classes work with str data.</p>
<p>Note that calling any method (except additional calls to close(),
which are ignored) on a closed stream should raise a ValueError.</p>
<p>IOBase (and its subclasses) support the iterator protocol, meaning
that an IOBase object can be iterated over yielding the lines in a
stream.</p>
<p>IOBase also supports the :keyword:<code>with</code> statement. In this example,
fp is closed after the suite of the with statement is complete:</p>
<p>with open('spam.txt', 'r') as fp:
fp.write('Spam and eggs!')</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>io.IOBase</li>
<li>_io._IOBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="libica.openapi.v3.rest.RESTResponse.getheader"><code class="name flex">
<span>def <span class="ident">getheader</span></span>(<span>self, name, default=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getheader(self, name, default=None):
    &#34;&#34;&#34;Returns a given response header.&#34;&#34;&#34;
    return self.response.headers.get(name, default)</code></pre>
</details>
<div class="desc"><p>Returns a given response header.</p></div>
</dd>
<dt id="libica.openapi.v3.rest.RESTResponse.getheaders"><code class="name flex">
<span>def <span class="ident">getheaders</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getheaders(self):
    &#34;&#34;&#34;Returns a dictionary of the response headers.&#34;&#34;&#34;
    return self.response.headers</code></pre>
</details>
<div class="desc"><p>Returns a dictionary of the response headers.</p></div>
</dd>
<dt id="libica.openapi.v3.rest.RESTResponse.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self):
    if self.data is None:
        self.data = self.response.data
    return self.data</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="libica.openapi.v3" href="index.html">libica.openapi.v3</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="libica.openapi.v3.rest.is_socks_proxy_url" href="#libica.openapi.v3.rest.is_socks_proxy_url">is_socks_proxy_url</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="libica.openapi.v3.rest.RESTClientObject" href="#libica.openapi.v3.rest.RESTClientObject">RESTClientObject</a></code></h4>
<ul class="">
<li><code><a title="libica.openapi.v3.rest.RESTClientObject.request" href="#libica.openapi.v3.rest.RESTClientObject.request">request</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="libica.openapi.v3.rest.RESTResponse" href="#libica.openapi.v3.rest.RESTResponse">RESTResponse</a></code></h4>
<ul class="">
<li><code><a title="libica.openapi.v3.rest.RESTResponse.getheader" href="#libica.openapi.v3.rest.RESTResponse.getheader">getheader</a></code></li>
<li><code><a title="libica.openapi.v3.rest.RESTResponse.getheaders" href="#libica.openapi.v3.rest.RESTResponse.getheaders">getheaders</a></code></li>
<li><code><a title="libica.openapi.v3.rest.RESTResponse.read" href="#libica.openapi.v3.rest.RESTResponse.read">read</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
