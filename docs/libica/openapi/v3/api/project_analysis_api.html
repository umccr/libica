<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>libica.openapi.v3.api.project_analysis_api API documentation</title>
<meta name="description" content="ICA Rest API â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>libica.openapi.v3.api.project_analysis_api</code></h1>
</header>
<section id="section-intro">
<p>ICA Rest API</p>
<p>This API can be used to interact with Illumina Connected Analytics.<br> <h2>Authentication</h2> <p> Authentication to the
API can be done in multiple ways:<br> <ul><li>For the entire API, except for the POST /tokens endpoint: API-key + JWT</li> <li>Only for the POST /tokens endpoint: API-key + Basic Authentication</li></ul> </p> <p> <h4>API-key</h4> API keys are managed within the Illumina portal where you can manage your profile after you have logged on. The API-key has to be provided in the X-API-Key header parameter when executing API calls to ICA. In the background, a JWT will be requested at the IDP of Illumina to create a session. A good practice is to not use the API-key for every API call, but to first generate a JWT and to use that for authentication in subsequent calls.<br> </p> <p> <h4>JWT</h4> To avoid using an API-key for each call, we recommend to request a JWT via the POST /tokens endpoint
using this API-key. The JWT will expire after a pre-configured period specified by a tenant administrator through the IAM console in the Illumina portal. The JWT is the preferred way for authentication.<br>A not yet expired, still valid JWT could be refreshed using the POST /tokens:refresh endpoint.<br>Refreshing the JWT is not possible if the JWT was generated by using an API-key.<br> </p> <p> <h4>Basic Authentication</h4> Basic authentication is only supported by the POST /tokens endpoint for generating a JWT. Use "Basic base64encoded(emailaddress:password)" in the "Authorization" header parameter for this authentication method. In case having access to multiple tenants using the same email-address, also provide the "tenant" request parameter to indicate what tenant you would like to request a JWT for. </p> <p> <h2>Compression</h2> If the API client provides request header 'Accept-Encoding' with value 'gzip', then the API applies GZIP compression on the JSON response. This significantly reduces the size and thus the download time of the response, which results in faster end-to-end API calls. In case of compression, the API also provides response header 'Content-Encoding' with value 'gzip', as indication for the client that decompression is required. </p> </p>
<p>The version of the OpenAPI document: 3
Generated by OpenAPI Generator (<a href="https://openapi-generator.tech">https://openapi-generator.tech</a>)</p>
<p>Do not edit the class manually.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi"><code class="flex name class">
<span>class <span class="ident">ProjectAnalysisApi</span></span>
<span>(</span><span>api_client=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProjectAnalysisApi:
    &#34;&#34;&#34;NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    &#34;&#34;&#34;

    def __init__(self, api_client=None) -&gt; None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def abort_analysis(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to abort&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Abort an analysis.

        Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to abort (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._abort_analysis_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def abort_analysis_with_http_info(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to abort&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[None]:
        &#34;&#34;&#34;Abort an analysis.

        Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to abort (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._abort_analysis_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def abort_analysis_without_preload_content(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to abort&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Abort an analysis.

        Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to abort (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._abort_analysis_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _abort_analysis_serialize(
        self,
        project_id,
        analysis_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if analysis_id is not None:
            _path_params[&#39;analysisId&#39;] = analysis_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses/{analysisId}:abort&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_cwl_analysis(
        self,
        project_id: StrictStr,
        create_cwl_analysis: Annotated[CreateCwlAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisV4:
        &#34;&#34;&#34;(Deprecated) Create and start an analysis for a CWL pipeline.

        # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

        :param project_id: (required)
        :type project_id: str
        :param create_cwl_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_cwl_analysis: CreateCwlAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501
        warnings.warn(&#34;POST /api/projects/{projectId}/analysis:cwl is deprecated.&#34;, DeprecationWarning)

        _param = self._create_cwl_analysis_serialize(
            project_id=project_id,
            create_cwl_analysis=create_cwl_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_cwl_analysis_with_http_info(
        self,
        project_id: StrictStr,
        create_cwl_analysis: Annotated[CreateCwlAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisV4]:
        &#34;&#34;&#34;(Deprecated) Create and start an analysis for a CWL pipeline.

        # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

        :param project_id: (required)
        :type project_id: str
        :param create_cwl_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_cwl_analysis: CreateCwlAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501
        warnings.warn(&#34;POST /api/projects/{projectId}/analysis:cwl is deprecated.&#34;, DeprecationWarning)

        _param = self._create_cwl_analysis_serialize(
            project_id=project_id,
            create_cwl_analysis=create_cwl_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_cwl_analysis_without_preload_content(
        self,
        project_id: StrictStr,
        create_cwl_analysis: Annotated[CreateCwlAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;(Deprecated) Create and start an analysis for a CWL pipeline.

        # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

        :param project_id: (required)
        :type project_id: str
        :param create_cwl_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_cwl_analysis: CreateCwlAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501
        warnings.warn(&#34;POST /api/projects/{projectId}/analysis:cwl is deprecated.&#34;, DeprecationWarning)

        _param = self._create_cwl_analysis_serialize(
            project_id=project_id,
            create_cwl_analysis=create_cwl_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_cwl_analysis_serialize(
        self,
        project_id,
        create_cwl_analysis,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        # process the header parameters
        if idempotency_key is not None:
            _header_params[&#39;Idempotency-Key&#39;] = idempotency_key
        # process the form parameters
        # process the body parameter
        if create_cwl_analysis is not None:
            _body_params = create_cwl_analysis


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;application/vnd.illumina.v4+json&#39;, 
                        &#39;application/vnd.illumina.v3+json&#39;, 
                        &#39;application/json&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/analysis:cwl&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_cwl_analysis_with_json_input(
        self,
        project_id: StrictStr,
        create_cwl_with_json_input_analysis: Annotated[CreateCwlWithJsonInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisV4:
        &#34;&#34;&#34;Create and start an analysis for a CWL pipeline with an input.json.

        This endpoint is intended to be used with an input.json and will bypass the input form. The combination of using this endpoint with an input.json for a json-form based pipeline with sensitive fields defined is not possible.

        :param project_id: (required)
        :type project_id: str
        :param create_cwl_with_json_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_cwl_with_json_input_analysis: CreateCwlWithJsonInputAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_analysis_with_json_input_serialize(
            project_id=project_id,
            create_cwl_with_json_input_analysis=create_cwl_with_json_input_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_cwl_analysis_with_json_input_with_http_info(
        self,
        project_id: StrictStr,
        create_cwl_with_json_input_analysis: Annotated[CreateCwlWithJsonInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisV4]:
        &#34;&#34;&#34;Create and start an analysis for a CWL pipeline with an input.json.

        This endpoint is intended to be used with an input.json and will bypass the input form. The combination of using this endpoint with an input.json for a json-form based pipeline with sensitive fields defined is not possible.

        :param project_id: (required)
        :type project_id: str
        :param create_cwl_with_json_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_cwl_with_json_input_analysis: CreateCwlWithJsonInputAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_analysis_with_json_input_serialize(
            project_id=project_id,
            create_cwl_with_json_input_analysis=create_cwl_with_json_input_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_cwl_analysis_with_json_input_without_preload_content(
        self,
        project_id: StrictStr,
        create_cwl_with_json_input_analysis: Annotated[CreateCwlWithJsonInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Create and start an analysis for a CWL pipeline with an input.json.

        This endpoint is intended to be used with an input.json and will bypass the input form. The combination of using this endpoint with an input.json for a json-form based pipeline with sensitive fields defined is not possible.

        :param project_id: (required)
        :type project_id: str
        :param create_cwl_with_json_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_cwl_with_json_input_analysis: CreateCwlWithJsonInputAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_analysis_with_json_input_serialize(
            project_id=project_id,
            create_cwl_with_json_input_analysis=create_cwl_with_json_input_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_cwl_analysis_with_json_input_serialize(
        self,
        project_id,
        create_cwl_with_json_input_analysis,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        # process the header parameters
        if idempotency_key is not None:
            _header_params[&#39;Idempotency-Key&#39;] = idempotency_key
        # process the form parameters
        # process the body parameter
        if create_cwl_with_json_input_analysis is not None:
            _body_params = create_cwl_with_json_input_analysis


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;application/vnd.illumina.v4+json&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/analysis:cwlWithJsonInput&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_cwl_analysis_with_structured_input(
        self,
        project_id: StrictStr,
        create_cwl_with_structured_input_analysis: Annotated[CreateCwlWithStructuredInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisV4:
        &#34;&#34;&#34;Create and start an analysis for a CWL pipeline with a structured input.


        :param project_id: (required)
        :type project_id: str
        :param create_cwl_with_structured_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_cwl_with_structured_input_analysis: CreateCwlWithStructuredInputAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_analysis_with_structured_input_serialize(
            project_id=project_id,
            create_cwl_with_structured_input_analysis=create_cwl_with_structured_input_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_cwl_analysis_with_structured_input_with_http_info(
        self,
        project_id: StrictStr,
        create_cwl_with_structured_input_analysis: Annotated[CreateCwlWithStructuredInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisV4]:
        &#34;&#34;&#34;Create and start an analysis for a CWL pipeline with a structured input.


        :param project_id: (required)
        :type project_id: str
        :param create_cwl_with_structured_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_cwl_with_structured_input_analysis: CreateCwlWithStructuredInputAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_analysis_with_structured_input_serialize(
            project_id=project_id,
            create_cwl_with_structured_input_analysis=create_cwl_with_structured_input_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_cwl_analysis_with_structured_input_without_preload_content(
        self,
        project_id: StrictStr,
        create_cwl_with_structured_input_analysis: Annotated[CreateCwlWithStructuredInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Create and start an analysis for a CWL pipeline with a structured input.


        :param project_id: (required)
        :type project_id: str
        :param create_cwl_with_structured_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_cwl_with_structured_input_analysis: CreateCwlWithStructuredInputAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_analysis_with_structured_input_serialize(
            project_id=project_id,
            create_cwl_with_structured_input_analysis=create_cwl_with_structured_input_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_cwl_analysis_with_structured_input_serialize(
        self,
        project_id,
        create_cwl_with_structured_input_analysis,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        # process the header parameters
        if idempotency_key is not None:
            _header_params[&#39;Idempotency-Key&#39;] = idempotency_key
        # process the form parameters
        # process the body parameter
        if create_cwl_with_structured_input_analysis is not None:
            _body_params = create_cwl_with_structured_input_analysis


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;application/vnd.illumina.v4+json&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/analysis:cwlWithStructuredInput&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_cwl_json_analysis(
        self,
        project_id: StrictStr,
        create_cwl_json_analysis: Annotated[CreateCwlJsonAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisV4:
        &#34;&#34;&#34;Create and start an analysis for a JSON based CWL pipeline.


        :param project_id: (required)
        :type project_id: str
        :param create_cwl_json_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_cwl_json_analysis: CreateCwlJsonAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_json_analysis_serialize(
            project_id=project_id,
            create_cwl_json_analysis=create_cwl_json_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_cwl_json_analysis_with_http_info(
        self,
        project_id: StrictStr,
        create_cwl_json_analysis: Annotated[CreateCwlJsonAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisV4]:
        &#34;&#34;&#34;Create and start an analysis for a JSON based CWL pipeline.


        :param project_id: (required)
        :type project_id: str
        :param create_cwl_json_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_cwl_json_analysis: CreateCwlJsonAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_json_analysis_serialize(
            project_id=project_id,
            create_cwl_json_analysis=create_cwl_json_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_cwl_json_analysis_without_preload_content(
        self,
        project_id: StrictStr,
        create_cwl_json_analysis: Annotated[CreateCwlJsonAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Create and start an analysis for a JSON based CWL pipeline.


        :param project_id: (required)
        :type project_id: str
        :param create_cwl_json_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_cwl_json_analysis: CreateCwlJsonAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_json_analysis_serialize(
            project_id=project_id,
            create_cwl_json_analysis=create_cwl_json_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_cwl_json_analysis_serialize(
        self,
        project_id,
        create_cwl_json_analysis,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        # process the header parameters
        if idempotency_key is not None:
            _header_params[&#39;Idempotency-Key&#39;] = idempotency_key
        # process the form parameters
        # process the body parameter
        if create_cwl_json_analysis is not None:
            _body_params = create_cwl_json_analysis


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;application/vnd.illumina.v4+json&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/analysis:cwlJson&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_nextflow_analysis(
        self,
        project_id: StrictStr,
        create_nextflow_analysis: Annotated[CreateNextflowAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisV4:
        &#34;&#34;&#34;Create and start an analysis for a Nextflow pipeline.

        # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

        :param project_id: (required)
        :type project_id: str
        :param create_nextflow_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_nextflow_analysis: CreateNextflowAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_analysis_serialize(
            project_id=project_id,
            create_nextflow_analysis=create_nextflow_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_nextflow_analysis_with_http_info(
        self,
        project_id: StrictStr,
        create_nextflow_analysis: Annotated[CreateNextflowAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisV4]:
        &#34;&#34;&#34;Create and start an analysis for a Nextflow pipeline.

        # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

        :param project_id: (required)
        :type project_id: str
        :param create_nextflow_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_nextflow_analysis: CreateNextflowAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_analysis_serialize(
            project_id=project_id,
            create_nextflow_analysis=create_nextflow_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_nextflow_analysis_without_preload_content(
        self,
        project_id: StrictStr,
        create_nextflow_analysis: Annotated[CreateNextflowAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Create and start an analysis for a Nextflow pipeline.

        # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

        :param project_id: (required)
        :type project_id: str
        :param create_nextflow_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_nextflow_analysis: CreateNextflowAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_analysis_serialize(
            project_id=project_id,
            create_nextflow_analysis=create_nextflow_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_nextflow_analysis_serialize(
        self,
        project_id,
        create_nextflow_analysis,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        # process the header parameters
        if idempotency_key is not None:
            _header_params[&#39;Idempotency-Key&#39;] = idempotency_key
        # process the form parameters
        # process the body parameter
        if create_nextflow_analysis is not None:
            _body_params = create_nextflow_analysis


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;application/vnd.illumina.v4+json&#39;, 
                        &#39;application/vnd.illumina.v3+json&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/analysis:nextflow&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_nextflow_analysis_with_custom_input(
        self,
        project_id: StrictStr,
        create_nextflow_with_custom_input_analysis: Annotated[CreateNextflowWithCustomInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisV4:
        &#34;&#34;&#34;Create and initiate an analysis for a Nextflow pipeline using a custom input, provided in either YAML format or an escaped JSON string.

        This endpoint is intended to be used with a custom input and will bypass the input form. The combination of using this endpoint with a custom input for a json-form based pipeline with sensitive fields defined is not possible.

        :param project_id: (required)
        :type project_id: str
        :param create_nextflow_with_custom_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_nextflow_with_custom_input_analysis: CreateNextflowWithCustomInputAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_analysis_with_custom_input_serialize(
            project_id=project_id,
            create_nextflow_with_custom_input_analysis=create_nextflow_with_custom_input_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_nextflow_analysis_with_custom_input_with_http_info(
        self,
        project_id: StrictStr,
        create_nextflow_with_custom_input_analysis: Annotated[CreateNextflowWithCustomInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisV4]:
        &#34;&#34;&#34;Create and initiate an analysis for a Nextflow pipeline using a custom input, provided in either YAML format or an escaped JSON string.

        This endpoint is intended to be used with a custom input and will bypass the input form. The combination of using this endpoint with a custom input for a json-form based pipeline with sensitive fields defined is not possible.

        :param project_id: (required)
        :type project_id: str
        :param create_nextflow_with_custom_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_nextflow_with_custom_input_analysis: CreateNextflowWithCustomInputAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_analysis_with_custom_input_serialize(
            project_id=project_id,
            create_nextflow_with_custom_input_analysis=create_nextflow_with_custom_input_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_nextflow_analysis_with_custom_input_without_preload_content(
        self,
        project_id: StrictStr,
        create_nextflow_with_custom_input_analysis: Annotated[CreateNextflowWithCustomInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Create and initiate an analysis for a Nextflow pipeline using a custom input, provided in either YAML format or an escaped JSON string.

        This endpoint is intended to be used with a custom input and will bypass the input form. The combination of using this endpoint with a custom input for a json-form based pipeline with sensitive fields defined is not possible.

        :param project_id: (required)
        :type project_id: str
        :param create_nextflow_with_custom_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_nextflow_with_custom_input_analysis: CreateNextflowWithCustomInputAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_analysis_with_custom_input_serialize(
            project_id=project_id,
            create_nextflow_with_custom_input_analysis=create_nextflow_with_custom_input_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_nextflow_analysis_with_custom_input_serialize(
        self,
        project_id,
        create_nextflow_with_custom_input_analysis,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        # process the header parameters
        if idempotency_key is not None:
            _header_params[&#39;Idempotency-Key&#39;] = idempotency_key
        # process the form parameters
        # process the body parameter
        if create_nextflow_with_custom_input_analysis is not None:
            _body_params = create_nextflow_with_custom_input_analysis


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;application/vnd.illumina.v4+json&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/analysis:nextflowWithCustomInput&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_nextflow_json_analysis(
        self,
        project_id: StrictStr,
        create_nextflow_json_analysis: Annotated[CreateNextflowJsonAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisV4:
        &#34;&#34;&#34;Create and start an analysis for a JSON based Nextflow pipeline.


        :param project_id: (required)
        :type project_id: str
        :param create_nextflow_json_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_nextflow_json_analysis: CreateNextflowJsonAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_json_analysis_serialize(
            project_id=project_id,
            create_nextflow_json_analysis=create_nextflow_json_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_nextflow_json_analysis_with_http_info(
        self,
        project_id: StrictStr,
        create_nextflow_json_analysis: Annotated[CreateNextflowJsonAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisV4]:
        &#34;&#34;&#34;Create and start an analysis for a JSON based Nextflow pipeline.


        :param project_id: (required)
        :type project_id: str
        :param create_nextflow_json_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_nextflow_json_analysis: CreateNextflowJsonAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_json_analysis_serialize(
            project_id=project_id,
            create_nextflow_json_analysis=create_nextflow_json_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_nextflow_json_analysis_without_preload_content(
        self,
        project_id: StrictStr,
        create_nextflow_json_analysis: Annotated[CreateNextflowJsonAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
        idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Create and start an analysis for a JSON based Nextflow pipeline.


        :param project_id: (required)
        :type project_id: str
        :param create_nextflow_json_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
        :type create_nextflow_json_analysis: CreateNextflowJsonAnalysis
        :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
        :type idempotency_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_json_analysis_serialize(
            project_id=project_id,
            create_nextflow_json_analysis=create_nextflow_json_analysis,
            idempotency_key=idempotency_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_nextflow_json_analysis_serialize(
        self,
        project_id,
        create_nextflow_json_analysis,
        idempotency_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        # process the header parameters
        if idempotency_key is not None:
            _header_params[&#39;Idempotency-Key&#39;] = idempotency_key
        # process the form parameters
        # process the body parameter
        if create_nextflow_json_analysis is not None:
            _body_params = create_nextflow_json_analysis


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;application/vnd.illumina.v4+json&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/analysis:nextflowJson&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_analyses(
        self,
        project_id: StrictStr,
        reference: Annotated[Optional[StrictStr], Field(description=&#34;The reference to filter on.&#34;)] = None,
        userreference: Annotated[Optional[StrictStr], Field(description=&#34;The user-reference to filter on.&#34;)] = None,
        status: Annotated[Optional[StrictStr], Field(description=&#34;The status to filter on.&#34;)] = None,
        usertag: Annotated[Optional[StrictStr], Field(description=&#34;The user-tags to filter on.&#34;)] = None,
        technicaltag: Annotated[Optional[StrictStr], Field(description=&#34;The technical-tags to filter on.&#34;)] = None,
        referencetag: Annotated[Optional[StrictStr], Field(description=&#34;The reference-data-tags to filter on.&#34;)] = None,
        page_offset: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages&#34;)] = None,
        page_token: Annotated[Optional[StrictStr], Field(description=&#34;[only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.&#34;)] = None,
        page_size: Annotated[Optional[StrictStr], Field(description=&#34;[can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results&#34;)] = None,
        sort: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary &#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisPagedListV3:
        &#34;&#34;&#34;(Deprecated) Retrieve the list of analyses.

        This endpoint only returns V3 items. Use the search endpoint to get V4 items.

        :param project_id: (required)
        :type project_id: str
        :param reference: The reference to filter on.
        :type reference: str
        :param userreference: The user-reference to filter on.
        :type userreference: str
        :param status: The status to filter on.
        :type status: str
        :param usertag: The user-tags to filter on.
        :type usertag: str
        :param technicaltag: The technical-tags to filter on.
        :type technicaltag: str
        :param referencetag: The reference-data-tags to filter on.
        :type referencetag: str
        :param page_offset: [only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
        :type page_offset: str
        :param page_token: [only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
        :type page_token: str
        :param page_size: [can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
        :type page_size: str
        :param sort: [only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501
        warnings.warn(&#34;GET /api/projects/{projectId}/analyses is deprecated.&#34;, DeprecationWarning)

        _param = self._get_analyses_serialize(
            project_id=project_id,
            reference=reference,
            userreference=userreference,
            status=status,
            usertag=usertag,
            technicaltag=technicaltag,
            referencetag=referencetag,
            page_offset=page_offset,
            page_token=page_token,
            page_size=page_size,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisPagedListV3&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_analyses_with_http_info(
        self,
        project_id: StrictStr,
        reference: Annotated[Optional[StrictStr], Field(description=&#34;The reference to filter on.&#34;)] = None,
        userreference: Annotated[Optional[StrictStr], Field(description=&#34;The user-reference to filter on.&#34;)] = None,
        status: Annotated[Optional[StrictStr], Field(description=&#34;The status to filter on.&#34;)] = None,
        usertag: Annotated[Optional[StrictStr], Field(description=&#34;The user-tags to filter on.&#34;)] = None,
        technicaltag: Annotated[Optional[StrictStr], Field(description=&#34;The technical-tags to filter on.&#34;)] = None,
        referencetag: Annotated[Optional[StrictStr], Field(description=&#34;The reference-data-tags to filter on.&#34;)] = None,
        page_offset: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages&#34;)] = None,
        page_token: Annotated[Optional[StrictStr], Field(description=&#34;[only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.&#34;)] = None,
        page_size: Annotated[Optional[StrictStr], Field(description=&#34;[can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results&#34;)] = None,
        sort: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary &#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisPagedListV3]:
        &#34;&#34;&#34;(Deprecated) Retrieve the list of analyses.

        This endpoint only returns V3 items. Use the search endpoint to get V4 items.

        :param project_id: (required)
        :type project_id: str
        :param reference: The reference to filter on.
        :type reference: str
        :param userreference: The user-reference to filter on.
        :type userreference: str
        :param status: The status to filter on.
        :type status: str
        :param usertag: The user-tags to filter on.
        :type usertag: str
        :param technicaltag: The technical-tags to filter on.
        :type technicaltag: str
        :param referencetag: The reference-data-tags to filter on.
        :type referencetag: str
        :param page_offset: [only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
        :type page_offset: str
        :param page_token: [only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
        :type page_token: str
        :param page_size: [can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
        :type page_size: str
        :param sort: [only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501
        warnings.warn(&#34;GET /api/projects/{projectId}/analyses is deprecated.&#34;, DeprecationWarning)

        _param = self._get_analyses_serialize(
            project_id=project_id,
            reference=reference,
            userreference=userreference,
            status=status,
            usertag=usertag,
            technicaltag=technicaltag,
            referencetag=referencetag,
            page_offset=page_offset,
            page_token=page_token,
            page_size=page_size,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisPagedListV3&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_analyses_without_preload_content(
        self,
        project_id: StrictStr,
        reference: Annotated[Optional[StrictStr], Field(description=&#34;The reference to filter on.&#34;)] = None,
        userreference: Annotated[Optional[StrictStr], Field(description=&#34;The user-reference to filter on.&#34;)] = None,
        status: Annotated[Optional[StrictStr], Field(description=&#34;The status to filter on.&#34;)] = None,
        usertag: Annotated[Optional[StrictStr], Field(description=&#34;The user-tags to filter on.&#34;)] = None,
        technicaltag: Annotated[Optional[StrictStr], Field(description=&#34;The technical-tags to filter on.&#34;)] = None,
        referencetag: Annotated[Optional[StrictStr], Field(description=&#34;The reference-data-tags to filter on.&#34;)] = None,
        page_offset: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages&#34;)] = None,
        page_token: Annotated[Optional[StrictStr], Field(description=&#34;[only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.&#34;)] = None,
        page_size: Annotated[Optional[StrictStr], Field(description=&#34;[can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results&#34;)] = None,
        sort: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary &#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;(Deprecated) Retrieve the list of analyses.

        This endpoint only returns V3 items. Use the search endpoint to get V4 items.

        :param project_id: (required)
        :type project_id: str
        :param reference: The reference to filter on.
        :type reference: str
        :param userreference: The user-reference to filter on.
        :type userreference: str
        :param status: The status to filter on.
        :type status: str
        :param usertag: The user-tags to filter on.
        :type usertag: str
        :param technicaltag: The technical-tags to filter on.
        :type technicaltag: str
        :param referencetag: The reference-data-tags to filter on.
        :type referencetag: str
        :param page_offset: [only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
        :type page_offset: str
        :param page_token: [only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
        :type page_token: str
        :param page_size: [can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
        :type page_size: str
        :param sort: [only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501
        warnings.warn(&#34;GET /api/projects/{projectId}/analyses is deprecated.&#34;, DeprecationWarning)

        _param = self._get_analyses_serialize(
            project_id=project_id,
            reference=reference,
            userreference=userreference,
            status=status,
            usertag=usertag,
            technicaltag=technicaltag,
            referencetag=referencetag,
            page_offset=page_offset,
            page_token=page_token,
            page_size=page_size,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisPagedListV3&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_analyses_serialize(
        self,
        project_id,
        reference,
        userreference,
        status,
        usertag,
        technicaltag,
        referencetag,
        page_offset,
        page_token,
        page_size,
        sort,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        if reference is not None:
            
            _query_params.append((&#39;reference&#39;, reference))
            
        if userreference is not None:
            
            _query_params.append((&#39;userreference&#39;, userreference))
            
        if status is not None:
            
            _query_params.append((&#39;status&#39;, status))
            
        if usertag is not None:
            
            _query_params.append((&#39;usertag&#39;, usertag))
            
        if technicaltag is not None:
            
            _query_params.append((&#39;technicaltag&#39;, technicaltag))
            
        if referencetag is not None:
            
            _query_params.append((&#39;referencetag&#39;, referencetag))
            
        if page_offset is not None:
            
            _query_params.append((&#39;pageOffset&#39;, page_offset))
            
        if page_token is not None:
            
            _query_params.append((&#39;pageToken&#39;, page_token))
            
        if page_size is not None:
            
            _query_params.append((&#39;pageSize&#39;, page_size))
            
        if sort is not None:
            
            _query_params.append((&#39;sort&#39;, sort))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_analysis(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisV4:
        &#34;&#34;&#34;Retrieve an analysis.

        # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_analysis_with_http_info(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisV4]:
        &#34;&#34;&#34;Retrieve an analysis.

        # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_analysis_without_preload_content(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve an analysis.

        # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_analysis_serialize(
        self,
        project_id,
        analysis_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if analysis_id is not None:
            _path_params[&#39;analysisId&#39;] = analysis_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses/{analysisId}&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_analysis_configurations(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the configuration for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ExecutionConfigurationList:
        &#34;&#34;&#34;Retrieve the configurations of an analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the configuration for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_configurations_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;ExecutionConfigurationList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_analysis_configurations_with_http_info(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the configuration for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[ExecutionConfigurationList]:
        &#34;&#34;&#34;Retrieve the configurations of an analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the configuration for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_configurations_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;ExecutionConfigurationList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_analysis_configurations_without_preload_content(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the configuration for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve the configurations of an analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the configuration for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_configurations_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;ExecutionConfigurationList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_analysis_configurations_serialize(
        self,
        project_id,
        analysis_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if analysis_id is not None:
            _path_params[&#39;analysisId&#39;] = analysis_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses/{analysisId}/configurations&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_analysis_inputs(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the inputs for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisInputList:
        &#34;&#34;&#34;Retrieve the inputs of an analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the inputs for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_inputs_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisInputList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_analysis_inputs_with_http_info(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the inputs for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisInputList]:
        &#34;&#34;&#34;Retrieve the inputs of an analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the inputs for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_inputs_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisInputList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_analysis_inputs_without_preload_content(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the inputs for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve the inputs of an analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the inputs for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_inputs_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisInputList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_analysis_inputs_serialize(
        self,
        project_id,
        analysis_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if analysis_id is not None:
            _path_params[&#39;analysisId&#39;] = analysis_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses/{analysisId}/inputs&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_analysis_outputs(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the outputs for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisOutputList:
        &#34;&#34;&#34;Retrieve the outputs of an analysis (limited to the first 200.000 files per output folder). When trying to retrieve the listed data with an endpoint such as GET /api/data/{dataUrn}, data which has already been deleted will be skipped.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the outputs for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_outputs_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisOutputList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_analysis_outputs_with_http_info(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the outputs for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisOutputList]:
        &#34;&#34;&#34;Retrieve the outputs of an analysis (limited to the first 200.000 files per output folder). When trying to retrieve the listed data with an endpoint such as GET /api/data/{dataUrn}, data which has already been deleted will be skipped.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the outputs for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_outputs_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisOutputList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_analysis_outputs_without_preload_content(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the outputs for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve the outputs of an analysis (limited to the first 200.000 files per output folder). When trying to retrieve the listed data with an endpoint such as GET /api/data/{dataUrn}, data which has already been deleted will be skipped.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the outputs for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_outputs_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisOutputList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_analysis_outputs_serialize(
        self,
        project_id,
        analysis_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if analysis_id is not None:
            _path_params[&#39;analysisId&#39;] = analysis_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses/{analysisId}/outputs&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_analysis_reports(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the reports for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisReportEntryList:
        &#34;&#34;&#34;Retrieve the report configs and associated reports.

        Retrieves the reports which match the report config defined in a pipeline.

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the reports for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_reports_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisReportEntryList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_analysis_reports_with_http_info(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the reports for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisReportEntryList]:
        &#34;&#34;&#34;Retrieve the report configs and associated reports.

        Retrieves the reports which match the report config defined in a pipeline.

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the reports for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_reports_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisReportEntryList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_analysis_reports_without_preload_content(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the reports for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve the report configs and associated reports.

        Retrieves the reports which match the report config defined in a pipeline.

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the reports for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_reports_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisReportEntryList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_analysis_reports_serialize(
        self,
        project_id,
        analysis_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if analysis_id is not None:
            _path_params[&#39;analysisId&#39;] = analysis_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses/{analysisId}/reports&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_analysis_steps(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the individual steps for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisStepList:
        &#34;&#34;&#34;Retrieve the individual steps of an analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the individual steps for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_steps_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisStepList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_analysis_steps_with_http_info(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the individual steps for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisStepList]:
        &#34;&#34;&#34;Retrieve the individual steps of an analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the individual steps for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_steps_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisStepList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_analysis_steps_without_preload_content(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the individual steps for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve the individual steps of an analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the individual steps for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_steps_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisStepList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_analysis_steps_serialize(
        self,
        project_id,
        analysis_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if analysis_id is not None:
            _path_params[&#39;analysisId&#39;] = analysis_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses/{analysisId}/steps&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_analysis_usage_details(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the usage details for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisUsageDetails:
        &#34;&#34;&#34;Retrieve the analysis usage details.

        The usage details can be retrieved once the analysis has completed with status SUCCEEDED or FAILED. It may take several minutes for the information to become available. A 404 status indicates that the system is busy processing the information.

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the usage details for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_usage_details_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisUsageDetails&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_analysis_usage_details_with_http_info(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the usage details for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisUsageDetails]:
        &#34;&#34;&#34;Retrieve the analysis usage details.

        The usage details can be retrieved once the analysis has completed with status SUCCEEDED or FAILED. It may take several minutes for the information to become available. A 404 status indicates that the system is busy processing the information.

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the usage details for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_usage_details_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisUsageDetails&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_analysis_usage_details_without_preload_content(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the usage details for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve the analysis usage details.

        The usage details can be retrieved once the analysis has completed with status SUCCEEDED or FAILED. It may take several minutes for the information to become available. A 404 status indicates that the system is busy processing the information.

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the usage details for (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_analysis_usage_details_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisUsageDetails&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_analysis_usage_details_serialize(
        self,
        project_id,
        analysis_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if analysis_id is not None:
            _path_params[&#39;analysisId&#39;] = analysis_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses/{analysisId}/usage&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_cwl_input_json(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the CWL analysis for which to retrieve the input json&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; CwlAnalysisInputJson:
        &#34;&#34;&#34;Retrieve the input json of a CWL analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the CWL analysis for which to retrieve the input json (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_cwl_input_json_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;CwlAnalysisInputJson&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_cwl_input_json_with_http_info(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the CWL analysis for which to retrieve the input json&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[CwlAnalysisInputJson]:
        &#34;&#34;&#34;Retrieve the input json of a CWL analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the CWL analysis for which to retrieve the input json (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_cwl_input_json_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;CwlAnalysisInputJson&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_cwl_input_json_without_preload_content(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the CWL analysis for which to retrieve the input json&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve the input json of a CWL analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the CWL analysis for which to retrieve the input json (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_cwl_input_json_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;CwlAnalysisInputJson&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_cwl_input_json_serialize(
        self,
        project_id,
        analysis_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if analysis_id is not None:
            _path_params[&#39;analysisId&#39;] = analysis_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses/{analysisId}/cwl/inputJson&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_cwl_output_json(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the CWL analysis for which to retrieve the output json&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; CwlAnalysisOutputJson:
        &#34;&#34;&#34;Retrieve the output json of a CWL analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the CWL analysis for which to retrieve the output json (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_cwl_output_json_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;CwlAnalysisOutputJson&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_cwl_output_json_with_http_info(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the CWL analysis for which to retrieve the output json&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[CwlAnalysisOutputJson]:
        &#34;&#34;&#34;Retrieve the output json of a CWL analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the CWL analysis for which to retrieve the output json (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_cwl_output_json_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;CwlAnalysisOutputJson&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_cwl_output_json_without_preload_content(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the CWL analysis for which to retrieve the output json&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve the output json of a CWL analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the CWL analysis for which to retrieve the output json (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_cwl_output_json_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;CwlAnalysisOutputJson&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_cwl_output_json_serialize(
        self,
        project_id,
        analysis_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if analysis_id is not None:
            _path_params[&#39;analysisId&#39;] = analysis_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses/{analysisId}/cwl/outputJson&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_project_analysis_input_form_values(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the input form values from&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; InputFormFieldList:
        &#34;&#34;&#34;Retrieve the values from an input form.

        Retrieve the values from an input form of a JSON based pipeline used to start an analysis.

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the input form values from (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_analysis_input_form_values_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;InputFormFieldList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_project_analysis_input_form_values_with_http_info(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the input form values from&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[InputFormFieldList]:
        &#34;&#34;&#34;Retrieve the values from an input form.

        Retrieve the values from an input form of a JSON based pipeline used to start an analysis.

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the input form values from (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_analysis_input_form_values_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;InputFormFieldList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_project_analysis_input_form_values_without_preload_content(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the input form values from&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve the values from an input form.

        Retrieve the values from an input form of a JSON based pipeline used to start an analysis.

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis to retrieve the input form values from (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_analysis_input_form_values_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;InputFormFieldList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_project_analysis_input_form_values_serialize(
        self,
        project_id,
        analysis_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if analysis_id is not None:
            _path_params[&#39;analysisId&#39;] = analysis_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses/{analysisId}/inputFormValues&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_raw_analysis_output(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis for which to retrieve the raw output&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisRawOutput:
        &#34;&#34;&#34;(Deprecated) Retrieve the raw output of an analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis for which to retrieve the raw output (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501
        warnings.warn(&#34;GET /api/projects/{projectId}/analyses/{analysisId}/rawOutput is deprecated.&#34;, DeprecationWarning)

        _param = self._get_raw_analysis_output_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisRawOutput&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_raw_analysis_output_with_http_info(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis for which to retrieve the raw output&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisRawOutput]:
        &#34;&#34;&#34;(Deprecated) Retrieve the raw output of an analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis for which to retrieve the raw output (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501
        warnings.warn(&#34;GET /api/projects/{projectId}/analyses/{analysisId}/rawOutput is deprecated.&#34;, DeprecationWarning)

        _param = self._get_raw_analysis_output_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisRawOutput&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_raw_analysis_output_without_preload_content(
        self,
        project_id: StrictStr,
        analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis for which to retrieve the raw output&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;(Deprecated) Retrieve the raw output of an analysis.


        :param project_id: (required)
        :type project_id: str
        :param analysis_id: The ID of the analysis for which to retrieve the raw output (required)
        :type analysis_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501
        warnings.warn(&#34;GET /api/projects/{projectId}/analyses/{analysisId}/rawOutput is deprecated.&#34;, DeprecationWarning)

        _param = self._get_raw_analysis_output_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisRawOutput&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_raw_analysis_output_serialize(
        self,
        project_id,
        analysis_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if analysis_id is not None:
            _path_params[&#39;analysisId&#39;] = analysis_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses/{analysisId}/rawOutput&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_analyses(
        self,
        project_id: StrictStr,
        page_offset: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages&#34;)] = None,
        page_token: Annotated[Optional[StrictStr], Field(description=&#34;[only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.&#34;)] = None,
        page_size: Annotated[Optional[StrictStr], Field(description=&#34;[can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results&#34;)] = None,
        sort: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary &#34;)] = None,
        analysis_query_parameters: Optional[AnalysisQueryParameters] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisPagedListV4:
        &#34;&#34;&#34;Search analyses.


        :param project_id: (required)
        :type project_id: str
        :param page_offset: [only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
        :type page_offset: str
        :param page_token: [only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
        :type page_token: str
        :param page_size: [can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
        :type page_size: str
        :param sort: [only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
        :type sort: str
        :param analysis_query_parameters:
        :type analysis_query_parameters: AnalysisQueryParameters
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._search_analyses_serialize(
            project_id=project_id,
            page_offset=page_offset,
            page_token=page_token,
            page_size=page_size,
            sort=sort,
            analysis_query_parameters=analysis_query_parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisPagedListV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_analyses_with_http_info(
        self,
        project_id: StrictStr,
        page_offset: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages&#34;)] = None,
        page_token: Annotated[Optional[StrictStr], Field(description=&#34;[only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.&#34;)] = None,
        page_size: Annotated[Optional[StrictStr], Field(description=&#34;[can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results&#34;)] = None,
        sort: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary &#34;)] = None,
        analysis_query_parameters: Optional[AnalysisQueryParameters] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisPagedListV4]:
        &#34;&#34;&#34;Search analyses.


        :param project_id: (required)
        :type project_id: str
        :param page_offset: [only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
        :type page_offset: str
        :param page_token: [only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
        :type page_token: str
        :param page_size: [can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
        :type page_size: str
        :param sort: [only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
        :type sort: str
        :param analysis_query_parameters:
        :type analysis_query_parameters: AnalysisQueryParameters
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._search_analyses_serialize(
            project_id=project_id,
            page_offset=page_offset,
            page_token=page_token,
            page_size=page_size,
            sort=sort,
            analysis_query_parameters=analysis_query_parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisPagedListV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_analyses_without_preload_content(
        self,
        project_id: StrictStr,
        page_offset: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages&#34;)] = None,
        page_token: Annotated[Optional[StrictStr], Field(description=&#34;[only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.&#34;)] = None,
        page_size: Annotated[Optional[StrictStr], Field(description=&#34;[can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results&#34;)] = None,
        sort: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary &#34;)] = None,
        analysis_query_parameters: Optional[AnalysisQueryParameters] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Search analyses.


        :param project_id: (required)
        :type project_id: str
        :param page_offset: [only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
        :type page_offset: str
        :param page_token: [only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
        :type page_token: str
        :param page_size: [can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
        :type page_size: str
        :param sort: [only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
        :type sort: str
        :param analysis_query_parameters:
        :type analysis_query_parameters: AnalysisQueryParameters
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._search_analyses_serialize(
            project_id=project_id,
            page_offset=page_offset,
            page_token=page_token,
            page_size=page_size,
            sort=sort,
            analysis_query_parameters=analysis_query_parameters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisPagedListV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_analyses_serialize(
        self,
        project_id,
        page_offset,
        page_token,
        page_size,
        sort,
        analysis_query_parameters,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        if page_offset is not None:
            
            _query_params.append((&#39;pageOffset&#39;, page_offset))
            
        if page_token is not None:
            
            _query_params.append((&#39;pageToken&#39;, page_token))
            
        if page_size is not None:
            
            _query_params.append((&#39;pageSize&#39;, page_size))
            
        if sort is not None:
            
            _query_params.append((&#39;sort&#39;, sort))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if analysis_query_parameters is not None:
            _body_params = analysis_query_parameters


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;application/vnd.illumina.v3+json&#39;, 
                        &#39;application/json&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/analysis:search&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_analysis(
        self,
        project_id: StrictStr,
        analysis_id: StrictStr,
        analysis_v4: AnalysisV4,
        if_match: Annotated[Optional[StrictStr], Field(description=&#34;Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client&#39;s most recent value of the &#39;ETag&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; AnalysisV4:
        &#34;&#34;&#34;Update an analysis.

        # Attributes which can be updated:    - tags # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: (required)
        :type analysis_id: str
        :param analysis_v4: (required)
        :type analysis_v4: AnalysisV4
        :param if_match: Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client&#39;s most recent value of the &#39;ETag&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
        :type if_match: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_analysis_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            analysis_v4=analysis_v4,
            if_match=if_match,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_analysis_with_http_info(
        self,
        project_id: StrictStr,
        analysis_id: StrictStr,
        analysis_v4: AnalysisV4,
        if_match: Annotated[Optional[StrictStr], Field(description=&#34;Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client&#39;s most recent value of the &#39;ETag&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[AnalysisV4]:
        &#34;&#34;&#34;Update an analysis.

        # Attributes which can be updated:    - tags # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: (required)
        :type analysis_id: str
        :param analysis_v4: (required)
        :type analysis_v4: AnalysisV4
        :param if_match: Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client&#39;s most recent value of the &#39;ETag&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
        :type if_match: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_analysis_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            analysis_v4=analysis_v4,
            if_match=if_match,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_analysis_without_preload_content(
        self,
        project_id: StrictStr,
        analysis_id: StrictStr,
        analysis_v4: AnalysisV4,
        if_match: Annotated[Optional[StrictStr], Field(description=&#34;Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client&#39;s most recent value of the &#39;ETag&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.&#34;)] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Update an analysis.

        # Attributes which can be updated:    - tags # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

        :param project_id: (required)
        :type project_id: str
        :param analysis_id: (required)
        :type analysis_id: str
        :param analysis_v4: (required)
        :type analysis_v4: AnalysisV4
        :param if_match: Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client&#39;s most recent value of the &#39;ETag&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
        :type if_match: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_analysis_serialize(
            project_id=project_id,
            analysis_id=analysis_id,
            analysis_v4=analysis_v4,
            if_match=if_match,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;AnalysisV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_analysis_serialize(
        self,
        project_id,
        analysis_id,
        analysis_v4,
        if_match,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if analysis_id is not None:
            _path_params[&#39;analysisId&#39;] = analysis_id
        # process the query parameters
        # process the header parameters
        if if_match is not None:
            _header_params[&#39;If-Match&#39;] = if_match
        # process the form parameters
        # process the body parameter
        if analysis_v4 is not None:
            _body_params = analysis_v4


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;application/vnd.illumina.v4+json&#39;, 
                        &#39;application/vnd.illumina.v3+json&#39;, 
                        &#39;application/json&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;PUT&#39;,
            resource_path=&#39;/api/projects/{projectId}/analyses/{analysisId}&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )</code></pre>
</details>
<div class="desc"><p>NOTE: This class is auto generated by OpenAPI Generator
Ref: <a href="https://openapi-generator.tech">https://openapi-generator.tech</a></p>
<p>Do not edit the class manually.</p></div>
<h3>Methods</h3>
<dl>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.abort_analysis"><code class="name flex">
<span>def <span class="ident">abort_analysis</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ abort')]) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def abort_analysis(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to abort&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; None:
    &#34;&#34;&#34;Abort an analysis.

    Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to abort (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._abort_analysis_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Abort an analysis.</p>
<p>Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to abort (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.abort_analysis_with_http_info"><code class="name flex">
<span>def <span class="ident">abort_analysis_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ abort')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[NoneType]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def abort_analysis_with_http_info(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to abort&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[None]:
    &#34;&#34;&#34;Abort an analysis.

    Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to abort (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._abort_analysis_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Abort an analysis.</p>
<p>Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to abort (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.abort_analysis_without_preload_content"><code class="name flex">
<span>def <span class="ident">abort_analysis_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ abort')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def abort_analysis_without_preload_content(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to abort&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Abort an analysis.

    Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to abort (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._abort_analysis_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Abort an analysis.</p>
<p>Endpoint for aborting an analysis. The status of the analysis is not updated immediately, only when the abortion of the analysis has actually started.This is a non-RESTful endpoint, as the path of this endpoint is not representing a REST resource.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to abort (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis"><code class="name flex">
<span>def <span class="ident">create_cwl_analysis</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_cwl_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_cwl_analysis.CreateCwlAnalysis" href="../models/create_cwl_analysis.html#libica.openapi.v3.models.create_cwl_analysis.CreateCwlAnalysis">CreateCwlAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.models.analysis_v4.AnalysisV4" href="../models/analysis_v4.html#libica.openapi.v3.models.analysis_v4.AnalysisV4">AnalysisV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_analysis(
    self,
    project_id: StrictStr,
    create_cwl_analysis: Annotated[CreateCwlAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisV4:
    &#34;&#34;&#34;(Deprecated) Create and start an analysis for a CWL pipeline.

    # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

    :param project_id: (required)
    :type project_id: str
    :param create_cwl_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_cwl_analysis: CreateCwlAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501
    warnings.warn(&#34;POST /api/projects/{projectId}/analysis:cwl is deprecated.&#34;, DeprecationWarning)

    _param = self._create_cwl_analysis_serialize(
        project_id=project_id,
        create_cwl_analysis=create_cwl_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>(Deprecated) Create and start an analysis for a CWL pipeline.</p>
<h1 id="changelog-for-this-endpoint-multiple-versions-exist-note-that-the-values-for-request-headers-content-type-and-accept-must-contain-a-matching-version-v3-initial-version-v4-field-type-status-changed-from-enum-to-string-new-statuses-have-been-added-queued-initializing-preparing_inputs-generating_outputs-aborting-field-analysispriority-changed-from-enum-to-string-the-owner-and-tenant-are-now-represented-by-identifier-objects">Changelog For this endpoint multiple versions exist. Note that the values for request headers 'Content-Type' and 'Accept' must contain a matching version.
## [V3]
* Initial version ## [V4]
* Field type 'status' changed from enum to String. New statuses have been added: ['QUEUED', 'INITIALIZING', 'PREPARING_INPUTS', 'GENERATING_OUTPUTS', 'ABORTING'].
* Field analysisPriority changed from enum to String.
* The owner and tenant are now represented by Identifier objects.</h1>
<p>:param project_id: (required)
:type project_id: str
:param create_cwl_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_cwl_analysis: CreateCwlAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_http_info"><code class="name flex">
<span>def <span class="ident">create_cwl_analysis_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_cwl_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_cwl_analysis.CreateCwlAnalysis" href="../models/create_cwl_analysis.html#libica.openapi.v3.models.create_cwl_analysis.CreateCwlAnalysis">CreateCwlAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_analysis_with_http_info(
    self,
    project_id: StrictStr,
    create_cwl_analysis: Annotated[CreateCwlAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisV4]:
    &#34;&#34;&#34;(Deprecated) Create and start an analysis for a CWL pipeline.

    # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

    :param project_id: (required)
    :type project_id: str
    :param create_cwl_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_cwl_analysis: CreateCwlAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501
    warnings.warn(&#34;POST /api/projects/{projectId}/analysis:cwl is deprecated.&#34;, DeprecationWarning)

    _param = self._create_cwl_analysis_serialize(
        project_id=project_id,
        create_cwl_analysis=create_cwl_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>(Deprecated) Create and start an analysis for a CWL pipeline.</p>
<h1 id="changelog-for-this-endpoint-multiple-versions-exist-note-that-the-values-for-request-headers-content-type-and-accept-must-contain-a-matching-version-v3-initial-version-v4-field-type-status-changed-from-enum-to-string-new-statuses-have-been-added-queued-initializing-preparing_inputs-generating_outputs-aborting-field-analysispriority-changed-from-enum-to-string-the-owner-and-tenant-are-now-represented-by-identifier-objects">Changelog For this endpoint multiple versions exist. Note that the values for request headers 'Content-Type' and 'Accept' must contain a matching version.
## [V3]
* Initial version ## [V4]
* Field type 'status' changed from enum to String. New statuses have been added: ['QUEUED', 'INITIALIZING', 'PREPARING_INPUTS', 'GENERATING_OUTPUTS', 'ABORTING'].
* Field analysisPriority changed from enum to String.
* The owner and tenant are now represented by Identifier objects.</h1>
<p>:param project_id: (required)
:type project_id: str
:param create_cwl_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_cwl_analysis: CreateCwlAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_json_input"><code class="name flex">
<span>def <span class="ident">create_cwl_analysis_with_json_input</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_cwl_with_json_input_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_cwl_with_json_input_analysis.CreateCwlWithJsonInputAnalysis" href="../models/create_cwl_with_json_input_analysis.html#libica.openapi.v3.models.create_cwl_with_json_input_analysis.CreateCwlWithJsonInputAnalysis">CreateCwlWithJsonInputAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.models.analysis_v4.AnalysisV4" href="../models/analysis_v4.html#libica.openapi.v3.models.analysis_v4.AnalysisV4">AnalysisV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_analysis_with_json_input(
    self,
    project_id: StrictStr,
    create_cwl_with_json_input_analysis: Annotated[CreateCwlWithJsonInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisV4:
    &#34;&#34;&#34;Create and start an analysis for a CWL pipeline with an input.json.

    This endpoint is intended to be used with an input.json and will bypass the input form. The combination of using this endpoint with an input.json for a json-form based pipeline with sensitive fields defined is not possible.

    :param project_id: (required)
    :type project_id: str
    :param create_cwl_with_json_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_cwl_with_json_input_analysis: CreateCwlWithJsonInputAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_analysis_with_json_input_serialize(
        project_id=project_id,
        create_cwl_with_json_input_analysis=create_cwl_with_json_input_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a CWL pipeline with an input.json.</p>
<p>This endpoint is intended to be used with an input.json and will bypass the input form. The combination of using this endpoint with an input.json for a json-form based pipeline with sensitive fields defined is not possible.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_cwl_with_json_input_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_cwl_with_json_input_analysis: CreateCwlWithJsonInputAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_json_input_with_http_info"><code class="name flex">
<span>def <span class="ident">create_cwl_analysis_with_json_input_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_cwl_with_json_input_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_cwl_with_json_input_analysis.CreateCwlWithJsonInputAnalysis" href="../models/create_cwl_with_json_input_analysis.html#libica.openapi.v3.models.create_cwl_with_json_input_analysis.CreateCwlWithJsonInputAnalysis">CreateCwlWithJsonInputAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_analysis_with_json_input_with_http_info(
    self,
    project_id: StrictStr,
    create_cwl_with_json_input_analysis: Annotated[CreateCwlWithJsonInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisV4]:
    &#34;&#34;&#34;Create and start an analysis for a CWL pipeline with an input.json.

    This endpoint is intended to be used with an input.json and will bypass the input form. The combination of using this endpoint with an input.json for a json-form based pipeline with sensitive fields defined is not possible.

    :param project_id: (required)
    :type project_id: str
    :param create_cwl_with_json_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_cwl_with_json_input_analysis: CreateCwlWithJsonInputAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_analysis_with_json_input_serialize(
        project_id=project_id,
        create_cwl_with_json_input_analysis=create_cwl_with_json_input_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a CWL pipeline with an input.json.</p>
<p>This endpoint is intended to be used with an input.json and will bypass the input form. The combination of using this endpoint with an input.json for a json-form based pipeline with sensitive fields defined is not possible.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_cwl_with_json_input_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_cwl_with_json_input_analysis: CreateCwlWithJsonInputAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_json_input_without_preload_content"><code class="name flex">
<span>def <span class="ident">create_cwl_analysis_with_json_input_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_cwl_with_json_input_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_cwl_with_json_input_analysis.CreateCwlWithJsonInputAnalysis" href="../models/create_cwl_with_json_input_analysis.html#libica.openapi.v3.models.create_cwl_with_json_input_analysis.CreateCwlWithJsonInputAnalysis">CreateCwlWithJsonInputAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_analysis_with_json_input_without_preload_content(
    self,
    project_id: StrictStr,
    create_cwl_with_json_input_analysis: Annotated[CreateCwlWithJsonInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Create and start an analysis for a CWL pipeline with an input.json.

    This endpoint is intended to be used with an input.json and will bypass the input form. The combination of using this endpoint with an input.json for a json-form based pipeline with sensitive fields defined is not possible.

    :param project_id: (required)
    :type project_id: str
    :param create_cwl_with_json_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_cwl_with_json_input_analysis: CreateCwlWithJsonInputAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_analysis_with_json_input_serialize(
        project_id=project_id,
        create_cwl_with_json_input_analysis=create_cwl_with_json_input_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a CWL pipeline with an input.json.</p>
<p>This endpoint is intended to be used with an input.json and will bypass the input form. The combination of using this endpoint with an input.json for a json-form based pipeline with sensitive fields defined is not possible.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_cwl_with_json_input_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_cwl_with_json_input_analysis: CreateCwlWithJsonInputAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_structured_input"><code class="name flex">
<span>def <span class="ident">create_cwl_analysis_with_structured_input</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_cwl_with_structured_input_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_cwl_with_structured_input_analysis.CreateCwlWithStructuredInputAnalysis" href="../models/create_cwl_with_structured_input_analysis.html#libica.openapi.v3.models.create_cwl_with_structured_input_analysis.CreateCwlWithStructuredInputAnalysis">CreateCwlWithStructuredInputAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.models.analysis_v4.AnalysisV4" href="../models/analysis_v4.html#libica.openapi.v3.models.analysis_v4.AnalysisV4">AnalysisV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_analysis_with_structured_input(
    self,
    project_id: StrictStr,
    create_cwl_with_structured_input_analysis: Annotated[CreateCwlWithStructuredInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisV4:
    &#34;&#34;&#34;Create and start an analysis for a CWL pipeline with a structured input.


    :param project_id: (required)
    :type project_id: str
    :param create_cwl_with_structured_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_cwl_with_structured_input_analysis: CreateCwlWithStructuredInputAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_analysis_with_structured_input_serialize(
        project_id=project_id,
        create_cwl_with_structured_input_analysis=create_cwl_with_structured_input_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a CWL pipeline with a structured input.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_cwl_with_structured_input_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_cwl_with_structured_input_analysis: CreateCwlWithStructuredInputAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_structured_input_with_http_info"><code class="name flex">
<span>def <span class="ident">create_cwl_analysis_with_structured_input_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_cwl_with_structured_input_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_cwl_with_structured_input_analysis.CreateCwlWithStructuredInputAnalysis" href="../models/create_cwl_with_structured_input_analysis.html#libica.openapi.v3.models.create_cwl_with_structured_input_analysis.CreateCwlWithStructuredInputAnalysis">CreateCwlWithStructuredInputAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_analysis_with_structured_input_with_http_info(
    self,
    project_id: StrictStr,
    create_cwl_with_structured_input_analysis: Annotated[CreateCwlWithStructuredInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisV4]:
    &#34;&#34;&#34;Create and start an analysis for a CWL pipeline with a structured input.


    :param project_id: (required)
    :type project_id: str
    :param create_cwl_with_structured_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_cwl_with_structured_input_analysis: CreateCwlWithStructuredInputAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_analysis_with_structured_input_serialize(
        project_id=project_id,
        create_cwl_with_structured_input_analysis=create_cwl_with_structured_input_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a CWL pipeline with a structured input.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_cwl_with_structured_input_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_cwl_with_structured_input_analysis: CreateCwlWithStructuredInputAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_structured_input_without_preload_content"><code class="name flex">
<span>def <span class="ident">create_cwl_analysis_with_structured_input_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_cwl_with_structured_input_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_cwl_with_structured_input_analysis.CreateCwlWithStructuredInputAnalysis" href="../models/create_cwl_with_structured_input_analysis.html#libica.openapi.v3.models.create_cwl_with_structured_input_analysis.CreateCwlWithStructuredInputAnalysis">CreateCwlWithStructuredInputAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_analysis_with_structured_input_without_preload_content(
    self,
    project_id: StrictStr,
    create_cwl_with_structured_input_analysis: Annotated[CreateCwlWithStructuredInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Create and start an analysis for a CWL pipeline with a structured input.


    :param project_id: (required)
    :type project_id: str
    :param create_cwl_with_structured_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_cwl_with_structured_input_analysis: CreateCwlWithStructuredInputAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_analysis_with_structured_input_serialize(
        project_id=project_id,
        create_cwl_with_structured_input_analysis=create_cwl_with_structured_input_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a CWL pipeline with a structured input.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_cwl_with_structured_input_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_cwl_with_structured_input_analysis: CreateCwlWithStructuredInputAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_without_preload_content"><code class="name flex">
<span>def <span class="ident">create_cwl_analysis_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_cwl_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_cwl_analysis.CreateCwlAnalysis" href="../models/create_cwl_analysis.html#libica.openapi.v3.models.create_cwl_analysis.CreateCwlAnalysis">CreateCwlAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_analysis_without_preload_content(
    self,
    project_id: StrictStr,
    create_cwl_analysis: Annotated[CreateCwlAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;(Deprecated) Create and start an analysis for a CWL pipeline.

    # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

    :param project_id: (required)
    :type project_id: str
    :param create_cwl_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_cwl_analysis: CreateCwlAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501
    warnings.warn(&#34;POST /api/projects/{projectId}/analysis:cwl is deprecated.&#34;, DeprecationWarning)

    _param = self._create_cwl_analysis_serialize(
        project_id=project_id,
        create_cwl_analysis=create_cwl_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>(Deprecated) Create and start an analysis for a CWL pipeline.</p>
<h1 id="changelog-for-this-endpoint-multiple-versions-exist-note-that-the-values-for-request-headers-content-type-and-accept-must-contain-a-matching-version-v3-initial-version-v4-field-type-status-changed-from-enum-to-string-new-statuses-have-been-added-queued-initializing-preparing_inputs-generating_outputs-aborting-field-analysispriority-changed-from-enum-to-string-the-owner-and-tenant-are-now-represented-by-identifier-objects">Changelog For this endpoint multiple versions exist. Note that the values for request headers 'Content-Type' and 'Accept' must contain a matching version.
## [V3]
* Initial version ## [V4]
* Field type 'status' changed from enum to String. New statuses have been added: ['QUEUED', 'INITIALIZING', 'PREPARING_INPUTS', 'GENERATING_OUTPUTS', 'ABORTING'].
* Field analysisPriority changed from enum to String.
* The owner and tenant are now represented by Identifier objects.</h1>
<p>:param project_id: (required)
:type project_id: str
:param create_cwl_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_cwl_analysis: CreateCwlAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_json_analysis"><code class="name flex">
<span>def <span class="ident">create_cwl_json_analysis</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_cwl_json_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_cwl_json_analysis.CreateCwlJsonAnalysis" href="../models/create_cwl_json_analysis.html#libica.openapi.v3.models.create_cwl_json_analysis.CreateCwlJsonAnalysis">CreateCwlJsonAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.models.analysis_v4.AnalysisV4" href="../models/analysis_v4.html#libica.openapi.v3.models.analysis_v4.AnalysisV4">AnalysisV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_json_analysis(
    self,
    project_id: StrictStr,
    create_cwl_json_analysis: Annotated[CreateCwlJsonAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisV4:
    &#34;&#34;&#34;Create and start an analysis for a JSON based CWL pipeline.


    :param project_id: (required)
    :type project_id: str
    :param create_cwl_json_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_cwl_json_analysis: CreateCwlJsonAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_json_analysis_serialize(
        project_id=project_id,
        create_cwl_json_analysis=create_cwl_json_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a JSON based CWL pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_cwl_json_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_cwl_json_analysis: CreateCwlJsonAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_json_analysis_with_http_info"><code class="name flex">
<span>def <span class="ident">create_cwl_json_analysis_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_cwl_json_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_cwl_json_analysis.CreateCwlJsonAnalysis" href="../models/create_cwl_json_analysis.html#libica.openapi.v3.models.create_cwl_json_analysis.CreateCwlJsonAnalysis">CreateCwlJsonAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_json_analysis_with_http_info(
    self,
    project_id: StrictStr,
    create_cwl_json_analysis: Annotated[CreateCwlJsonAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisV4]:
    &#34;&#34;&#34;Create and start an analysis for a JSON based CWL pipeline.


    :param project_id: (required)
    :type project_id: str
    :param create_cwl_json_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_cwl_json_analysis: CreateCwlJsonAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_json_analysis_serialize(
        project_id=project_id,
        create_cwl_json_analysis=create_cwl_json_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a JSON based CWL pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_cwl_json_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_cwl_json_analysis: CreateCwlJsonAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_json_analysis_without_preload_content"><code class="name flex">
<span>def <span class="ident">create_cwl_json_analysis_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_cwl_json_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_cwl_json_analysis.CreateCwlJsonAnalysis" href="../models/create_cwl_json_analysis.html#libica.openapi.v3.models.create_cwl_json_analysis.CreateCwlJsonAnalysis">CreateCwlJsonAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_json_analysis_without_preload_content(
    self,
    project_id: StrictStr,
    create_cwl_json_analysis: Annotated[CreateCwlJsonAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Create and start an analysis for a JSON based CWL pipeline.


    :param project_id: (required)
    :type project_id: str
    :param create_cwl_json_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_cwl_json_analysis: CreateCwlJsonAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_json_analysis_serialize(
        project_id=project_id,
        create_cwl_json_analysis=create_cwl_json_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a JSON based CWL pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_cwl_json_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_cwl_json_analysis: CreateCwlJsonAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis"><code class="name flex">
<span>def <span class="ident">create_nextflow_analysis</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_nextflow_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_nextflow_analysis.CreateNextflowAnalysis" href="../models/create_nextflow_analysis.html#libica.openapi.v3.models.create_nextflow_analysis.CreateNextflowAnalysis">CreateNextflowAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.models.analysis_v4.AnalysisV4" href="../models/analysis_v4.html#libica.openapi.v3.models.analysis_v4.AnalysisV4">AnalysisV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_analysis(
    self,
    project_id: StrictStr,
    create_nextflow_analysis: Annotated[CreateNextflowAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisV4:
    &#34;&#34;&#34;Create and start an analysis for a Nextflow pipeline.

    # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

    :param project_id: (required)
    :type project_id: str
    :param create_nextflow_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_nextflow_analysis: CreateNextflowAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_analysis_serialize(
        project_id=project_id,
        create_nextflow_analysis=create_nextflow_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a Nextflow pipeline.</p>
<h1 id="changelog-for-this-endpoint-multiple-versions-exist-note-that-the-values-for-request-headers-content-type-and-accept-must-contain-a-matching-version-v3-initial-version-v4-field-type-status-changed-from-enum-to-string-new-statuses-have-been-added-queued-initializing-preparing_inputs-generating_outputs-aborting-field-analysispriority-changed-from-enum-to-string-the-owner-and-tenant-are-now-represented-by-identifier-objects">Changelog For this endpoint multiple versions exist. Note that the values for request headers 'Content-Type' and 'Accept' must contain a matching version.
## [V3]
* Initial version ## [V4]
* Field type 'status' changed from enum to String. New statuses have been added: ['QUEUED', 'INITIALIZING', 'PREPARING_INPUTS', 'GENERATING_OUTPUTS', 'ABORTING'].
* Field analysisPriority changed from enum to String.
* The owner and tenant are now represented by Identifier objects.</h1>
<p>:param project_id: (required)
:type project_id: str
:param create_nextflow_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_nextflow_analysis: CreateNextflowAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_with_custom_input"><code class="name flex">
<span>def <span class="ident">create_nextflow_analysis_with_custom_input</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_nextflow_with_custom_input_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_nextflow_with_custom_input_analysis.CreateNextflowWithCustomInputAnalysis" href="../models/create_nextflow_with_custom_input_analysis.html#libica.openapi.v3.models.create_nextflow_with_custom_input_analysis.CreateNextflowWithCustomInputAnalysis">CreateNextflowWithCustomInputAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.models.analysis_v4.AnalysisV4" href="../models/analysis_v4.html#libica.openapi.v3.models.analysis_v4.AnalysisV4">AnalysisV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_analysis_with_custom_input(
    self,
    project_id: StrictStr,
    create_nextflow_with_custom_input_analysis: Annotated[CreateNextflowWithCustomInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisV4:
    &#34;&#34;&#34;Create and initiate an analysis for a Nextflow pipeline using a custom input, provided in either YAML format or an escaped JSON string.

    This endpoint is intended to be used with a custom input and will bypass the input form. The combination of using this endpoint with a custom input for a json-form based pipeline with sensitive fields defined is not possible.

    :param project_id: (required)
    :type project_id: str
    :param create_nextflow_with_custom_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_nextflow_with_custom_input_analysis: CreateNextflowWithCustomInputAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_analysis_with_custom_input_serialize(
        project_id=project_id,
        create_nextflow_with_custom_input_analysis=create_nextflow_with_custom_input_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Create and initiate an analysis for a Nextflow pipeline using a custom input, provided in either YAML format or an escaped JSON string.</p>
<p>This endpoint is intended to be used with a custom input and will bypass the input form. The combination of using this endpoint with a custom input for a json-form based pipeline with sensitive fields defined is not possible.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_nextflow_with_custom_input_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_nextflow_with_custom_input_analysis: CreateNextflowWithCustomInputAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_with_custom_input_with_http_info"><code class="name flex">
<span>def <span class="ident">create_nextflow_analysis_with_custom_input_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_nextflow_with_custom_input_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_nextflow_with_custom_input_analysis.CreateNextflowWithCustomInputAnalysis" href="../models/create_nextflow_with_custom_input_analysis.html#libica.openapi.v3.models.create_nextflow_with_custom_input_analysis.CreateNextflowWithCustomInputAnalysis">CreateNextflowWithCustomInputAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_analysis_with_custom_input_with_http_info(
    self,
    project_id: StrictStr,
    create_nextflow_with_custom_input_analysis: Annotated[CreateNextflowWithCustomInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisV4]:
    &#34;&#34;&#34;Create and initiate an analysis for a Nextflow pipeline using a custom input, provided in either YAML format or an escaped JSON string.

    This endpoint is intended to be used with a custom input and will bypass the input form. The combination of using this endpoint with a custom input for a json-form based pipeline with sensitive fields defined is not possible.

    :param project_id: (required)
    :type project_id: str
    :param create_nextflow_with_custom_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_nextflow_with_custom_input_analysis: CreateNextflowWithCustomInputAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_analysis_with_custom_input_serialize(
        project_id=project_id,
        create_nextflow_with_custom_input_analysis=create_nextflow_with_custom_input_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Create and initiate an analysis for a Nextflow pipeline using a custom input, provided in either YAML format or an escaped JSON string.</p>
<p>This endpoint is intended to be used with a custom input and will bypass the input form. The combination of using this endpoint with a custom input for a json-form based pipeline with sensitive fields defined is not possible.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_nextflow_with_custom_input_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_nextflow_with_custom_input_analysis: CreateNextflowWithCustomInputAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_with_custom_input_without_preload_content"><code class="name flex">
<span>def <span class="ident">create_nextflow_analysis_with_custom_input_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_nextflow_with_custom_input_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_nextflow_with_custom_input_analysis.CreateNextflowWithCustomInputAnalysis" href="../models/create_nextflow_with_custom_input_analysis.html#libica.openapi.v3.models.create_nextflow_with_custom_input_analysis.CreateNextflowWithCustomInputAnalysis">CreateNextflowWithCustomInputAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_analysis_with_custom_input_without_preload_content(
    self,
    project_id: StrictStr,
    create_nextflow_with_custom_input_analysis: Annotated[CreateNextflowWithCustomInputAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Create and initiate an analysis for a Nextflow pipeline using a custom input, provided in either YAML format or an escaped JSON string.

    This endpoint is intended to be used with a custom input and will bypass the input form. The combination of using this endpoint with a custom input for a json-form based pipeline with sensitive fields defined is not possible.

    :param project_id: (required)
    :type project_id: str
    :param create_nextflow_with_custom_input_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_nextflow_with_custom_input_analysis: CreateNextflowWithCustomInputAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_analysis_with_custom_input_serialize(
        project_id=project_id,
        create_nextflow_with_custom_input_analysis=create_nextflow_with_custom_input_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Create and initiate an analysis for a Nextflow pipeline using a custom input, provided in either YAML format or an escaped JSON string.</p>
<p>This endpoint is intended to be used with a custom input and will bypass the input form. The combination of using this endpoint with a custom input for a json-form based pipeline with sensitive fields defined is not possible.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_nextflow_with_custom_input_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_nextflow_with_custom_input_analysis: CreateNextflowWithCustomInputAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_with_http_info"><code class="name flex">
<span>def <span class="ident">create_nextflow_analysis_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_nextflow_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_nextflow_analysis.CreateNextflowAnalysis" href="../models/create_nextflow_analysis.html#libica.openapi.v3.models.create_nextflow_analysis.CreateNextflowAnalysis">CreateNextflowAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_analysis_with_http_info(
    self,
    project_id: StrictStr,
    create_nextflow_analysis: Annotated[CreateNextflowAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisV4]:
    &#34;&#34;&#34;Create and start an analysis for a Nextflow pipeline.

    # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

    :param project_id: (required)
    :type project_id: str
    :param create_nextflow_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_nextflow_analysis: CreateNextflowAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_analysis_serialize(
        project_id=project_id,
        create_nextflow_analysis=create_nextflow_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a Nextflow pipeline.</p>
<h1 id="changelog-for-this-endpoint-multiple-versions-exist-note-that-the-values-for-request-headers-content-type-and-accept-must-contain-a-matching-version-v3-initial-version-v4-field-type-status-changed-from-enum-to-string-new-statuses-have-been-added-queued-initializing-preparing_inputs-generating_outputs-aborting-field-analysispriority-changed-from-enum-to-string-the-owner-and-tenant-are-now-represented-by-identifier-objects">Changelog For this endpoint multiple versions exist. Note that the values for request headers 'Content-Type' and 'Accept' must contain a matching version.
## [V3]
* Initial version ## [V4]
* Field type 'status' changed from enum to String. New statuses have been added: ['QUEUED', 'INITIALIZING', 'PREPARING_INPUTS', 'GENERATING_OUTPUTS', 'ABORTING'].
* Field analysisPriority changed from enum to String.
* The owner and tenant are now represented by Identifier objects.</h1>
<p>:param project_id: (required)
:type project_id: str
:param create_nextflow_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_nextflow_analysis: CreateNextflowAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_without_preload_content"><code class="name flex">
<span>def <span class="ident">create_nextflow_analysis_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_nextflow_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_nextflow_analysis.CreateNextflowAnalysis" href="../models/create_nextflow_analysis.html#libica.openapi.v3.models.create_nextflow_analysis.CreateNextflowAnalysis">CreateNextflowAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_analysis_without_preload_content(
    self,
    project_id: StrictStr,
    create_nextflow_analysis: Annotated[CreateNextflowAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Create and start an analysis for a Nextflow pipeline.

    # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

    :param project_id: (required)
    :type project_id: str
    :param create_nextflow_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_nextflow_analysis: CreateNextflowAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_analysis_serialize(
        project_id=project_id,
        create_nextflow_analysis=create_nextflow_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a Nextflow pipeline.</p>
<h1 id="changelog-for-this-endpoint-multiple-versions-exist-note-that-the-values-for-request-headers-content-type-and-accept-must-contain-a-matching-version-v3-initial-version-v4-field-type-status-changed-from-enum-to-string-new-statuses-have-been-added-queued-initializing-preparing_inputs-generating_outputs-aborting-field-analysispriority-changed-from-enum-to-string-the-owner-and-tenant-are-now-represented-by-identifier-objects">Changelog For this endpoint multiple versions exist. Note that the values for request headers 'Content-Type' and 'Accept' must contain a matching version.
## [V3]
* Initial version ## [V4]
* Field type 'status' changed from enum to String. New statuses have been added: ['QUEUED', 'INITIALIZING', 'PREPARING_INPUTS', 'GENERATING_OUTPUTS', 'ABORTING'].
* Field analysisPriority changed from enum to String.
* The owner and tenant are now represented by Identifier objects.</h1>
<p>:param project_id: (required)
:type project_id: str
:param create_nextflow_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_nextflow_analysis: CreateNextflowAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_json_analysis"><code class="name flex">
<span>def <span class="ident">create_nextflow_json_analysis</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_nextflow_json_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_nextflow_json_analysis.CreateNextflowJsonAnalysis" href="../models/create_nextflow_json_analysis.html#libica.openapi.v3.models.create_nextflow_json_analysis.CreateNextflowJsonAnalysis">CreateNextflowJsonAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.models.analysis_v4.AnalysisV4" href="../models/analysis_v4.html#libica.openapi.v3.models.analysis_v4.AnalysisV4">AnalysisV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_json_analysis(
    self,
    project_id: StrictStr,
    create_nextflow_json_analysis: Annotated[CreateNextflowJsonAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisV4:
    &#34;&#34;&#34;Create and start an analysis for a JSON based Nextflow pipeline.


    :param project_id: (required)
    :type project_id: str
    :param create_nextflow_json_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_nextflow_json_analysis: CreateNextflowJsonAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_json_analysis_serialize(
        project_id=project_id,
        create_nextflow_json_analysis=create_nextflow_json_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a JSON based Nextflow pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_nextflow_json_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_nextflow_json_analysis: CreateNextflowJsonAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_json_analysis_with_http_info"><code class="name flex">
<span>def <span class="ident">create_nextflow_json_analysis_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_nextflow_json_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_nextflow_json_analysis.CreateNextflowJsonAnalysis" href="../models/create_nextflow_json_analysis.html#libica.openapi.v3.models.create_nextflow_json_analysis.CreateNextflowJsonAnalysis">CreateNextflowJsonAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_json_analysis_with_http_info(
    self,
    project_id: StrictStr,
    create_nextflow_json_analysis: Annotated[CreateNextflowJsonAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisV4]:
    &#34;&#34;&#34;Create and start an analysis for a JSON based Nextflow pipeline.


    :param project_id: (required)
    :type project_id: str
    :param create_nextflow_json_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_nextflow_json_analysis: CreateNextflowJsonAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_json_analysis_serialize(
        project_id=project_id,
        create_nextflow_json_analysis=create_nextflow_json_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a JSON based Nextflow pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_nextflow_json_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_nextflow_json_analysis: CreateNextflowJsonAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_json_analysis_without_preload_content"><code class="name flex">
<span>def <span class="ident">create_nextflow_json_analysis_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>create_nextflow_json_analysis:Â Annotated[<a title="libica.openapi.v3.models.create_nextflow_json_analysis.CreateNextflowJsonAnalysis" href="../models/create_nextflow_json_analysis.html#libica.openapi.v3.models.create_nextflow_json_analysis.CreateNextflowJsonAnalysis">CreateNextflowJsonAnalysis</a>,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ followingÂ optionsÂ canÂ beÂ usedÂ forÂ actionOnExist:<brÂ /><ul><li>OverwriteÂ (default):Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â itÂ isÂ overwritten.</li><li>Rename:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â anÂ incrementalÂ counterÂ isÂ appendedÂ toÂ theÂ fileÂ name.</li><li>Skip:Â IfÂ aÂ fileÂ withÂ thatÂ nameÂ alreadyÂ exists,Â theÂ newÂ fileÂ isÂ notÂ savedÂ andÂ theÂ dataÂ isÂ discarded.</li></ul>')],<br>idempotency_key:Â Annotated[Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[Strict(strict=True),Â MaxLen(max_length=255)])]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="TheÂ Idempotency-KeyÂ headerÂ canÂ beÂ usedÂ toÂ preventÂ duplicateÂ requestsÂ andÂ supportÂ retries.Â ItÂ isÂ implementedÂ accordingÂ toÂ theÂ IETFÂ spec,Â withÂ oneÂ exceptionÂ (seeÂ below).Â TheÂ headerÂ valueÂ isÂ allowedÂ toÂ beÂ maxÂ 255Â charactersÂ long.Â IfÂ theÂ headerÂ isÂ suppliedÂ forÂ aÂ successfulÂ responseÂ (HTTPÂ statusÂ codeÂ <Â 400)Â thenÂ theÂ response
willÂ beÂ savedÂ forÂ 7Â daysÂ forÂ theÂ specificÂ APIÂ endpoint,Â headerÂ valueÂ andÂ userÂ reference.Â WhenÂ theÂ sameÂ userÂ makes
aÂ newÂ requestÂ withinÂ 7Â daysÂ toÂ theÂ sameÂ APIÂ endpointÂ withÂ theÂ sameÂ Idempotency-KeyÂ headerÂ value,Â followingÂ useÂ casesÂ canÂ occur:<brÂ /><ul><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ anÂ answerÂ isÂ storedÂ =>Â theÂ storedÂ responseÂ isÂ returnedÂ withoutÂ executingÂ theÂ requestÂ again.</li><li>theÂ requestÂ bodyÂ isÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ andÂ noÂ answerÂ isÂ storedÂ becauseÂ theÂ previousÂ requestÂ hasÂ notÂ finishedÂ =>Â 409Â errorÂ response,Â whichÂ indicatesÂ thatÂ theÂ originalÂ callÂ isÂ stillÂ inÂ progress.</li><li>theÂ requestÂ bodyÂ isÂ notÂ theÂ sameÂ asÂ theÂ previousÂ requestÂ =>Â 422Â errorÂ response,Â asÂ thisÂ isÂ notÂ allowed.</li></ul>ThisÂ meansÂ thatÂ eachÂ timeÂ whenÂ executingÂ aÂ newÂ APIÂ requestÂ usingÂ theÂ Idempotency-KeyÂ header,Â theÂ requestÂ hasÂ toÂ containÂ aÂ newÂ headerÂ valueÂ thatÂ hasn'tÂ beenÂ usedÂ (successfully)Â inÂ theÂ pastÂ 7Â daysÂ forÂ thatÂ specificÂ APIÂ endpointÂ andÂ byÂ theÂ specificÂ user.Â ForÂ errorÂ responsesÂ (HTTPÂ statusÂ codeÂ >=Â 400)Â weÂ allowÂ clientsÂ toÂ retryÂ theÂ call.Â ThisÂ isÂ whereÂ weÂ don'tÂ followÂ theÂ IETFÂ specification.")]Â =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_json_analysis_without_preload_content(
    self,
    project_id: StrictStr,
    create_nextflow_json_analysis: Annotated[CreateNextflowJsonAnalysis, Field(description=&#34;The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt;&#34;)],
    idempotency_key: Annotated[Optional[Annotated[str, Field(strict=True, max_length=255)]], Field(description=&#34;The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Create and start an analysis for a JSON based Nextflow pipeline.


    :param project_id: (required)
    :type project_id: str
    :param create_nextflow_json_analysis: The following options can be used for actionOnExist:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Overwrite (default): If a file with that name already exists, it is overwritten.&lt;/li&gt;&lt;li&gt;Rename: If a file with that name already exists, an incremental counter is appended to the file name.&lt;/li&gt;&lt;li&gt;Skip: If a file with that name already exists, the new file is not saved and the data is discarded.&lt;/li&gt;&lt;/ul&gt; (required)
    :type create_nextflow_json_analysis: CreateNextflowJsonAnalysis
    :param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response  will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes  a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.&lt;/li&gt;&lt;li&gt;the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.&lt;/li&gt;&lt;li&gt;the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.&lt;/li&gt;&lt;/ul&gt;This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn&#39;t been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don&#39;t follow the IETF specification.
    :type idempotency_key: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_json_analysis_serialize(
        project_id=project_id,
        create_nextflow_json_analysis=create_nextflow_json_analysis,
        idempotency_key=idempotency_key,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Create and start an analysis for a JSON based Nextflow pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param create_nextflow_json_analysis: The following options can be used for actionOnExist:<br /><ul><li>Overwrite (default): If a file with that name already exists, it is overwritten.</li><li>Rename: If a file with that name already exists, an incremental counter is appended to the file name.</li><li>Skip: If a file with that name already exists, the new file is not saved and the data is discarded.</li></ul> (required)
:type create_nextflow_json_analysis: CreateNextflowJsonAnalysis
:param idempotency_key: The Idempotency-Key header can be used to prevent duplicate requests and support retries. It is implemented according to the IETF spec, with one exception (see below). The header value is allowed to be max 255 characters long. If the header is supplied for a successful response (HTTP status code &lt; 400) then the response
will be saved for 7 days for the specific API endpoint, header value and user reference. When the same user makes
a new request within 7 days to the same API endpoint with the same Idempotency-Key header value, following use cases can occur:<br /><ul><li>the request body is the same as the previous request and an answer is stored =&gt; the stored response is returned without executing the request again.</li><li>the request body is the same as the previous request and no answer is stored because the previous request has not finished =&gt; 409 error response, which indicates that the original call is still in progress.</li><li>the request body is not the same as the previous request =&gt; 422 error response, as this is not allowed.</li></ul>This means that each time when executing a new API request using the Idempotency-Key header, the request has to contain a new header value that hasn't been used (successfully) in the past 7 days for that specific API endpoint and by the specific user. For error responses (HTTP status code &gt;= 400) we allow clients to retry the call. This is where we don't follow the IETF specification.
:type idempotency_key: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analyses"><code class="name flex">
<span>def <span class="ident">get_analyses</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>reference:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ referenceÂ toÂ filterÂ on.')]Â =Â None,<br>userreference:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ user-referenceÂ toÂ filterÂ on.')]Â =Â None,<br>status:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ statusÂ toÂ filterÂ on.')]Â =Â None,<br>usertag:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ user-tagsÂ toÂ filterÂ on.')]Â =Â None,<br>technicaltag:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ technical-tagsÂ toÂ filterÂ on.')]Â =Â None,<br>referencetag:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ reference-data-tagsÂ toÂ filterÂ on.')]Â =Â None,<br>page_offset:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ offset-basedÂ paging]<br>TheÂ amountÂ ofÂ rowsÂ toÂ skipÂ inÂ theÂ result.Â IdeallyÂ thisÂ isÂ aÂ multipleÂ ofÂ theÂ sizeÂ parameter.Â Offset-basedÂ paginationÂ hasÂ aÂ resultÂ limitÂ ofÂ 200KÂ rowsÂ andÂ doesÂ notÂ guaranteeÂ uniqueÂ resultsÂ acrossÂ pages')]Â =Â None,<br>page_token:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ cursor-basedÂ paging]<br>TheÂ cursorÂ toÂ getÂ subsequentÂ results.Â TheÂ valueÂ toÂ useÂ isÂ returnedÂ inÂ theÂ resultÂ whenÂ usingÂ cursor-basedÂ pagination.Â Cursor-basedÂ paginationÂ guaranteesÂ completeÂ andÂ uniqueÂ resultsÂ acrossÂ allÂ pages.')]Â =Â None,<br>page_size:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[canÂ beÂ usedÂ withÂ bothÂ offset-Â andÂ cursor-basedÂ paging]<br>TheÂ amountÂ ofÂ rowsÂ toÂ return.Â UseÂ inÂ combinationÂ withÂ theÂ offsetÂ (whenÂ usingÂ offset-basedÂ pagination)Â orÂ cursorÂ (whenÂ usingÂ cursor-basedÂ pagination)Â parameterÂ toÂ getÂ subsequentÂ results')]Â =Â None,<br>sort:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ offset-basedÂ paging]<br>WhichÂ fieldÂ toÂ orderÂ theÂ resultsÂ by.Â TheÂ defaultÂ orderÂ isÂ ascending,Â suffixÂ withÂ \'Â desc\'Â toÂ sortÂ descendingÂ (suffixÂ \'Â asc\'Â alsoÂ worksÂ forÂ ascending).Â MultipleÂ valuesÂ shouldÂ beÂ separatedÂ withÂ commas.Â AnÂ example:Â "?sort=sortAttribute1,Â sortAttribute2Â desc"
TheÂ attributesÂ forÂ whichÂ sortingÂ isÂ supported:Â -Â referenceÂ -Â userReferenceÂ -Â pipelineÂ -Â statusÂ -Â startDateÂ -Â endDateÂ -Â summaryÂ ')]Â =Â None) â€‘>Â <a title="libica.openapi.v3.models.analysis_paged_list_v3.AnalysisPagedListV3" href="../models/analysis_paged_list_v3.html#libica.openapi.v3.models.analysis_paged_list_v3.AnalysisPagedListV3">AnalysisPagedListV3</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analyses(
    self,
    project_id: StrictStr,
    reference: Annotated[Optional[StrictStr], Field(description=&#34;The reference to filter on.&#34;)] = None,
    userreference: Annotated[Optional[StrictStr], Field(description=&#34;The user-reference to filter on.&#34;)] = None,
    status: Annotated[Optional[StrictStr], Field(description=&#34;The status to filter on.&#34;)] = None,
    usertag: Annotated[Optional[StrictStr], Field(description=&#34;The user-tags to filter on.&#34;)] = None,
    technicaltag: Annotated[Optional[StrictStr], Field(description=&#34;The technical-tags to filter on.&#34;)] = None,
    referencetag: Annotated[Optional[StrictStr], Field(description=&#34;The reference-data-tags to filter on.&#34;)] = None,
    page_offset: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages&#34;)] = None,
    page_token: Annotated[Optional[StrictStr], Field(description=&#34;[only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.&#34;)] = None,
    page_size: Annotated[Optional[StrictStr], Field(description=&#34;[can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results&#34;)] = None,
    sort: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary &#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisPagedListV3:
    &#34;&#34;&#34;(Deprecated) Retrieve the list of analyses.

    This endpoint only returns V3 items. Use the search endpoint to get V4 items.

    :param project_id: (required)
    :type project_id: str
    :param reference: The reference to filter on.
    :type reference: str
    :param userreference: The user-reference to filter on.
    :type userreference: str
    :param status: The status to filter on.
    :type status: str
    :param usertag: The user-tags to filter on.
    :type usertag: str
    :param technicaltag: The technical-tags to filter on.
    :type technicaltag: str
    :param referencetag: The reference-data-tags to filter on.
    :type referencetag: str
    :param page_offset: [only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
    :type page_offset: str
    :param page_token: [only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
    :type page_token: str
    :param page_size: [can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
    :type page_size: str
    :param sort: [only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
    :type sort: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501
    warnings.warn(&#34;GET /api/projects/{projectId}/analyses is deprecated.&#34;, DeprecationWarning)

    _param = self._get_analyses_serialize(
        project_id=project_id,
        reference=reference,
        userreference=userreference,
        status=status,
        usertag=usertag,
        technicaltag=technicaltag,
        referencetag=referencetag,
        page_offset=page_offset,
        page_token=page_token,
        page_size=page_size,
        sort=sort,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisPagedListV3&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>(Deprecated) Retrieve the list of analyses.</p>
<p>This endpoint only returns V3 items. Use the search endpoint to get V4 items.</p>
<p>:param project_id: (required)
:type project_id: str
:param reference: The reference to filter on.
:type reference: str
:param userreference: The user-reference to filter on.
:type userreference: str
:param status: The status to filter on.
:type status: str
:param usertag: The user-tags to filter on.
:type usertag: str
:param technicaltag: The technical-tags to filter on.
:type technicaltag: str
:param referencetag: The reference-data-tags to filter on.
:type referencetag: str
:param page_offset: [only use with offset-based paging]<br>The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
:type page_offset: str
:param page_token: [only use with cursor-based paging]<br>The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
:type page_token: str
:param page_size: [can be used with both offset- and cursor-based paging]<br>The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
:type page_size: str
:param sort: [only use with offset-based paging]<br>Which field to order the results by. The default order is ascending, suffix with ' desc' to sort descending (suffix ' asc' also works for ascending). Multiple values should be separated with commas. An example: "?sort=sortAttribute1, sortAttribute2 desc"
The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
:type sort: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analyses_with_http_info"><code class="name flex">
<span>def <span class="ident">get_analyses_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>reference:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ referenceÂ toÂ filterÂ on.')]Â =Â None,<br>userreference:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ user-referenceÂ toÂ filterÂ on.')]Â =Â None,<br>status:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ statusÂ toÂ filterÂ on.')]Â =Â None,<br>usertag:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ user-tagsÂ toÂ filterÂ on.')]Â =Â None,<br>technicaltag:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ technical-tagsÂ toÂ filterÂ on.')]Â =Â None,<br>referencetag:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ reference-data-tagsÂ toÂ filterÂ on.')]Â =Â None,<br>page_offset:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ offset-basedÂ paging]<br>TheÂ amountÂ ofÂ rowsÂ toÂ skipÂ inÂ theÂ result.Â IdeallyÂ thisÂ isÂ aÂ multipleÂ ofÂ theÂ sizeÂ parameter.Â Offset-basedÂ paginationÂ hasÂ aÂ resultÂ limitÂ ofÂ 200KÂ rowsÂ andÂ doesÂ notÂ guaranteeÂ uniqueÂ resultsÂ acrossÂ pages')]Â =Â None,<br>page_token:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ cursor-basedÂ paging]<br>TheÂ cursorÂ toÂ getÂ subsequentÂ results.Â TheÂ valueÂ toÂ useÂ isÂ returnedÂ inÂ theÂ resultÂ whenÂ usingÂ cursor-basedÂ pagination.Â Cursor-basedÂ paginationÂ guaranteesÂ completeÂ andÂ uniqueÂ resultsÂ acrossÂ allÂ pages.')]Â =Â None,<br>page_size:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[canÂ beÂ usedÂ withÂ bothÂ offset-Â andÂ cursor-basedÂ paging]<br>TheÂ amountÂ ofÂ rowsÂ toÂ return.Â UseÂ inÂ combinationÂ withÂ theÂ offsetÂ (whenÂ usingÂ offset-basedÂ pagination)Â orÂ cursorÂ (whenÂ usingÂ cursor-basedÂ pagination)Â parameterÂ toÂ getÂ subsequentÂ results')]Â =Â None,<br>sort:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ offset-basedÂ paging]<br>WhichÂ fieldÂ toÂ orderÂ theÂ resultsÂ by.Â TheÂ defaultÂ orderÂ isÂ ascending,Â suffixÂ withÂ \'Â desc\'Â toÂ sortÂ descendingÂ (suffixÂ \'Â asc\'Â alsoÂ worksÂ forÂ ascending).Â MultipleÂ valuesÂ shouldÂ beÂ separatedÂ withÂ commas.Â AnÂ example:Â "?sort=sortAttribute1,Â sortAttribute2Â desc"
TheÂ attributesÂ forÂ whichÂ sortingÂ isÂ supported:Â -Â referenceÂ -Â userReferenceÂ -Â pipelineÂ -Â statusÂ -Â startDateÂ -Â endDateÂ -Â summaryÂ ')]Â =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisPagedListV3]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analyses_with_http_info(
    self,
    project_id: StrictStr,
    reference: Annotated[Optional[StrictStr], Field(description=&#34;The reference to filter on.&#34;)] = None,
    userreference: Annotated[Optional[StrictStr], Field(description=&#34;The user-reference to filter on.&#34;)] = None,
    status: Annotated[Optional[StrictStr], Field(description=&#34;The status to filter on.&#34;)] = None,
    usertag: Annotated[Optional[StrictStr], Field(description=&#34;The user-tags to filter on.&#34;)] = None,
    technicaltag: Annotated[Optional[StrictStr], Field(description=&#34;The technical-tags to filter on.&#34;)] = None,
    referencetag: Annotated[Optional[StrictStr], Field(description=&#34;The reference-data-tags to filter on.&#34;)] = None,
    page_offset: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages&#34;)] = None,
    page_token: Annotated[Optional[StrictStr], Field(description=&#34;[only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.&#34;)] = None,
    page_size: Annotated[Optional[StrictStr], Field(description=&#34;[can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results&#34;)] = None,
    sort: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary &#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisPagedListV3]:
    &#34;&#34;&#34;(Deprecated) Retrieve the list of analyses.

    This endpoint only returns V3 items. Use the search endpoint to get V4 items.

    :param project_id: (required)
    :type project_id: str
    :param reference: The reference to filter on.
    :type reference: str
    :param userreference: The user-reference to filter on.
    :type userreference: str
    :param status: The status to filter on.
    :type status: str
    :param usertag: The user-tags to filter on.
    :type usertag: str
    :param technicaltag: The technical-tags to filter on.
    :type technicaltag: str
    :param referencetag: The reference-data-tags to filter on.
    :type referencetag: str
    :param page_offset: [only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
    :type page_offset: str
    :param page_token: [only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
    :type page_token: str
    :param page_size: [can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
    :type page_size: str
    :param sort: [only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
    :type sort: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501
    warnings.warn(&#34;GET /api/projects/{projectId}/analyses is deprecated.&#34;, DeprecationWarning)

    _param = self._get_analyses_serialize(
        project_id=project_id,
        reference=reference,
        userreference=userreference,
        status=status,
        usertag=usertag,
        technicaltag=technicaltag,
        referencetag=referencetag,
        page_offset=page_offset,
        page_token=page_token,
        page_size=page_size,
        sort=sort,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisPagedListV3&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>(Deprecated) Retrieve the list of analyses.</p>
<p>This endpoint only returns V3 items. Use the search endpoint to get V4 items.</p>
<p>:param project_id: (required)
:type project_id: str
:param reference: The reference to filter on.
:type reference: str
:param userreference: The user-reference to filter on.
:type userreference: str
:param status: The status to filter on.
:type status: str
:param usertag: The user-tags to filter on.
:type usertag: str
:param technicaltag: The technical-tags to filter on.
:type technicaltag: str
:param referencetag: The reference-data-tags to filter on.
:type referencetag: str
:param page_offset: [only use with offset-based paging]<br>The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
:type page_offset: str
:param page_token: [only use with cursor-based paging]<br>The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
:type page_token: str
:param page_size: [can be used with both offset- and cursor-based paging]<br>The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
:type page_size: str
:param sort: [only use with offset-based paging]<br>Which field to order the results by. The default order is ascending, suffix with ' desc' to sort descending (suffix ' asc' also works for ascending). Multiple values should be separated with commas. An example: "?sort=sortAttribute1, sortAttribute2 desc"
The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
:type sort: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analyses_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_analyses_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>reference:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ referenceÂ toÂ filterÂ on.')]Â =Â None,<br>userreference:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ user-referenceÂ toÂ filterÂ on.')]Â =Â None,<br>status:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ statusÂ toÂ filterÂ on.')]Â =Â None,<br>usertag:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ user-tagsÂ toÂ filterÂ on.')]Â =Â None,<br>technicaltag:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ technical-tagsÂ toÂ filterÂ on.')]Â =Â None,<br>referencetag:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ reference-data-tagsÂ toÂ filterÂ on.')]Â =Â None,<br>page_offset:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ offset-basedÂ paging]<br>TheÂ amountÂ ofÂ rowsÂ toÂ skipÂ inÂ theÂ result.Â IdeallyÂ thisÂ isÂ aÂ multipleÂ ofÂ theÂ sizeÂ parameter.Â Offset-basedÂ paginationÂ hasÂ aÂ resultÂ limitÂ ofÂ 200KÂ rowsÂ andÂ doesÂ notÂ guaranteeÂ uniqueÂ resultsÂ acrossÂ pages')]Â =Â None,<br>page_token:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ cursor-basedÂ paging]<br>TheÂ cursorÂ toÂ getÂ subsequentÂ results.Â TheÂ valueÂ toÂ useÂ isÂ returnedÂ inÂ theÂ resultÂ whenÂ usingÂ cursor-basedÂ pagination.Â Cursor-basedÂ paginationÂ guaranteesÂ completeÂ andÂ uniqueÂ resultsÂ acrossÂ allÂ pages.')]Â =Â None,<br>page_size:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[canÂ beÂ usedÂ withÂ bothÂ offset-Â andÂ cursor-basedÂ paging]<br>TheÂ amountÂ ofÂ rowsÂ toÂ return.Â UseÂ inÂ combinationÂ withÂ theÂ offsetÂ (whenÂ usingÂ offset-basedÂ pagination)Â orÂ cursorÂ (whenÂ usingÂ cursor-basedÂ pagination)Â parameterÂ toÂ getÂ subsequentÂ results')]Â =Â None,<br>sort:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ offset-basedÂ paging]<br>WhichÂ fieldÂ toÂ orderÂ theÂ resultsÂ by.Â TheÂ defaultÂ orderÂ isÂ ascending,Â suffixÂ withÂ \'Â desc\'Â toÂ sortÂ descendingÂ (suffixÂ \'Â asc\'Â alsoÂ worksÂ forÂ ascending).Â MultipleÂ valuesÂ shouldÂ beÂ separatedÂ withÂ commas.Â AnÂ example:Â "?sort=sortAttribute1,Â sortAttribute2Â desc"
TheÂ attributesÂ forÂ whichÂ sortingÂ isÂ supported:Â -Â referenceÂ -Â userReferenceÂ -Â pipelineÂ -Â statusÂ -Â startDateÂ -Â endDateÂ -Â summaryÂ ')]Â =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analyses_without_preload_content(
    self,
    project_id: StrictStr,
    reference: Annotated[Optional[StrictStr], Field(description=&#34;The reference to filter on.&#34;)] = None,
    userreference: Annotated[Optional[StrictStr], Field(description=&#34;The user-reference to filter on.&#34;)] = None,
    status: Annotated[Optional[StrictStr], Field(description=&#34;The status to filter on.&#34;)] = None,
    usertag: Annotated[Optional[StrictStr], Field(description=&#34;The user-tags to filter on.&#34;)] = None,
    technicaltag: Annotated[Optional[StrictStr], Field(description=&#34;The technical-tags to filter on.&#34;)] = None,
    referencetag: Annotated[Optional[StrictStr], Field(description=&#34;The reference-data-tags to filter on.&#34;)] = None,
    page_offset: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages&#34;)] = None,
    page_token: Annotated[Optional[StrictStr], Field(description=&#34;[only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.&#34;)] = None,
    page_size: Annotated[Optional[StrictStr], Field(description=&#34;[can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results&#34;)] = None,
    sort: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary &#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;(Deprecated) Retrieve the list of analyses.

    This endpoint only returns V3 items. Use the search endpoint to get V4 items.

    :param project_id: (required)
    :type project_id: str
    :param reference: The reference to filter on.
    :type reference: str
    :param userreference: The user-reference to filter on.
    :type userreference: str
    :param status: The status to filter on.
    :type status: str
    :param usertag: The user-tags to filter on.
    :type usertag: str
    :param technicaltag: The technical-tags to filter on.
    :type technicaltag: str
    :param referencetag: The reference-data-tags to filter on.
    :type referencetag: str
    :param page_offset: [only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
    :type page_offset: str
    :param page_token: [only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
    :type page_token: str
    :param page_size: [can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
    :type page_size: str
    :param sort: [only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
    :type sort: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501
    warnings.warn(&#34;GET /api/projects/{projectId}/analyses is deprecated.&#34;, DeprecationWarning)

    _param = self._get_analyses_serialize(
        project_id=project_id,
        reference=reference,
        userreference=userreference,
        status=status,
        usertag=usertag,
        technicaltag=technicaltag,
        referencetag=referencetag,
        page_offset=page_offset,
        page_token=page_token,
        page_size=page_size,
        sort=sort,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisPagedListV3&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>(Deprecated) Retrieve the list of analyses.</p>
<p>This endpoint only returns V3 items. Use the search endpoint to get V4 items.</p>
<p>:param project_id: (required)
:type project_id: str
:param reference: The reference to filter on.
:type reference: str
:param userreference: The user-reference to filter on.
:type userreference: str
:param status: The status to filter on.
:type status: str
:param usertag: The user-tags to filter on.
:type usertag: str
:param technicaltag: The technical-tags to filter on.
:type technicaltag: str
:param referencetag: The reference-data-tags to filter on.
:type referencetag: str
:param page_offset: [only use with offset-based paging]<br>The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
:type page_offset: str
:param page_token: [only use with cursor-based paging]<br>The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
:type page_token: str
:param page_size: [can be used with both offset- and cursor-based paging]<br>The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
:type page_size: str
:param sort: [only use with offset-based paging]<br>Which field to order the results by. The default order is ascending, suffix with ' desc' to sort descending (suffix ' asc' also works for ascending). Multiple values should be separated with commas. An example: "?sort=sortAttribute1, sortAttribute2 desc"
The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
:type sort: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis"><code class="name flex">
<span>def <span class="ident">get_analysis</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieve')]) â€‘>Â <a title="libica.openapi.v3.models.analysis_v4.AnalysisV4" href="../models/analysis_v4.html#libica.openapi.v3.models.analysis_v4.AnalysisV4">AnalysisV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisV4:
    &#34;&#34;&#34;Retrieve an analysis.

    # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve an analysis.</p>
<h1 id="changelog-for-this-endpoint-multiple-versions-exist-note-that-the-values-for-request-headers-content-type-and-accept-must-contain-a-matching-version-v3-initial-version-v4-field-type-status-changed-from-enum-to-string-new-statuses-have-been-added-queued-initializing-preparing_inputs-generating_outputs-aborting-field-analysispriority-changed-from-enum-to-string-the-owner-and-tenant-are-now-represented-by-identifier-objects">Changelog For this endpoint multiple versions exist. Note that the values for request headers 'Content-Type' and 'Accept' must contain a matching version.
## [V3]
* Initial version ## [V4]
* Field type 'status' changed from enum to String. New statuses have been added: ['QUEUED', 'INITIALIZING', 'PREPARING_INPUTS', 'GENERATING_OUTPUTS', 'ABORTING'].
* Field analysisPriority changed from enum to String.
* The owner and tenant are now represented by Identifier objects.</h1>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_configurations"><code class="name flex">
<span>def <span class="ident">get_analysis_configurations</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ configurationÂ for')]) â€‘>Â <a title="libica.openapi.v3.models.execution_configuration_list.ExecutionConfigurationList" href="../models/execution_configuration_list.html#libica.openapi.v3.models.execution_configuration_list.ExecutionConfigurationList">ExecutionConfigurationList</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_configurations(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the configuration for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ExecutionConfigurationList:
    &#34;&#34;&#34;Retrieve the configurations of an analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the configuration for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_configurations_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;ExecutionConfigurationList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve the configurations of an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the configuration for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_configurations_with_http_info"><code class="name flex">
<span>def <span class="ident">get_analysis_configurations_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ configurationÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[ExecutionConfigurationList]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_configurations_with_http_info(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the configuration for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[ExecutionConfigurationList]:
    &#34;&#34;&#34;Retrieve the configurations of an analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the configuration for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_configurations_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;ExecutionConfigurationList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve the configurations of an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the configuration for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_configurations_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_analysis_configurations_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ configurationÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_configurations_without_preload_content(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the configuration for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve the configurations of an analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the configuration for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_configurations_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;ExecutionConfigurationList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve the configurations of an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the configuration for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_inputs"><code class="name flex">
<span>def <span class="ident">get_analysis_inputs</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ inputsÂ for')]) â€‘>Â <a title="libica.openapi.v3.models.analysis_input_list.AnalysisInputList" href="../models/analysis_input_list.html#libica.openapi.v3.models.analysis_input_list.AnalysisInputList">AnalysisInputList</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_inputs(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the inputs for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisInputList:
    &#34;&#34;&#34;Retrieve the inputs of an analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the inputs for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_inputs_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisInputList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve the inputs of an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the inputs for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_inputs_with_http_info"><code class="name flex">
<span>def <span class="ident">get_analysis_inputs_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ inputsÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisInputList]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_inputs_with_http_info(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the inputs for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisInputList]:
    &#34;&#34;&#34;Retrieve the inputs of an analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the inputs for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_inputs_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisInputList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve the inputs of an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the inputs for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_inputs_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_analysis_inputs_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ inputsÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_inputs_without_preload_content(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the inputs for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve the inputs of an analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the inputs for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_inputs_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisInputList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve the inputs of an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the inputs for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_outputs"><code class="name flex">
<span>def <span class="ident">get_analysis_outputs</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ outputsÂ for')]) â€‘>Â <a title="libica.openapi.v3.models.analysis_output_list.AnalysisOutputList" href="../models/analysis_output_list.html#libica.openapi.v3.models.analysis_output_list.AnalysisOutputList">AnalysisOutputList</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_outputs(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the outputs for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisOutputList:
    &#34;&#34;&#34;Retrieve the outputs of an analysis (limited to the first 200.000 files per output folder). When trying to retrieve the listed data with an endpoint such as GET /api/data/{dataUrn}, data which has already been deleted will be skipped.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the outputs for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_outputs_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisOutputList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve the outputs of an analysis (limited to the first 200.000 files per output folder). When trying to retrieve the listed data with an endpoint such as GET /api/data/{dataUrn}, data which has already been deleted will be skipped.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the outputs for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_outputs_with_http_info"><code class="name flex">
<span>def <span class="ident">get_analysis_outputs_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ outputsÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisOutputList]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_outputs_with_http_info(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the outputs for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisOutputList]:
    &#34;&#34;&#34;Retrieve the outputs of an analysis (limited to the first 200.000 files per output folder). When trying to retrieve the listed data with an endpoint such as GET /api/data/{dataUrn}, data which has already been deleted will be skipped.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the outputs for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_outputs_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisOutputList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve the outputs of an analysis (limited to the first 200.000 files per output folder). When trying to retrieve the listed data with an endpoint such as GET /api/data/{dataUrn}, data which has already been deleted will be skipped.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the outputs for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_outputs_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_analysis_outputs_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ outputsÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_outputs_without_preload_content(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the outputs for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve the outputs of an analysis (limited to the first 200.000 files per output folder). When trying to retrieve the listed data with an endpoint such as GET /api/data/{dataUrn}, data which has already been deleted will be skipped.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the outputs for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_outputs_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisOutputList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve the outputs of an analysis (limited to the first 200.000 files per output folder). When trying to retrieve the listed data with an endpoint such as GET /api/data/{dataUrn}, data which has already been deleted will be skipped.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the outputs for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_reports"><code class="name flex">
<span>def <span class="ident">get_analysis_reports</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ reportsÂ for')]) â€‘>Â <a title="libica.openapi.v3.models.analysis_report_entry_list.AnalysisReportEntryList" href="../models/analysis_report_entry_list.html#libica.openapi.v3.models.analysis_report_entry_list.AnalysisReportEntryList">AnalysisReportEntryList</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_reports(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the reports for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisReportEntryList:
    &#34;&#34;&#34;Retrieve the report configs and associated reports.

    Retrieves the reports which match the report config defined in a pipeline.

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the reports for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_reports_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisReportEntryList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve the report configs and associated reports.</p>
<p>Retrieves the reports which match the report config defined in a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the reports for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_reports_with_http_info"><code class="name flex">
<span>def <span class="ident">get_analysis_reports_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ reportsÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisReportEntryList]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_reports_with_http_info(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the reports for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisReportEntryList]:
    &#34;&#34;&#34;Retrieve the report configs and associated reports.

    Retrieves the reports which match the report config defined in a pipeline.

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the reports for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_reports_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisReportEntryList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve the report configs and associated reports.</p>
<p>Retrieves the reports which match the report config defined in a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the reports for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_reports_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_analysis_reports_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ reportsÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_reports_without_preload_content(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the reports for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve the report configs and associated reports.

    Retrieves the reports which match the report config defined in a pipeline.

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the reports for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_reports_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisReportEntryList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve the report configs and associated reports.</p>
<p>Retrieves the reports which match the report config defined in a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the reports for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_steps"><code class="name flex">
<span>def <span class="ident">get_analysis_steps</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ individualÂ stepsÂ for')]) â€‘>Â <a title="libica.openapi.v3.models.analysis_step_list.AnalysisStepList" href="../models/analysis_step_list.html#libica.openapi.v3.models.analysis_step_list.AnalysisStepList">AnalysisStepList</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_steps(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the individual steps for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisStepList:
    &#34;&#34;&#34;Retrieve the individual steps of an analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the individual steps for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_steps_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisStepList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve the individual steps of an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the individual steps for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_steps_with_http_info"><code class="name flex">
<span>def <span class="ident">get_analysis_steps_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ individualÂ stepsÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisStepList]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_steps_with_http_info(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the individual steps for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisStepList]:
    &#34;&#34;&#34;Retrieve the individual steps of an analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the individual steps for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_steps_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisStepList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve the individual steps of an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the individual steps for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_steps_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_analysis_steps_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ individualÂ stepsÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_steps_without_preload_content(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the individual steps for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve the individual steps of an analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the individual steps for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_steps_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisStepList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve the individual steps of an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the individual steps for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_usage_details"><code class="name flex">
<span>def <span class="ident">get_analysis_usage_details</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ usageÂ detailsÂ for')]) â€‘>Â <a title="libica.openapi.v3.models.analysis_usage_details.AnalysisUsageDetails" href="../models/analysis_usage_details.html#libica.openapi.v3.models.analysis_usage_details.AnalysisUsageDetails">AnalysisUsageDetails</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_usage_details(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the usage details for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisUsageDetails:
    &#34;&#34;&#34;Retrieve the analysis usage details.

    The usage details can be retrieved once the analysis has completed with status SUCCEEDED or FAILED. It may take several minutes for the information to become available. A 404 status indicates that the system is busy processing the information.

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the usage details for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_usage_details_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisUsageDetails&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve the analysis usage details.</p>
<p>The usage details can be retrieved once the analysis has completed with status SUCCEEDED or FAILED. It may take several minutes for the information to become available. A 404 status indicates that the system is busy processing the information.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the usage details for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_usage_details_with_http_info"><code class="name flex">
<span>def <span class="ident">get_analysis_usage_details_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ usageÂ detailsÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisUsageDetails]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_usage_details_with_http_info(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the usage details for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisUsageDetails]:
    &#34;&#34;&#34;Retrieve the analysis usage details.

    The usage details can be retrieved once the analysis has completed with status SUCCEEDED or FAILED. It may take several minutes for the information to become available. A 404 status indicates that the system is busy processing the information.

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the usage details for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_usage_details_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisUsageDetails&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve the analysis usage details.</p>
<p>The usage details can be retrieved once the analysis has completed with status SUCCEEDED or FAILED. It may take several minutes for the information to become available. A 404 status indicates that the system is busy processing the information.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the usage details for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_usage_details_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_analysis_usage_details_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ usageÂ detailsÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_usage_details_without_preload_content(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the usage details for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve the analysis usage details.

    The usage details can be retrieved once the analysis has completed with status SUCCEEDED or FAILED. It may take several minutes for the information to become available. A 404 status indicates that the system is busy processing the information.

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the usage details for (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_usage_details_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisUsageDetails&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve the analysis usage details.</p>
<p>The usage details can be retrieved once the analysis has completed with status SUCCEEDED or FAILED. It may take several minutes for the information to become available. A 404 status indicates that the system is busy processing the information.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the usage details for (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_with_http_info"><code class="name flex">
<span>def <span class="ident">get_analysis_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieve')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_with_http_info(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisV4]:
    &#34;&#34;&#34;Retrieve an analysis.

    # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve an analysis.</p>
<h1 id="changelog-for-this-endpoint-multiple-versions-exist-note-that-the-values-for-request-headers-content-type-and-accept-must-contain-a-matching-version-v3-initial-version-v4-field-type-status-changed-from-enum-to-string-new-statuses-have-been-added-queued-initializing-preparing_inputs-generating_outputs-aborting-field-analysispriority-changed-from-enum-to-string-the-owner-and-tenant-are-now-represented-by-identifier-objects">Changelog For this endpoint multiple versions exist. Note that the values for request headers 'Content-Type' and 'Accept' must contain a matching version.
## [V3]
* Initial version ## [V4]
* Field type 'status' changed from enum to String. New statuses have been added: ['QUEUED', 'INITIALIZING', 'PREPARING_INPUTS', 'GENERATING_OUTPUTS', 'ABORTING'].
* Field analysisPriority changed from enum to String.
* The owner and tenant are now represented by Identifier objects.</h1>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_analysis_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieve')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_analysis_without_preload_content(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve an analysis.

    # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_analysis_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve an analysis.</p>
<h1 id="changelog-for-this-endpoint-multiple-versions-exist-note-that-the-values-for-request-headers-content-type-and-accept-must-contain-a-matching-version-v3-initial-version-v4-field-type-status-changed-from-enum-to-string-new-statuses-have-been-added-queued-initializing-preparing_inputs-generating_outputs-aborting-field-analysispriority-changed-from-enum-to-string-the-owner-and-tenant-are-now-represented-by-identifier-objects">Changelog For this endpoint multiple versions exist. Note that the values for request headers 'Content-Type' and 'Accept' must contain a matching version.
## [V3]
* Initial version ## [V4]
* Field type 'status' changed from enum to String. New statuses have been added: ['QUEUED', 'INITIALIZING', 'PREPARING_INPUTS', 'GENERATING_OUTPUTS', 'ABORTING'].
* Field analysisPriority changed from enum to String.
* The owner and tenant are now represented by Identifier objects.</h1>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_input_json"><code class="name flex">
<span>def <span class="ident">get_cwl_input_json</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ CWLÂ analysisÂ forÂ whichÂ toÂ retrieveÂ theÂ inputÂ json')]) â€‘>Â <a title="libica.openapi.v3.models.cwl_analysis_input_json.CwlAnalysisInputJson" href="../models/cwl_analysis_input_json.html#libica.openapi.v3.models.cwl_analysis_input_json.CwlAnalysisInputJson">CwlAnalysisInputJson</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_cwl_input_json(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the CWL analysis for which to retrieve the input json&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; CwlAnalysisInputJson:
    &#34;&#34;&#34;Retrieve the input json of a CWL analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the CWL analysis for which to retrieve the input json (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_cwl_input_json_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;CwlAnalysisInputJson&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve the input json of a CWL analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the CWL analysis for which to retrieve the input json (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_input_json_with_http_info"><code class="name flex">
<span>def <span class="ident">get_cwl_input_json_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ CWLÂ analysisÂ forÂ whichÂ toÂ retrieveÂ theÂ inputÂ json')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[CwlAnalysisInputJson]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_cwl_input_json_with_http_info(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the CWL analysis for which to retrieve the input json&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[CwlAnalysisInputJson]:
    &#34;&#34;&#34;Retrieve the input json of a CWL analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the CWL analysis for which to retrieve the input json (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_cwl_input_json_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;CwlAnalysisInputJson&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve the input json of a CWL analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the CWL analysis for which to retrieve the input json (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_input_json_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_cwl_input_json_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ CWLÂ analysisÂ forÂ whichÂ toÂ retrieveÂ theÂ inputÂ json')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_cwl_input_json_without_preload_content(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the CWL analysis for which to retrieve the input json&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve the input json of a CWL analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the CWL analysis for which to retrieve the input json (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_cwl_input_json_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;CwlAnalysisInputJson&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve the input json of a CWL analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the CWL analysis for which to retrieve the input json (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_output_json"><code class="name flex">
<span>def <span class="ident">get_cwl_output_json</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ CWLÂ analysisÂ forÂ whichÂ toÂ retrieveÂ theÂ outputÂ json')]) â€‘>Â <a title="libica.openapi.v3.models.cwl_analysis_output_json.CwlAnalysisOutputJson" href="../models/cwl_analysis_output_json.html#libica.openapi.v3.models.cwl_analysis_output_json.CwlAnalysisOutputJson">CwlAnalysisOutputJson</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_cwl_output_json(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the CWL analysis for which to retrieve the output json&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; CwlAnalysisOutputJson:
    &#34;&#34;&#34;Retrieve the output json of a CWL analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the CWL analysis for which to retrieve the output json (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_cwl_output_json_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;CwlAnalysisOutputJson&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve the output json of a CWL analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the CWL analysis for which to retrieve the output json (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_output_json_with_http_info"><code class="name flex">
<span>def <span class="ident">get_cwl_output_json_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ CWLÂ analysisÂ forÂ whichÂ toÂ retrieveÂ theÂ outputÂ json')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[CwlAnalysisOutputJson]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_cwl_output_json_with_http_info(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the CWL analysis for which to retrieve the output json&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[CwlAnalysisOutputJson]:
    &#34;&#34;&#34;Retrieve the output json of a CWL analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the CWL analysis for which to retrieve the output json (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_cwl_output_json_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;CwlAnalysisOutputJson&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve the output json of a CWL analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the CWL analysis for which to retrieve the output json (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_output_json_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_cwl_output_json_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ CWLÂ analysisÂ forÂ whichÂ toÂ retrieveÂ theÂ outputÂ json')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_cwl_output_json_without_preload_content(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the CWL analysis for which to retrieve the output json&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve the output json of a CWL analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the CWL analysis for which to retrieve the output json (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_cwl_output_json_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;CwlAnalysisOutputJson&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve the output json of a CWL analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the CWL analysis for which to retrieve the output json (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_project_analysis_input_form_values"><code class="name flex">
<span>def <span class="ident">get_project_analysis_input_form_values</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ inputÂ formÂ valuesÂ from')]) â€‘>Â <a title="libica.openapi.v3.models.input_form_field_list.InputFormFieldList" href="../models/input_form_field_list.html#libica.openapi.v3.models.input_form_field_list.InputFormFieldList">InputFormFieldList</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_analysis_input_form_values(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the input form values from&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; InputFormFieldList:
    &#34;&#34;&#34;Retrieve the values from an input form.

    Retrieve the values from an input form of a JSON based pipeline used to start an analysis.

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the input form values from (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_analysis_input_form_values_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;InputFormFieldList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve the values from an input form.</p>
<p>Retrieve the values from an input form of a JSON based pipeline used to start an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the input form values from (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_project_analysis_input_form_values_with_http_info"><code class="name flex">
<span>def <span class="ident">get_project_analysis_input_form_values_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ inputÂ formÂ valuesÂ from')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[InputFormFieldList]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_analysis_input_form_values_with_http_info(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the input form values from&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[InputFormFieldList]:
    &#34;&#34;&#34;Retrieve the values from an input form.

    Retrieve the values from an input form of a JSON based pipeline used to start an analysis.

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the input form values from (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_analysis_input_form_values_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;InputFormFieldList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve the values from an input form.</p>
<p>Retrieve the values from an input form of a JSON based pipeline used to start an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the input form values from (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_project_analysis_input_form_values_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_project_analysis_input_form_values_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ toÂ retrieveÂ theÂ inputÂ formÂ valuesÂ from')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_analysis_input_form_values_without_preload_content(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis to retrieve the input form values from&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve the values from an input form.

    Retrieve the values from an input form of a JSON based pipeline used to start an analysis.

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis to retrieve the input form values from (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_analysis_input_form_values_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;InputFormFieldList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve the values from an input form.</p>
<p>Retrieve the values from an input form of a JSON based pipeline used to start an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis to retrieve the input form values from (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_raw_analysis_output"><code class="name flex">
<span>def <span class="ident">get_raw_analysis_output</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ forÂ whichÂ toÂ retrieveÂ theÂ rawÂ output')]) â€‘>Â <a title="libica.openapi.v3.models.analysis_raw_output.AnalysisRawOutput" href="../models/analysis_raw_output.html#libica.openapi.v3.models.analysis_raw_output.AnalysisRawOutput">AnalysisRawOutput</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_raw_analysis_output(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis for which to retrieve the raw output&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisRawOutput:
    &#34;&#34;&#34;(Deprecated) Retrieve the raw output of an analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis for which to retrieve the raw output (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501
    warnings.warn(&#34;GET /api/projects/{projectId}/analyses/{analysisId}/rawOutput is deprecated.&#34;, DeprecationWarning)

    _param = self._get_raw_analysis_output_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisRawOutput&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>(Deprecated) Retrieve the raw output of an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis for which to retrieve the raw output (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_raw_analysis_output_with_http_info"><code class="name flex">
<span>def <span class="ident">get_raw_analysis_output_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ forÂ whichÂ toÂ retrieveÂ theÂ rawÂ output')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisRawOutput]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_raw_analysis_output_with_http_info(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis for which to retrieve the raw output&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisRawOutput]:
    &#34;&#34;&#34;(Deprecated) Retrieve the raw output of an analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis for which to retrieve the raw output (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501
    warnings.warn(&#34;GET /api/projects/{projectId}/analyses/{analysisId}/rawOutput is deprecated.&#34;, DeprecationWarning)

    _param = self._get_raw_analysis_output_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisRawOutput&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>(Deprecated) Retrieve the raw output of an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis for which to retrieve the raw output (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_raw_analysis_output_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_raw_analysis_output_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ analysisÂ forÂ whichÂ toÂ retrieveÂ theÂ rawÂ output')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_raw_analysis_output_without_preload_content(
    self,
    project_id: StrictStr,
    analysis_id: Annotated[StrictStr, Field(description=&#34;The ID of the analysis for which to retrieve the raw output&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;(Deprecated) Retrieve the raw output of an analysis.


    :param project_id: (required)
    :type project_id: str
    :param analysis_id: The ID of the analysis for which to retrieve the raw output (required)
    :type analysis_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501
    warnings.warn(&#34;GET /api/projects/{projectId}/analyses/{analysisId}/rawOutput is deprecated.&#34;, DeprecationWarning)

    _param = self._get_raw_analysis_output_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisRawOutput&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>(Deprecated) Retrieve the raw output of an analysis.</p>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: The ID of the analysis for which to retrieve the raw output (required)
:type analysis_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.search_analyses"><code class="name flex">
<span>def <span class="ident">search_analyses</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>page_offset:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ offset-basedÂ paging]<br>TheÂ amountÂ ofÂ rowsÂ toÂ skipÂ inÂ theÂ result.Â IdeallyÂ thisÂ isÂ aÂ multipleÂ ofÂ theÂ sizeÂ parameter.Â Offset-basedÂ paginationÂ hasÂ aÂ resultÂ limitÂ ofÂ 200KÂ rowsÂ andÂ doesÂ notÂ guaranteeÂ uniqueÂ resultsÂ acrossÂ pages')]Â =Â None,<br>page_token:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ cursor-basedÂ paging]<br>TheÂ cursorÂ toÂ getÂ subsequentÂ results.Â TheÂ valueÂ toÂ useÂ isÂ returnedÂ inÂ theÂ resultÂ whenÂ usingÂ cursor-basedÂ pagination.Â Cursor-basedÂ paginationÂ guaranteesÂ completeÂ andÂ uniqueÂ resultsÂ acrossÂ allÂ pages.')]Â =Â None,<br>page_size:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[canÂ beÂ usedÂ withÂ bothÂ offset-Â andÂ cursor-basedÂ paging]<br>TheÂ amountÂ ofÂ rowsÂ toÂ return.Â UseÂ inÂ combinationÂ withÂ theÂ offsetÂ (whenÂ usingÂ offset-basedÂ pagination)Â orÂ cursorÂ (whenÂ usingÂ cursor-basedÂ pagination)Â parameterÂ toÂ getÂ subsequentÂ results')]Â =Â None,<br>sort:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ offset-basedÂ paging]<br>WhichÂ fieldÂ toÂ orderÂ theÂ resultsÂ by.Â TheÂ defaultÂ orderÂ isÂ ascending,Â suffixÂ withÂ \'Â desc\'Â toÂ sortÂ descendingÂ (suffixÂ \'Â asc\'Â alsoÂ worksÂ forÂ ascending).Â MultipleÂ valuesÂ shouldÂ beÂ separatedÂ withÂ commas.Â AnÂ example:Â "?sort=sortAttribute1,Â sortAttribute2Â desc"
TheÂ attributesÂ forÂ whichÂ sortingÂ isÂ supported:Â -Â referenceÂ -Â userReferenceÂ -Â pipelineÂ -Â statusÂ -Â startDateÂ -Â endDateÂ -Â summaryÂ ')]Â =Â None,<br>analysis_query_parameters:Â <a title="libica.openapi.v3.models.analysis_query_parameters.AnalysisQueryParameters" href="../models/analysis_query_parameters.html#libica.openapi.v3.models.analysis_query_parameters.AnalysisQueryParameters">AnalysisQueryParameters</a>Â |Â NoneÂ =Â None) â€‘>Â <a title="libica.openapi.v3.models.analysis_paged_list_v4.AnalysisPagedListV4" href="../models/analysis_paged_list_v4.html#libica.openapi.v3.models.analysis_paged_list_v4.AnalysisPagedListV4">AnalysisPagedListV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def search_analyses(
    self,
    project_id: StrictStr,
    page_offset: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages&#34;)] = None,
    page_token: Annotated[Optional[StrictStr], Field(description=&#34;[only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.&#34;)] = None,
    page_size: Annotated[Optional[StrictStr], Field(description=&#34;[can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results&#34;)] = None,
    sort: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary &#34;)] = None,
    analysis_query_parameters: Optional[AnalysisQueryParameters] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisPagedListV4:
    &#34;&#34;&#34;Search analyses.


    :param project_id: (required)
    :type project_id: str
    :param page_offset: [only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
    :type page_offset: str
    :param page_token: [only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
    :type page_token: str
    :param page_size: [can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
    :type page_size: str
    :param sort: [only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
    :type sort: str
    :param analysis_query_parameters:
    :type analysis_query_parameters: AnalysisQueryParameters
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._search_analyses_serialize(
        project_id=project_id,
        page_offset=page_offset,
        page_token=page_token,
        page_size=page_size,
        sort=sort,
        analysis_query_parameters=analysis_query_parameters,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisPagedListV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Search analyses.</p>
<p>:param project_id: (required)
:type project_id: str
:param page_offset: [only use with offset-based paging]<br>The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
:type page_offset: str
:param page_token: [only use with cursor-based paging]<br>The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
:type page_token: str
:param page_size: [can be used with both offset- and cursor-based paging]<br>The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
:type page_size: str
:param sort: [only use with offset-based paging]<br>Which field to order the results by. The default order is ascending, suffix with ' desc' to sort descending (suffix ' asc' also works for ascending). Multiple values should be separated with commas. An example: "?sort=sortAttribute1, sortAttribute2 desc"
The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
:type sort: str
:param analysis_query_parameters:
:type analysis_query_parameters: AnalysisQueryParameters
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.search_analyses_with_http_info"><code class="name flex">
<span>def <span class="ident">search_analyses_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>page_offset:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ offset-basedÂ paging]<br>TheÂ amountÂ ofÂ rowsÂ toÂ skipÂ inÂ theÂ result.Â IdeallyÂ thisÂ isÂ aÂ multipleÂ ofÂ theÂ sizeÂ parameter.Â Offset-basedÂ paginationÂ hasÂ aÂ resultÂ limitÂ ofÂ 200KÂ rowsÂ andÂ doesÂ notÂ guaranteeÂ uniqueÂ resultsÂ acrossÂ pages')]Â =Â None,<br>page_token:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ cursor-basedÂ paging]<br>TheÂ cursorÂ toÂ getÂ subsequentÂ results.Â TheÂ valueÂ toÂ useÂ isÂ returnedÂ inÂ theÂ resultÂ whenÂ usingÂ cursor-basedÂ pagination.Â Cursor-basedÂ paginationÂ guaranteesÂ completeÂ andÂ uniqueÂ resultsÂ acrossÂ allÂ pages.')]Â =Â None,<br>page_size:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[canÂ beÂ usedÂ withÂ bothÂ offset-Â andÂ cursor-basedÂ paging]<br>TheÂ amountÂ ofÂ rowsÂ toÂ return.Â UseÂ inÂ combinationÂ withÂ theÂ offsetÂ (whenÂ usingÂ offset-basedÂ pagination)Â orÂ cursorÂ (whenÂ usingÂ cursor-basedÂ pagination)Â parameterÂ toÂ getÂ subsequentÂ results')]Â =Â None,<br>sort:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ offset-basedÂ paging]<br>WhichÂ fieldÂ toÂ orderÂ theÂ resultsÂ by.Â TheÂ defaultÂ orderÂ isÂ ascending,Â suffixÂ withÂ \'Â desc\'Â toÂ sortÂ descendingÂ (suffixÂ \'Â asc\'Â alsoÂ worksÂ forÂ ascending).Â MultipleÂ valuesÂ shouldÂ beÂ separatedÂ withÂ commas.Â AnÂ example:Â "?sort=sortAttribute1,Â sortAttribute2Â desc"
TheÂ attributesÂ forÂ whichÂ sortingÂ isÂ supported:Â -Â referenceÂ -Â userReferenceÂ -Â pipelineÂ -Â statusÂ -Â startDateÂ -Â endDateÂ -Â summaryÂ ')]Â =Â None,<br>analysis_query_parameters:Â <a title="libica.openapi.v3.models.analysis_query_parameters.AnalysisQueryParameters" href="../models/analysis_query_parameters.html#libica.openapi.v3.models.analysis_query_parameters.AnalysisQueryParameters">AnalysisQueryParameters</a>Â |Â NoneÂ =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisPagedListV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def search_analyses_with_http_info(
    self,
    project_id: StrictStr,
    page_offset: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages&#34;)] = None,
    page_token: Annotated[Optional[StrictStr], Field(description=&#34;[only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.&#34;)] = None,
    page_size: Annotated[Optional[StrictStr], Field(description=&#34;[can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results&#34;)] = None,
    sort: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary &#34;)] = None,
    analysis_query_parameters: Optional[AnalysisQueryParameters] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisPagedListV4]:
    &#34;&#34;&#34;Search analyses.


    :param project_id: (required)
    :type project_id: str
    :param page_offset: [only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
    :type page_offset: str
    :param page_token: [only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
    :type page_token: str
    :param page_size: [can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
    :type page_size: str
    :param sort: [only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
    :type sort: str
    :param analysis_query_parameters:
    :type analysis_query_parameters: AnalysisQueryParameters
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._search_analyses_serialize(
        project_id=project_id,
        page_offset=page_offset,
        page_token=page_token,
        page_size=page_size,
        sort=sort,
        analysis_query_parameters=analysis_query_parameters,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisPagedListV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Search analyses.</p>
<p>:param project_id: (required)
:type project_id: str
:param page_offset: [only use with offset-based paging]<br>The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
:type page_offset: str
:param page_token: [only use with cursor-based paging]<br>The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
:type page_token: str
:param page_size: [can be used with both offset- and cursor-based paging]<br>The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
:type page_size: str
:param sort: [only use with offset-based paging]<br>Which field to order the results by. The default order is ascending, suffix with ' desc' to sort descending (suffix ' asc' also works for ascending). Multiple values should be separated with commas. An example: "?sort=sortAttribute1, sortAttribute2 desc"
The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
:type sort: str
:param analysis_query_parameters:
:type analysis_query_parameters: AnalysisQueryParameters
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.search_analyses_without_preload_content"><code class="name flex">
<span>def <span class="ident">search_analyses_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>page_offset:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ offset-basedÂ paging]<br>TheÂ amountÂ ofÂ rowsÂ toÂ skipÂ inÂ theÂ result.Â IdeallyÂ thisÂ isÂ aÂ multipleÂ ofÂ theÂ sizeÂ parameter.Â Offset-basedÂ paginationÂ hasÂ aÂ resultÂ limitÂ ofÂ 200KÂ rowsÂ andÂ doesÂ notÂ guaranteeÂ uniqueÂ resultsÂ acrossÂ pages')]Â =Â None,<br>page_token:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ cursor-basedÂ paging]<br>TheÂ cursorÂ toÂ getÂ subsequentÂ results.Â TheÂ valueÂ toÂ useÂ isÂ returnedÂ inÂ theÂ resultÂ whenÂ usingÂ cursor-basedÂ pagination.Â Cursor-basedÂ paginationÂ guaranteesÂ completeÂ andÂ uniqueÂ resultsÂ acrossÂ allÂ pages.')]Â =Â None,<br>page_size:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[canÂ beÂ usedÂ withÂ bothÂ offset-Â andÂ cursor-basedÂ paging]<br>TheÂ amountÂ ofÂ rowsÂ toÂ return.Â UseÂ inÂ combinationÂ withÂ theÂ offsetÂ (whenÂ usingÂ offset-basedÂ pagination)Â orÂ cursorÂ (whenÂ usingÂ cursor-basedÂ pagination)Â parameterÂ toÂ getÂ subsequentÂ results')]Â =Â None,<br>sort:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='[onlyÂ useÂ withÂ offset-basedÂ paging]<br>WhichÂ fieldÂ toÂ orderÂ theÂ resultsÂ by.Â TheÂ defaultÂ orderÂ isÂ ascending,Â suffixÂ withÂ \'Â desc\'Â toÂ sortÂ descendingÂ (suffixÂ \'Â asc\'Â alsoÂ worksÂ forÂ ascending).Â MultipleÂ valuesÂ shouldÂ beÂ separatedÂ withÂ commas.Â AnÂ example:Â "?sort=sortAttribute1,Â sortAttribute2Â desc"
TheÂ attributesÂ forÂ whichÂ sortingÂ isÂ supported:Â -Â referenceÂ -Â userReferenceÂ -Â pipelineÂ -Â statusÂ -Â startDateÂ -Â endDateÂ -Â summaryÂ ')]Â =Â None,<br>analysis_query_parameters:Â <a title="libica.openapi.v3.models.analysis_query_parameters.AnalysisQueryParameters" href="../models/analysis_query_parameters.html#libica.openapi.v3.models.analysis_query_parameters.AnalysisQueryParameters">AnalysisQueryParameters</a>Â |Â NoneÂ =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def search_analyses_without_preload_content(
    self,
    project_id: StrictStr,
    page_offset: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages&#34;)] = None,
    page_token: Annotated[Optional[StrictStr], Field(description=&#34;[only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.&#34;)] = None,
    page_size: Annotated[Optional[StrictStr], Field(description=&#34;[can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results&#34;)] = None,
    sort: Annotated[Optional[StrictStr], Field(description=&#34;[only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary &#34;)] = None,
    analysis_query_parameters: Optional[AnalysisQueryParameters] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Search analyses.


    :param project_id: (required)
    :type project_id: str
    :param page_offset: [only use with offset-based paging]&lt;br&gt;The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
    :type page_offset: str
    :param page_token: [only use with cursor-based paging]&lt;br&gt;The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
    :type page_token: str
    :param page_size: [can be used with both offset- and cursor-based paging]&lt;br&gt;The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
    :type page_size: str
    :param sort: [only use with offset-based paging]&lt;br&gt;Which field to order the results by. The default order is ascending, suffix with &#39; desc&#39; to sort descending (suffix &#39; asc&#39; also works for ascending). Multiple values should be separated with commas. An example: \&#34;?sort=sortAttribute1, sortAttribute2 desc\&#34;  The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary 
    :type sort: str
    :param analysis_query_parameters:
    :type analysis_query_parameters: AnalysisQueryParameters
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._search_analyses_serialize(
        project_id=project_id,
        page_offset=page_offset,
        page_token=page_token,
        page_size=page_size,
        sort=sort,
        analysis_query_parameters=analysis_query_parameters,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisPagedListV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Search analyses.</p>
<p>:param project_id: (required)
:type project_id: str
:param page_offset: [only use with offset-based paging]<br>The amount of rows to skip in the result. Ideally this is a multiple of the size parameter. Offset-based pagination has a result limit of 200K rows and does not guarantee unique results across pages
:type page_offset: str
:param page_token: [only use with cursor-based paging]<br>The cursor to get subsequent results. The value to use is returned in the result when using cursor-based pagination. Cursor-based pagination guarantees complete and unique results across all pages.
:type page_token: str
:param page_size: [can be used with both offset- and cursor-based paging]<br>The amount of rows to return. Use in combination with the offset (when using offset-based pagination) or cursor (when using cursor-based pagination) parameter to get subsequent results
:type page_size: str
:param sort: [only use with offset-based paging]<br>Which field to order the results by. The default order is ascending, suffix with ' desc' to sort descending (suffix ' asc' also works for ascending). Multiple values should be separated with commas. An example: "?sort=sortAttribute1, sortAttribute2 desc"
The attributes for which sorting is supported: - reference - userReference - pipeline - status - startDate - endDate - summary
:type sort: str
:param analysis_query_parameters:
:type analysis_query_parameters: AnalysisQueryParameters
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.update_analysis"><code class="name flex">
<span>def <span class="ident">update_analysis</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_v4:Â <a title="libica.openapi.v3.models.analysis_v4.AnalysisV4" href="../models/analysis_v4.html#libica.openapi.v3.models.analysis_v4.AnalysisV4">AnalysisV4</a>,<br>if_match:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="OptionalÂ headerÂ parameterÂ toÂ enableÂ conflictÂ exposure.Â IfÂ theÂ clientÂ providesÂ thisÂ header,Â thenÂ itÂ mustÂ containsÂ theÂ client'sÂ mostÂ recentÂ valueÂ ofÂ theÂ 'ETag'Â responseÂ header,Â andÂ theÂ serverÂ willÂ respondÂ withÂ aÂ 409Â codeÂ ifÂ itÂ detectsÂ aÂ conflict.Â IfÂ theÂ clientÂ doesÂ notÂ provideÂ thisÂ header,Â thenÂ theÂ serverÂ willÂ notÂ doÂ aÂ conflictÂ check,Â whichÂ meansÂ thatÂ asÂ aÂ clientÂ youÂ canÂ overrideÂ theÂ resourceÂ evenÂ whenÂ theÂ serverÂ hasÂ aÂ moreÂ recentÂ version.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.models.analysis_v4.AnalysisV4" href="../models/analysis_v4.html#libica.openapi.v3.models.analysis_v4.AnalysisV4">AnalysisV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_analysis(
    self,
    project_id: StrictStr,
    analysis_id: StrictStr,
    analysis_v4: AnalysisV4,
    if_match: Annotated[Optional[StrictStr], Field(description=&#34;Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client&#39;s most recent value of the &#39;ETag&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; AnalysisV4:
    &#34;&#34;&#34;Update an analysis.

    # Attributes which can be updated:    - tags # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: (required)
    :type analysis_id: str
    :param analysis_v4: (required)
    :type analysis_v4: AnalysisV4
    :param if_match: Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client&#39;s most recent value of the &#39;ETag&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
    :type if_match: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_analysis_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        analysis_v4=analysis_v4,
        if_match=if_match,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Update an analysis.</p>
<h1 id="attributes-which-can-be-updated-tags-changelog-for-this-endpoint-multiple-versions-exist-note-that-the-values-for-request-headers-content-type-and-accept-must-contain-a-matching-version-v3-initial-version-v4-field-type-status-changed-from-enum-to-string-new-statuses-have-been-added-queued-initializing-preparing_inputs-generating_outputs-aborting-field-analysispriority-changed-from-enum-to-string-the-owner-and-tenant-are-now-represented-by-identifier-objects">Attributes which can be updated:
- tags # Changelog For this endpoint multiple versions exist. Note that the values for request headers 'Content-Type' and 'Accept' must contain a matching version.
## [V3]
* Initial version ## [V4]
* Field type 'status' changed from enum to String. New statuses have been added: ['QUEUED', 'INITIALIZING', 'PREPARING_INPUTS', 'GENERATING_OUTPUTS', 'ABORTING'].
* Field analysisPriority changed from enum to String.
* The owner and tenant are now represented by Identifier objects.</h1>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: (required)
:type analysis_id: str
:param analysis_v4: (required)
:type analysis_v4: AnalysisV4
:param if_match: Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client's most recent value of the 'ETag' response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
:type if_match: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.update_analysis_with_http_info"><code class="name flex">
<span>def <span class="ident">update_analysis_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_v4:Â <a title="libica.openapi.v3.models.analysis_v4.AnalysisV4" href="../models/analysis_v4.html#libica.openapi.v3.models.analysis_v4.AnalysisV4">AnalysisV4</a>,<br>if_match:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="OptionalÂ headerÂ parameterÂ toÂ enableÂ conflictÂ exposure.Â IfÂ theÂ clientÂ providesÂ thisÂ header,Â thenÂ itÂ mustÂ containsÂ theÂ client'sÂ mostÂ recentÂ valueÂ ofÂ theÂ 'ETag'Â responseÂ header,Â andÂ theÂ serverÂ willÂ respondÂ withÂ aÂ 409Â codeÂ ifÂ itÂ detectsÂ aÂ conflict.Â IfÂ theÂ clientÂ doesÂ notÂ provideÂ thisÂ header,Â thenÂ theÂ serverÂ willÂ notÂ doÂ aÂ conflictÂ check,Â whichÂ meansÂ thatÂ asÂ aÂ clientÂ youÂ canÂ overrideÂ theÂ resourceÂ evenÂ whenÂ theÂ serverÂ hasÂ aÂ moreÂ recentÂ version.")]Â =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[AnalysisV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_analysis_with_http_info(
    self,
    project_id: StrictStr,
    analysis_id: StrictStr,
    analysis_v4: AnalysisV4,
    if_match: Annotated[Optional[StrictStr], Field(description=&#34;Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client&#39;s most recent value of the &#39;ETag&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[AnalysisV4]:
    &#34;&#34;&#34;Update an analysis.

    # Attributes which can be updated:    - tags # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: (required)
    :type analysis_id: str
    :param analysis_v4: (required)
    :type analysis_v4: AnalysisV4
    :param if_match: Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client&#39;s most recent value of the &#39;ETag&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
    :type if_match: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_analysis_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        analysis_v4=analysis_v4,
        if_match=if_match,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Update an analysis.</p>
<h1 id="attributes-which-can-be-updated-tags-changelog-for-this-endpoint-multiple-versions-exist-note-that-the-values-for-request-headers-content-type-and-accept-must-contain-a-matching-version-v3-initial-version-v4-field-type-status-changed-from-enum-to-string-new-statuses-have-been-added-queued-initializing-preparing_inputs-generating_outputs-aborting-field-analysispriority-changed-from-enum-to-string-the-owner-and-tenant-are-now-represented-by-identifier-objects">Attributes which can be updated:
- tags # Changelog For this endpoint multiple versions exist. Note that the values for request headers 'Content-Type' and 'Accept' must contain a matching version.
## [V3]
* Initial version ## [V4]
* Field type 'status' changed from enum to String. New statuses have been added: ['QUEUED', 'INITIALIZING', 'PREPARING_INPUTS', 'GENERATING_OUTPUTS', 'ABORTING'].
* Field analysisPriority changed from enum to String.
* The owner and tenant are now represented by Identifier objects.</h1>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: (required)
:type analysis_id: str
:param analysis_v4: (required)
:type analysis_v4: AnalysisV4
:param if_match: Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client's most recent value of the 'ETag' response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
:type if_match: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.update_analysis_without_preload_content"><code class="name flex">
<span>def <span class="ident">update_analysis_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_id:Â Annotated[str,Â Strict(strict=True)],<br>analysis_v4:Â <a title="libica.openapi.v3.models.analysis_v4.AnalysisV4" href="../models/analysis_v4.html#libica.openapi.v3.models.analysis_v4.AnalysisV4">AnalysisV4</a>,<br>if_match:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description="OptionalÂ headerÂ parameterÂ toÂ enableÂ conflictÂ exposure.Â IfÂ theÂ clientÂ providesÂ thisÂ header,Â thenÂ itÂ mustÂ containsÂ theÂ client'sÂ mostÂ recentÂ valueÂ ofÂ theÂ 'ETag'Â responseÂ header,Â andÂ theÂ serverÂ willÂ respondÂ withÂ aÂ 409Â codeÂ ifÂ itÂ detectsÂ aÂ conflict.Â IfÂ theÂ clientÂ doesÂ notÂ provideÂ thisÂ header,Â thenÂ theÂ serverÂ willÂ notÂ doÂ aÂ conflictÂ check,Â whichÂ meansÂ thatÂ asÂ aÂ clientÂ youÂ canÂ overrideÂ theÂ resourceÂ evenÂ whenÂ theÂ serverÂ hasÂ aÂ moreÂ recentÂ version.")]Â =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_analysis_without_preload_content(
    self,
    project_id: StrictStr,
    analysis_id: StrictStr,
    analysis_v4: AnalysisV4,
    if_match: Annotated[Optional[StrictStr], Field(description=&#34;Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client&#39;s most recent value of the &#39;ETag&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.&#34;)] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Update an analysis.

    # Attributes which can be updated:    - tags # Changelog For this endpoint multiple versions exist. Note that the values for request headers &#39;Content-Type&#39; and &#39;Accept&#39; must contain a matching version.  ## [V3]  * Initial version ## [V4]  * Field type &#39;status&#39; changed from enum to String. New statuses have been added: [&#39;QUEUED&#39;, &#39;INITIALIZING&#39;, &#39;PREPARING_INPUTS&#39;, &#39;GENERATING_OUTPUTS&#39;, &#39;ABORTING&#39;].  * Field analysisPriority changed from enum to String.  * The owner and tenant are now represented by Identifier objects. 

    :param project_id: (required)
    :type project_id: str
    :param analysis_id: (required)
    :type analysis_id: str
    :param analysis_v4: (required)
    :type analysis_v4: AnalysisV4
    :param if_match: Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client&#39;s most recent value of the &#39;ETag&#39; response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
    :type if_match: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_analysis_serialize(
        project_id=project_id,
        analysis_id=analysis_id,
        analysis_v4=analysis_v4,
        if_match=if_match,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;AnalysisV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Update an analysis.</p>
<h1 id="attributes-which-can-be-updated-tags-changelog-for-this-endpoint-multiple-versions-exist-note-that-the-values-for-request-headers-content-type-and-accept-must-contain-a-matching-version-v3-initial-version-v4-field-type-status-changed-from-enum-to-string-new-statuses-have-been-added-queued-initializing-preparing_inputs-generating_outputs-aborting-field-analysispriority-changed-from-enum-to-string-the-owner-and-tenant-are-now-represented-by-identifier-objects">Attributes which can be updated:
- tags # Changelog For this endpoint multiple versions exist. Note that the values for request headers 'Content-Type' and 'Accept' must contain a matching version.
## [V3]
* Initial version ## [V4]
* Field type 'status' changed from enum to String. New statuses have been added: ['QUEUED', 'INITIALIZING', 'PREPARING_INPUTS', 'GENERATING_OUTPUTS', 'ABORTING'].
* Field analysisPriority changed from enum to String.
* The owner and tenant are now represented by Identifier objects.</h1>
<p>:param project_id: (required)
:type project_id: str
:param analysis_id: (required)
:type analysis_id: str
:param analysis_v4: (required)
:type analysis_v4: AnalysisV4
:param if_match: Optional header parameter to enable conflict exposure. If the client provides this header, then it must contains the client's most recent value of the 'ETag' response header, and the server will respond with a 409 code if it detects a conflict. If the client does not provide this header, then the server will not do a conflict check, which means that as a client you can override the resource even when the server has a more recent version.
:type if_match: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="libica.openapi.v3.api" href="index.html">libica.openapi.v3.api</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi">ProjectAnalysisApi</a></code></h4>
<ul class="">
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.abort_analysis" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.abort_analysis">abort_analysis</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.abort_analysis_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.abort_analysis_with_http_info">abort_analysis_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.abort_analysis_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.abort_analysis_without_preload_content">abort_analysis_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis">create_cwl_analysis</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_http_info">create_cwl_analysis_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_json_input" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_json_input">create_cwl_analysis_with_json_input</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_json_input_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_json_input_with_http_info">create_cwl_analysis_with_json_input_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_json_input_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_json_input_without_preload_content">create_cwl_analysis_with_json_input_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_structured_input" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_structured_input">create_cwl_analysis_with_structured_input</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_structured_input_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_structured_input_with_http_info">create_cwl_analysis_with_structured_input_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_structured_input_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_with_structured_input_without_preload_content">create_cwl_analysis_with_structured_input_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_analysis_without_preload_content">create_cwl_analysis_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_json_analysis" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_json_analysis">create_cwl_json_analysis</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_json_analysis_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_json_analysis_with_http_info">create_cwl_json_analysis_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_json_analysis_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_cwl_json_analysis_without_preload_content">create_cwl_json_analysis_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis">create_nextflow_analysis</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_with_custom_input" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_with_custom_input">create_nextflow_analysis_with_custom_input</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_with_custom_input_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_with_custom_input_with_http_info">create_nextflow_analysis_with_custom_input_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_with_custom_input_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_with_custom_input_without_preload_content">create_nextflow_analysis_with_custom_input_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_with_http_info">create_nextflow_analysis_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_analysis_without_preload_content">create_nextflow_analysis_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_json_analysis" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_json_analysis">create_nextflow_json_analysis</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_json_analysis_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_json_analysis_with_http_info">create_nextflow_json_analysis_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_json_analysis_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.create_nextflow_json_analysis_without_preload_content">create_nextflow_json_analysis_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analyses" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analyses">get_analyses</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analyses_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analyses_with_http_info">get_analyses_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analyses_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analyses_without_preload_content">get_analyses_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis">get_analysis</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_configurations" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_configurations">get_analysis_configurations</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_configurations_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_configurations_with_http_info">get_analysis_configurations_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_configurations_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_configurations_without_preload_content">get_analysis_configurations_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_inputs" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_inputs">get_analysis_inputs</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_inputs_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_inputs_with_http_info">get_analysis_inputs_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_inputs_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_inputs_without_preload_content">get_analysis_inputs_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_outputs" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_outputs">get_analysis_outputs</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_outputs_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_outputs_with_http_info">get_analysis_outputs_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_outputs_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_outputs_without_preload_content">get_analysis_outputs_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_reports" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_reports">get_analysis_reports</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_reports_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_reports_with_http_info">get_analysis_reports_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_reports_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_reports_without_preload_content">get_analysis_reports_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_steps" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_steps">get_analysis_steps</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_steps_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_steps_with_http_info">get_analysis_steps_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_steps_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_steps_without_preload_content">get_analysis_steps_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_usage_details" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_usage_details">get_analysis_usage_details</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_usage_details_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_usage_details_with_http_info">get_analysis_usage_details_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_usage_details_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_usage_details_without_preload_content">get_analysis_usage_details_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_with_http_info">get_analysis_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_analysis_without_preload_content">get_analysis_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_input_json" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_input_json">get_cwl_input_json</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_input_json_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_input_json_with_http_info">get_cwl_input_json_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_input_json_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_input_json_without_preload_content">get_cwl_input_json_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_output_json" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_output_json">get_cwl_output_json</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_output_json_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_output_json_with_http_info">get_cwl_output_json_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_output_json_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_cwl_output_json_without_preload_content">get_cwl_output_json_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_project_analysis_input_form_values" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_project_analysis_input_form_values">get_project_analysis_input_form_values</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_project_analysis_input_form_values_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_project_analysis_input_form_values_with_http_info">get_project_analysis_input_form_values_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_project_analysis_input_form_values_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_project_analysis_input_form_values_without_preload_content">get_project_analysis_input_form_values_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_raw_analysis_output" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_raw_analysis_output">get_raw_analysis_output</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_raw_analysis_output_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_raw_analysis_output_with_http_info">get_raw_analysis_output_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_raw_analysis_output_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.get_raw_analysis_output_without_preload_content">get_raw_analysis_output_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.search_analyses" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.search_analyses">search_analyses</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.search_analyses_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.search_analyses_with_http_info">search_analyses_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.search_analyses_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.search_analyses_without_preload_content">search_analyses_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.update_analysis" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.update_analysis">update_analysis</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.update_analysis_with_http_info" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.update_analysis_with_http_info">update_analysis_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.update_analysis_without_preload_content" href="#libica.openapi.v3.api.project_analysis_api.ProjectAnalysisApi.update_analysis_without_preload_content">update_analysis_without_preload_content</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
