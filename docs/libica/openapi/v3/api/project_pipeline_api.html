<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>libica.openapi.v3.api.project_pipeline_api API documentation</title>
<meta name="description" content="ICA Rest API â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>libica.openapi.v3.api.project_pipeline_api</code></h1>
</header>
<section id="section-intro">
<p>ICA Rest API</p>
<p>This API can be used to interact with Illumina Connected Analytics.<br> <h2>Authentication</h2> <p> Authentication to the
API can be done in multiple ways:<br> <ul><li>For the entire API, except for the POST /tokens endpoint: API-key + JWT</li> <li>Only for the POST /tokens endpoint: API-key + Basic Authentication</li></ul> </p> <p> <h4>API-key</h4> API keys are managed within the Illumina portal where you can manage your profile after you have logged on. The API-key has to be provided in the X-API-Key header parameter when executing API calls to ICA. In the background, a JWT will be requested at the IDP of Illumina to create a session. A good practice is to not use the API-key for every API call, but to first generate a JWT and to use that for authentication in subsequent calls.<br> </p> <p> <h4>JWT</h4> To avoid using an API-key for each call, we recommend to request a JWT via the POST /tokens endpoint
using this API-key. The JWT will expire after a pre-configured period specified by a tenant administrator through the IAM console in the Illumina portal. The JWT is the preferred way for authentication.<br>A not yet expired, still valid JWT could be refreshed using the POST /tokens:refresh endpoint.<br>Refreshing the JWT is not possible if the JWT was generated by using an API-key.<br> </p> <p> <h4>Basic Authentication</h4> Basic authentication is only supported by the POST /tokens endpoint for generating a JWT. Use "Basic base64encoded(emailaddress:password)" in the "Authorization" header parameter for this authentication method. In case having access to multiple tenants using the same email-address, also provide the "tenant" request parameter to indicate what tenant you would like to request a JWT for. </p> <p> <h2>Compression</h2> If the API client provides request header 'Accept-Encoding' with value 'gzip', then the API applies GZIP compression on the JSON response. This significantly reduces the size and thus the download time of the response, which results in faster end-to-end API calls. In case of compression, the API also provides response header 'Content-Encoding' with value 'gzip', as indication for the client that decompression is required. </p> </p>
<p>The version of the OpenAPI document: 3
Generated by OpenAPI Generator (<a href="https://openapi-generator.tech">https://openapi-generator.tech</a>)</p>
<p>Do not edit the class manually.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi"><code class="flex name class">
<span>class <span class="ident">ProjectPipelineApi</span></span>
<span>(</span><span>api_client=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProjectPipelineApi:
    &#34;&#34;&#34;NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    &#34;&#34;&#34;

    def __init__(self, api_client=None) -&gt; None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_additional_project_pipeline_file(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to create a file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; PipelineFile:
        &#34;&#34;&#34;Create an additional input form file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to create a file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_additional_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;PipelineFile&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_additional_project_pipeline_file_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to create a file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[PipelineFile]:
        &#34;&#34;&#34;Create an additional input form file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to create a file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_additional_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;PipelineFile&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_additional_project_pipeline_file_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to create a file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Create an additional input form file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to create a file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_additional_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;PipelineFile&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_additional_project_pipeline_file_serialize(
        self,
        project_id,
        pipeline_id,
        content,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if content is not None:
            _files[&#39;content&#39;] = content
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;multipart/form-data&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/inputForm/additionalFiles&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_cwl_json_pipeline(
        self,
        project_id: StrictStr,
        code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the CWL pipeline&#34;)],
        description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the CWL pipeline&#34;)],
        workflow_cwl_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The CWL workflow file.&#34;)],
        input_form_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The JSON based input form.&#34;)],
        analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
        tool_cwl_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        on_render_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will render the current state of the input form.&#34;)] = None,
        on_submit_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will submit the current state of the input form.&#34;)] = None,
        other_input_form_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
        links: Optional[Links] = None,
        version_comment: Optional[StrictStr] = None,
        categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
        html_documentation: Optional[StrictStr] = None,
        proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
        report_configs: Optional[PipelineReportConfig] = None,
        resources: Optional[PipelineResources] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ProjectPipelineV4:
        &#34;&#34;&#34;Create a JSON based CWL pipeline within a project.


        :param project_id: (required)
        :type project_id: str
        :param code: The code of the CWL pipeline (required)
        :type code: str
        :param description: The description of the CWL pipeline (required)
        :type description: str
        :param workflow_cwl_file: The CWL workflow file. (required)
        :type workflow_cwl_file: bytearray
        :param input_form_file: The JSON based input form. (required)
        :type input_form_file: bytearray
        :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
        :type analysis_storage_id: str
        :param tool_cwl_files:
        :type tool_cwl_files: List[bytearray]
        :param on_render_file: A file that will render the current state of the input form.
        :type on_render_file: bytearray
        :param on_submit_file: A file that will submit the current state of the input form.
        :type on_submit_file: bytearray
        :param other_input_form_files:
        :type other_input_form_files: List[bytearray]
        :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
        :type metadata_model_file: bytearray
        :param links:
        :type links: Links
        :param version_comment:
        :type version_comment: str
        :param categories:
        :type categories: List[Optional[str]]
        :param html_documentation:
        :type html_documentation: str
        :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
        :type proprietary: bool
        :param report_configs:
        :type report_configs: PipelineReportConfig
        :param resources:
        :type resources: PipelineResources
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_json_pipeline_serialize(
            project_id=project_id,
            code=code,
            description=description,
            workflow_cwl_file=workflow_cwl_file,
            input_form_file=input_form_file,
            analysis_storage_id=analysis_storage_id,
            tool_cwl_files=tool_cwl_files,
            on_render_file=on_render_file,
            on_submit_file=on_submit_file,
            other_input_form_files=other_input_form_files,
            metadata_model_file=metadata_model_file,
            links=links,
            version_comment=version_comment,
            categories=categories,
            html_documentation=html_documentation,
            proprietary=proprietary,
            report_configs=report_configs,
            resources=resources,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;ProjectPipelineV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_cwl_json_pipeline_with_http_info(
        self,
        project_id: StrictStr,
        code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the CWL pipeline&#34;)],
        description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the CWL pipeline&#34;)],
        workflow_cwl_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The CWL workflow file.&#34;)],
        input_form_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The JSON based input form.&#34;)],
        analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
        tool_cwl_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        on_render_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will render the current state of the input form.&#34;)] = None,
        on_submit_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will submit the current state of the input form.&#34;)] = None,
        other_input_form_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
        links: Optional[Links] = None,
        version_comment: Optional[StrictStr] = None,
        categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
        html_documentation: Optional[StrictStr] = None,
        proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
        report_configs: Optional[PipelineReportConfig] = None,
        resources: Optional[PipelineResources] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[ProjectPipelineV4]:
        &#34;&#34;&#34;Create a JSON based CWL pipeline within a project.


        :param project_id: (required)
        :type project_id: str
        :param code: The code of the CWL pipeline (required)
        :type code: str
        :param description: The description of the CWL pipeline (required)
        :type description: str
        :param workflow_cwl_file: The CWL workflow file. (required)
        :type workflow_cwl_file: bytearray
        :param input_form_file: The JSON based input form. (required)
        :type input_form_file: bytearray
        :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
        :type analysis_storage_id: str
        :param tool_cwl_files:
        :type tool_cwl_files: List[bytearray]
        :param on_render_file: A file that will render the current state of the input form.
        :type on_render_file: bytearray
        :param on_submit_file: A file that will submit the current state of the input form.
        :type on_submit_file: bytearray
        :param other_input_form_files:
        :type other_input_form_files: List[bytearray]
        :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
        :type metadata_model_file: bytearray
        :param links:
        :type links: Links
        :param version_comment:
        :type version_comment: str
        :param categories:
        :type categories: List[Optional[str]]
        :param html_documentation:
        :type html_documentation: str
        :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
        :type proprietary: bool
        :param report_configs:
        :type report_configs: PipelineReportConfig
        :param resources:
        :type resources: PipelineResources
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_json_pipeline_serialize(
            project_id=project_id,
            code=code,
            description=description,
            workflow_cwl_file=workflow_cwl_file,
            input_form_file=input_form_file,
            analysis_storage_id=analysis_storage_id,
            tool_cwl_files=tool_cwl_files,
            on_render_file=on_render_file,
            on_submit_file=on_submit_file,
            other_input_form_files=other_input_form_files,
            metadata_model_file=metadata_model_file,
            links=links,
            version_comment=version_comment,
            categories=categories,
            html_documentation=html_documentation,
            proprietary=proprietary,
            report_configs=report_configs,
            resources=resources,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;ProjectPipelineV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_cwl_json_pipeline_without_preload_content(
        self,
        project_id: StrictStr,
        code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the CWL pipeline&#34;)],
        description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the CWL pipeline&#34;)],
        workflow_cwl_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The CWL workflow file.&#34;)],
        input_form_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The JSON based input form.&#34;)],
        analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
        tool_cwl_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        on_render_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will render the current state of the input form.&#34;)] = None,
        on_submit_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will submit the current state of the input form.&#34;)] = None,
        other_input_form_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
        links: Optional[Links] = None,
        version_comment: Optional[StrictStr] = None,
        categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
        html_documentation: Optional[StrictStr] = None,
        proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
        report_configs: Optional[PipelineReportConfig] = None,
        resources: Optional[PipelineResources] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Create a JSON based CWL pipeline within a project.


        :param project_id: (required)
        :type project_id: str
        :param code: The code of the CWL pipeline (required)
        :type code: str
        :param description: The description of the CWL pipeline (required)
        :type description: str
        :param workflow_cwl_file: The CWL workflow file. (required)
        :type workflow_cwl_file: bytearray
        :param input_form_file: The JSON based input form. (required)
        :type input_form_file: bytearray
        :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
        :type analysis_storage_id: str
        :param tool_cwl_files:
        :type tool_cwl_files: List[bytearray]
        :param on_render_file: A file that will render the current state of the input form.
        :type on_render_file: bytearray
        :param on_submit_file: A file that will submit the current state of the input form.
        :type on_submit_file: bytearray
        :param other_input_form_files:
        :type other_input_form_files: List[bytearray]
        :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
        :type metadata_model_file: bytearray
        :param links:
        :type links: Links
        :param version_comment:
        :type version_comment: str
        :param categories:
        :type categories: List[Optional[str]]
        :param html_documentation:
        :type html_documentation: str
        :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
        :type proprietary: bool
        :param report_configs:
        :type report_configs: PipelineReportConfig
        :param resources:
        :type resources: PipelineResources
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_json_pipeline_serialize(
            project_id=project_id,
            code=code,
            description=description,
            workflow_cwl_file=workflow_cwl_file,
            input_form_file=input_form_file,
            analysis_storage_id=analysis_storage_id,
            tool_cwl_files=tool_cwl_files,
            on_render_file=on_render_file,
            on_submit_file=on_submit_file,
            other_input_form_files=other_input_form_files,
            metadata_model_file=metadata_model_file,
            links=links,
            version_comment=version_comment,
            categories=categories,
            html_documentation=html_documentation,
            proprietary=proprietary,
            report_configs=report_configs,
            resources=resources,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;ProjectPipelineV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_cwl_json_pipeline_serialize(
        self,
        project_id,
        code,
        description,
        workflow_cwl_file,
        input_form_file,
        analysis_storage_id,
        tool_cwl_files,
        on_render_file,
        on_submit_file,
        other_input_form_files,
        metadata_model_file,
        links,
        version_comment,
        categories,
        html_documentation,
        proprietary,
        report_configs,
        resources,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            &#39;toolCwlFiles&#39;: &#39;csv&#39;,
            &#39;otherInputFormFiles&#39;: &#39;csv&#39;,
            &#39;categories&#39;: &#39;csv&#39;,
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if code is not None:
            _form_params.append((&#39;code&#39;, code))
        if description is not None:
            _form_params.append((&#39;description&#39;, description))
        if workflow_cwl_file is not None:
            _files[&#39;workflowCwlFile&#39;] = workflow_cwl_file
        if tool_cwl_files is not None:
            _files[&#39;toolCwlFiles&#39;] = tool_cwl_files
        if input_form_file is not None:
            _files[&#39;inputFormFile&#39;] = input_form_file
        if on_render_file is not None:
            _files[&#39;onRenderFile&#39;] = on_render_file
        if on_submit_file is not None:
            _files[&#39;onSubmitFile&#39;] = on_submit_file
        if other_input_form_files is not None:
            _files[&#39;otherInputFormFiles&#39;] = other_input_form_files
        if metadata_model_file is not None:
            _files[&#39;metadataModelFile&#39;] = metadata_model_file
        if links is not None:
            _form_params.append((&#39;links&#39;, links))
        if version_comment is not None:
            _form_params.append((&#39;versionComment&#39;, version_comment))
        if categories is not None:
            _form_params.append((&#39;categories&#39;, categories))
        if html_documentation is not None:
            _form_params.append((&#39;htmlDocumentation&#39;, html_documentation))
        if analysis_storage_id is not None:
            _form_params.append((&#39;analysisStorageId&#39;, analysis_storage_id))
        if proprietary is not None:
            _form_params.append((&#39;proprietary&#39;, proprietary))
        if report_configs is not None:
            _form_params.append((&#39;reportConfigs&#39;, report_configs))
        if resources is not None:
            _form_params.append((&#39;resources&#39;, resources))
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;multipart/form-data&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines:createCwlJsonPipeline&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_cwl_pipeline(
        self,
        project_id: StrictStr,
        code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the CWL pipeline&#34;)],
        description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the CWL pipeline&#34;)],
        workflow_cwl_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The CWL workflow file.&#34;)],
        parameters_xml_file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
        tool_cwl_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
        links: Optional[Links] = None,
        version_comment: Optional[StrictStr] = None,
        categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
        html_documentation: Optional[StrictStr] = None,
        proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
        report_configs: Optional[PipelineReportConfig] = None,
        resources: Optional[PipelineResources] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ProjectPipeline:
        &#34;&#34;&#34;Create a CWL pipeline within a project.


        :param project_id: (required)
        :type project_id: str
        :param code: The code of the CWL pipeline (required)
        :type code: str
        :param description: The description of the CWL pipeline (required)
        :type description: str
        :param workflow_cwl_file: The CWL workflow file. (required)
        :type workflow_cwl_file: bytearray
        :param parameters_xml_file: (required)
        :type parameters_xml_file: bytearray
        :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
        :type analysis_storage_id: str
        :param tool_cwl_files:
        :type tool_cwl_files: List[bytearray]
        :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
        :type metadata_model_file: bytearray
        :param links:
        :type links: Links
        :param version_comment:
        :type version_comment: str
        :param categories:
        :type categories: List[Optional[str]]
        :param html_documentation:
        :type html_documentation: str
        :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
        :type proprietary: bool
        :param report_configs:
        :type report_configs: PipelineReportConfig
        :param resources:
        :type resources: PipelineResources
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_pipeline_serialize(
            project_id=project_id,
            code=code,
            description=description,
            workflow_cwl_file=workflow_cwl_file,
            parameters_xml_file=parameters_xml_file,
            analysis_storage_id=analysis_storage_id,
            tool_cwl_files=tool_cwl_files,
            metadata_model_file=metadata_model_file,
            links=links,
            version_comment=version_comment,
            categories=categories,
            html_documentation=html_documentation,
            proprietary=proprietary,
            report_configs=report_configs,
            resources=resources,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;ProjectPipeline&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_cwl_pipeline_with_http_info(
        self,
        project_id: StrictStr,
        code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the CWL pipeline&#34;)],
        description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the CWL pipeline&#34;)],
        workflow_cwl_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The CWL workflow file.&#34;)],
        parameters_xml_file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
        tool_cwl_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
        links: Optional[Links] = None,
        version_comment: Optional[StrictStr] = None,
        categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
        html_documentation: Optional[StrictStr] = None,
        proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
        report_configs: Optional[PipelineReportConfig] = None,
        resources: Optional[PipelineResources] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[ProjectPipeline]:
        &#34;&#34;&#34;Create a CWL pipeline within a project.


        :param project_id: (required)
        :type project_id: str
        :param code: The code of the CWL pipeline (required)
        :type code: str
        :param description: The description of the CWL pipeline (required)
        :type description: str
        :param workflow_cwl_file: The CWL workflow file. (required)
        :type workflow_cwl_file: bytearray
        :param parameters_xml_file: (required)
        :type parameters_xml_file: bytearray
        :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
        :type analysis_storage_id: str
        :param tool_cwl_files:
        :type tool_cwl_files: List[bytearray]
        :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
        :type metadata_model_file: bytearray
        :param links:
        :type links: Links
        :param version_comment:
        :type version_comment: str
        :param categories:
        :type categories: List[Optional[str]]
        :param html_documentation:
        :type html_documentation: str
        :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
        :type proprietary: bool
        :param report_configs:
        :type report_configs: PipelineReportConfig
        :param resources:
        :type resources: PipelineResources
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_pipeline_serialize(
            project_id=project_id,
            code=code,
            description=description,
            workflow_cwl_file=workflow_cwl_file,
            parameters_xml_file=parameters_xml_file,
            analysis_storage_id=analysis_storage_id,
            tool_cwl_files=tool_cwl_files,
            metadata_model_file=metadata_model_file,
            links=links,
            version_comment=version_comment,
            categories=categories,
            html_documentation=html_documentation,
            proprietary=proprietary,
            report_configs=report_configs,
            resources=resources,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;ProjectPipeline&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_cwl_pipeline_without_preload_content(
        self,
        project_id: StrictStr,
        code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the CWL pipeline&#34;)],
        description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the CWL pipeline&#34;)],
        workflow_cwl_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The CWL workflow file.&#34;)],
        parameters_xml_file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
        tool_cwl_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
        links: Optional[Links] = None,
        version_comment: Optional[StrictStr] = None,
        categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
        html_documentation: Optional[StrictStr] = None,
        proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
        report_configs: Optional[PipelineReportConfig] = None,
        resources: Optional[PipelineResources] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Create a CWL pipeline within a project.


        :param project_id: (required)
        :type project_id: str
        :param code: The code of the CWL pipeline (required)
        :type code: str
        :param description: The description of the CWL pipeline (required)
        :type description: str
        :param workflow_cwl_file: The CWL workflow file. (required)
        :type workflow_cwl_file: bytearray
        :param parameters_xml_file: (required)
        :type parameters_xml_file: bytearray
        :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
        :type analysis_storage_id: str
        :param tool_cwl_files:
        :type tool_cwl_files: List[bytearray]
        :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
        :type metadata_model_file: bytearray
        :param links:
        :type links: Links
        :param version_comment:
        :type version_comment: str
        :param categories:
        :type categories: List[Optional[str]]
        :param html_documentation:
        :type html_documentation: str
        :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
        :type proprietary: bool
        :param report_configs:
        :type report_configs: PipelineReportConfig
        :param resources:
        :type resources: PipelineResources
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_cwl_pipeline_serialize(
            project_id=project_id,
            code=code,
            description=description,
            workflow_cwl_file=workflow_cwl_file,
            parameters_xml_file=parameters_xml_file,
            analysis_storage_id=analysis_storage_id,
            tool_cwl_files=tool_cwl_files,
            metadata_model_file=metadata_model_file,
            links=links,
            version_comment=version_comment,
            categories=categories,
            html_documentation=html_documentation,
            proprietary=proprietary,
            report_configs=report_configs,
            resources=resources,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;ProjectPipeline&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_cwl_pipeline_serialize(
        self,
        project_id,
        code,
        description,
        workflow_cwl_file,
        parameters_xml_file,
        analysis_storage_id,
        tool_cwl_files,
        metadata_model_file,
        links,
        version_comment,
        categories,
        html_documentation,
        proprietary,
        report_configs,
        resources,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            &#39;toolCwlFiles&#39;: &#39;csv&#39;,
            &#39;categories&#39;: &#39;csv&#39;,
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if code is not None:
            _form_params.append((&#39;code&#39;, code))
        if description is not None:
            _form_params.append((&#39;description&#39;, description))
        if workflow_cwl_file is not None:
            _files[&#39;workflowCwlFile&#39;] = workflow_cwl_file
        if tool_cwl_files is not None:
            _files[&#39;toolCwlFiles&#39;] = tool_cwl_files
        if parameters_xml_file is not None:
            _files[&#39;parametersXmlFile&#39;] = parameters_xml_file
        if metadata_model_file is not None:
            _files[&#39;metadataModelFile&#39;] = metadata_model_file
        if links is not None:
            _form_params.append((&#39;links&#39;, links))
        if version_comment is not None:
            _form_params.append((&#39;versionComment&#39;, version_comment))
        if categories is not None:
            _form_params.append((&#39;categories&#39;, categories))
        if html_documentation is not None:
            _form_params.append((&#39;htmlDocumentation&#39;, html_documentation))
        if analysis_storage_id is not None:
            _form_params.append((&#39;analysisStorageId&#39;, analysis_storage_id))
        if proprietary is not None:
            _form_params.append((&#39;proprietary&#39;, proprietary))
        if report_configs is not None:
            _form_params.append((&#39;reportConfigs&#39;, report_configs))
        if resources is not None:
            _form_params.append((&#39;resources&#39;, resources))
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;multipart/form-data&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines:createCwlPipeline&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_nextflow_json_pipeline(
        self,
        project_id: StrictStr,
        code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the pipeline&#34;)],
        description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the pipeline&#34;)],
        main_nextflow_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The main Nextflow file.&#34;)],
        input_form_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The JSON based input form.&#34;)],
        analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
        pipeline_language_version_id: Annotated[Optional[StrictStr], Field(description=&#34;The id of the Nextflow version to use for the pipeline.&#34;)] = None,
        nextflow_config_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The Nextflow config file.&#34;)] = None,
        other_nextflow_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        on_render_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will render the current state of the input form.&#34;)] = None,
        on_submit_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will submit the current state of the input form.&#34;)] = None,
        other_input_form_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
        links: Optional[Links] = None,
        version_comment: Optional[StrictStr] = None,
        categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
        html_documentation: Optional[StrictStr] = None,
        proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
        report_configs: Optional[PipelineReportConfig] = None,
        resources: Optional[PipelineResources] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; PipelineV4:
        &#34;&#34;&#34;Create a JSON based Nextflow pipeline within a project.


        :param project_id: (required)
        :type project_id: str
        :param code: The code of the pipeline (required)
        :type code: str
        :param description: The description of the pipeline (required)
        :type description: str
        :param main_nextflow_file: The main Nextflow file. (required)
        :type main_nextflow_file: bytearray
        :param input_form_file: The JSON based input form. (required)
        :type input_form_file: bytearray
        :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
        :type analysis_storage_id: str
        :param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
        :type pipeline_language_version_id: str
        :param nextflow_config_file: The Nextflow config file.
        :type nextflow_config_file: bytearray
        :param other_nextflow_files:
        :type other_nextflow_files: List[bytearray]
        :param on_render_file: A file that will render the current state of the input form.
        :type on_render_file: bytearray
        :param on_submit_file: A file that will submit the current state of the input form.
        :type on_submit_file: bytearray
        :param other_input_form_files:
        :type other_input_form_files: List[bytearray]
        :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
        :type metadata_model_file: bytearray
        :param links:
        :type links: Links
        :param version_comment:
        :type version_comment: str
        :param categories:
        :type categories: List[Optional[str]]
        :param html_documentation:
        :type html_documentation: str
        :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
        :type proprietary: bool
        :param report_configs:
        :type report_configs: PipelineReportConfig
        :param resources:
        :type resources: PipelineResources
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_json_pipeline_serialize(
            project_id=project_id,
            code=code,
            description=description,
            main_nextflow_file=main_nextflow_file,
            input_form_file=input_form_file,
            analysis_storage_id=analysis_storage_id,
            pipeline_language_version_id=pipeline_language_version_id,
            nextflow_config_file=nextflow_config_file,
            other_nextflow_files=other_nextflow_files,
            on_render_file=on_render_file,
            on_submit_file=on_submit_file,
            other_input_form_files=other_input_form_files,
            metadata_model_file=metadata_model_file,
            links=links,
            version_comment=version_comment,
            categories=categories,
            html_documentation=html_documentation,
            proprietary=proprietary,
            report_configs=report_configs,
            resources=resources,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;PipelineV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_nextflow_json_pipeline_with_http_info(
        self,
        project_id: StrictStr,
        code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the pipeline&#34;)],
        description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the pipeline&#34;)],
        main_nextflow_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The main Nextflow file.&#34;)],
        input_form_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The JSON based input form.&#34;)],
        analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
        pipeline_language_version_id: Annotated[Optional[StrictStr], Field(description=&#34;The id of the Nextflow version to use for the pipeline.&#34;)] = None,
        nextflow_config_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The Nextflow config file.&#34;)] = None,
        other_nextflow_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        on_render_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will render the current state of the input form.&#34;)] = None,
        on_submit_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will submit the current state of the input form.&#34;)] = None,
        other_input_form_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
        links: Optional[Links] = None,
        version_comment: Optional[StrictStr] = None,
        categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
        html_documentation: Optional[StrictStr] = None,
        proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
        report_configs: Optional[PipelineReportConfig] = None,
        resources: Optional[PipelineResources] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[PipelineV4]:
        &#34;&#34;&#34;Create a JSON based Nextflow pipeline within a project.


        :param project_id: (required)
        :type project_id: str
        :param code: The code of the pipeline (required)
        :type code: str
        :param description: The description of the pipeline (required)
        :type description: str
        :param main_nextflow_file: The main Nextflow file. (required)
        :type main_nextflow_file: bytearray
        :param input_form_file: The JSON based input form. (required)
        :type input_form_file: bytearray
        :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
        :type analysis_storage_id: str
        :param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
        :type pipeline_language_version_id: str
        :param nextflow_config_file: The Nextflow config file.
        :type nextflow_config_file: bytearray
        :param other_nextflow_files:
        :type other_nextflow_files: List[bytearray]
        :param on_render_file: A file that will render the current state of the input form.
        :type on_render_file: bytearray
        :param on_submit_file: A file that will submit the current state of the input form.
        :type on_submit_file: bytearray
        :param other_input_form_files:
        :type other_input_form_files: List[bytearray]
        :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
        :type metadata_model_file: bytearray
        :param links:
        :type links: Links
        :param version_comment:
        :type version_comment: str
        :param categories:
        :type categories: List[Optional[str]]
        :param html_documentation:
        :type html_documentation: str
        :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
        :type proprietary: bool
        :param report_configs:
        :type report_configs: PipelineReportConfig
        :param resources:
        :type resources: PipelineResources
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_json_pipeline_serialize(
            project_id=project_id,
            code=code,
            description=description,
            main_nextflow_file=main_nextflow_file,
            input_form_file=input_form_file,
            analysis_storage_id=analysis_storage_id,
            pipeline_language_version_id=pipeline_language_version_id,
            nextflow_config_file=nextflow_config_file,
            other_nextflow_files=other_nextflow_files,
            on_render_file=on_render_file,
            on_submit_file=on_submit_file,
            other_input_form_files=other_input_form_files,
            metadata_model_file=metadata_model_file,
            links=links,
            version_comment=version_comment,
            categories=categories,
            html_documentation=html_documentation,
            proprietary=proprietary,
            report_configs=report_configs,
            resources=resources,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;PipelineV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_nextflow_json_pipeline_without_preload_content(
        self,
        project_id: StrictStr,
        code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the pipeline&#34;)],
        description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the pipeline&#34;)],
        main_nextflow_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The main Nextflow file.&#34;)],
        input_form_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The JSON based input form.&#34;)],
        analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
        pipeline_language_version_id: Annotated[Optional[StrictStr], Field(description=&#34;The id of the Nextflow version to use for the pipeline.&#34;)] = None,
        nextflow_config_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The Nextflow config file.&#34;)] = None,
        other_nextflow_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        on_render_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will render the current state of the input form.&#34;)] = None,
        on_submit_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will submit the current state of the input form.&#34;)] = None,
        other_input_form_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
        links: Optional[Links] = None,
        version_comment: Optional[StrictStr] = None,
        categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
        html_documentation: Optional[StrictStr] = None,
        proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
        report_configs: Optional[PipelineReportConfig] = None,
        resources: Optional[PipelineResources] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Create a JSON based Nextflow pipeline within a project.


        :param project_id: (required)
        :type project_id: str
        :param code: The code of the pipeline (required)
        :type code: str
        :param description: The description of the pipeline (required)
        :type description: str
        :param main_nextflow_file: The main Nextflow file. (required)
        :type main_nextflow_file: bytearray
        :param input_form_file: The JSON based input form. (required)
        :type input_form_file: bytearray
        :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
        :type analysis_storage_id: str
        :param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
        :type pipeline_language_version_id: str
        :param nextflow_config_file: The Nextflow config file.
        :type nextflow_config_file: bytearray
        :param other_nextflow_files:
        :type other_nextflow_files: List[bytearray]
        :param on_render_file: A file that will render the current state of the input form.
        :type on_render_file: bytearray
        :param on_submit_file: A file that will submit the current state of the input form.
        :type on_submit_file: bytearray
        :param other_input_form_files:
        :type other_input_form_files: List[bytearray]
        :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
        :type metadata_model_file: bytearray
        :param links:
        :type links: Links
        :param version_comment:
        :type version_comment: str
        :param categories:
        :type categories: List[Optional[str]]
        :param html_documentation:
        :type html_documentation: str
        :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
        :type proprietary: bool
        :param report_configs:
        :type report_configs: PipelineReportConfig
        :param resources:
        :type resources: PipelineResources
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_json_pipeline_serialize(
            project_id=project_id,
            code=code,
            description=description,
            main_nextflow_file=main_nextflow_file,
            input_form_file=input_form_file,
            analysis_storage_id=analysis_storage_id,
            pipeline_language_version_id=pipeline_language_version_id,
            nextflow_config_file=nextflow_config_file,
            other_nextflow_files=other_nextflow_files,
            on_render_file=on_render_file,
            on_submit_file=on_submit_file,
            other_input_form_files=other_input_form_files,
            metadata_model_file=metadata_model_file,
            links=links,
            version_comment=version_comment,
            categories=categories,
            html_documentation=html_documentation,
            proprietary=proprietary,
            report_configs=report_configs,
            resources=resources,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;PipelineV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_nextflow_json_pipeline_serialize(
        self,
        project_id,
        code,
        description,
        main_nextflow_file,
        input_form_file,
        analysis_storage_id,
        pipeline_language_version_id,
        nextflow_config_file,
        other_nextflow_files,
        on_render_file,
        on_submit_file,
        other_input_form_files,
        metadata_model_file,
        links,
        version_comment,
        categories,
        html_documentation,
        proprietary,
        report_configs,
        resources,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            &#39;otherNextflowFiles&#39;: &#39;csv&#39;,
            &#39;otherInputFormFiles&#39;: &#39;csv&#39;,
            &#39;categories&#39;: &#39;csv&#39;,
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if code is not None:
            _form_params.append((&#39;code&#39;, code))
        if pipeline_language_version_id is not None:
            _form_params.append((&#39;pipelineLanguageVersionId&#39;, pipeline_language_version_id))
        if description is not None:
            _form_params.append((&#39;description&#39;, description))
        if main_nextflow_file is not None:
            _files[&#39;mainNextflowFile&#39;] = main_nextflow_file
        if nextflow_config_file is not None:
            _files[&#39;nextflowConfigFile&#39;] = nextflow_config_file
        if other_nextflow_files is not None:
            _files[&#39;otherNextflowFiles&#39;] = other_nextflow_files
        if input_form_file is not None:
            _files[&#39;inputFormFile&#39;] = input_form_file
        if on_render_file is not None:
            _files[&#39;onRenderFile&#39;] = on_render_file
        if on_submit_file is not None:
            _files[&#39;onSubmitFile&#39;] = on_submit_file
        if other_input_form_files is not None:
            _files[&#39;otherInputFormFiles&#39;] = other_input_form_files
        if metadata_model_file is not None:
            _files[&#39;metadataModelFile&#39;] = metadata_model_file
        if links is not None:
            _form_params.append((&#39;links&#39;, links))
        if version_comment is not None:
            _form_params.append((&#39;versionComment&#39;, version_comment))
        if categories is not None:
            _form_params.append((&#39;categories&#39;, categories))
        if html_documentation is not None:
            _form_params.append((&#39;htmlDocumentation&#39;, html_documentation))
        if analysis_storage_id is not None:
            _form_params.append((&#39;analysisStorageId&#39;, analysis_storage_id))
        if proprietary is not None:
            _form_params.append((&#39;proprietary&#39;, proprietary))
        if report_configs is not None:
            _form_params.append((&#39;reportConfigs&#39;, report_configs))
        if resources is not None:
            _form_params.append((&#39;resources&#39;, resources))
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;multipart/form-data&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines:createNextflowJsonPipeline&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_nextflow_pipeline(
        self,
        project_id: StrictStr,
        code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the pipeline&#34;)],
        description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the pipeline&#34;)],
        main_nextflow_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The main Nextflow file.&#34;)],
        parameters_xml_file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
        pipeline_language_version_id: Annotated[Optional[StrictStr], Field(description=&#34;The id of the Nextflow version to use for the pipeline.&#34;)] = None,
        nextflow_config_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The Nextflow config file.&#34;)] = None,
        other_nextflow_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
        links: Optional[Links] = None,
        version_comment: Optional[StrictStr] = None,
        categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
        html_documentation: Optional[StrictStr] = None,
        proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
        report_configs: Optional[PipelineReportConfig] = None,
        resources: Optional[PipelineResources] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ProjectPipeline:
        &#34;&#34;&#34;Create a Nextflow pipeline within a project.


        :param project_id: (required)
        :type project_id: str
        :param code: The code of the pipeline (required)
        :type code: str
        :param description: The description of the pipeline (required)
        :type description: str
        :param main_nextflow_file: The main Nextflow file. (required)
        :type main_nextflow_file: bytearray
        :param parameters_xml_file: (required)
        :type parameters_xml_file: bytearray
        :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
        :type analysis_storage_id: str
        :param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
        :type pipeline_language_version_id: str
        :param nextflow_config_file: The Nextflow config file.
        :type nextflow_config_file: bytearray
        :param other_nextflow_files:
        :type other_nextflow_files: List[bytearray]
        :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
        :type metadata_model_file: bytearray
        :param links:
        :type links: Links
        :param version_comment:
        :type version_comment: str
        :param categories:
        :type categories: List[Optional[str]]
        :param html_documentation:
        :type html_documentation: str
        :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
        :type proprietary: bool
        :param report_configs:
        :type report_configs: PipelineReportConfig
        :param resources:
        :type resources: PipelineResources
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_pipeline_serialize(
            project_id=project_id,
            code=code,
            description=description,
            main_nextflow_file=main_nextflow_file,
            parameters_xml_file=parameters_xml_file,
            analysis_storage_id=analysis_storage_id,
            pipeline_language_version_id=pipeline_language_version_id,
            nextflow_config_file=nextflow_config_file,
            other_nextflow_files=other_nextflow_files,
            metadata_model_file=metadata_model_file,
            links=links,
            version_comment=version_comment,
            categories=categories,
            html_documentation=html_documentation,
            proprietary=proprietary,
            report_configs=report_configs,
            resources=resources,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;ProjectPipeline&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_nextflow_pipeline_with_http_info(
        self,
        project_id: StrictStr,
        code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the pipeline&#34;)],
        description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the pipeline&#34;)],
        main_nextflow_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The main Nextflow file.&#34;)],
        parameters_xml_file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
        pipeline_language_version_id: Annotated[Optional[StrictStr], Field(description=&#34;The id of the Nextflow version to use for the pipeline.&#34;)] = None,
        nextflow_config_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The Nextflow config file.&#34;)] = None,
        other_nextflow_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
        links: Optional[Links] = None,
        version_comment: Optional[StrictStr] = None,
        categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
        html_documentation: Optional[StrictStr] = None,
        proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
        report_configs: Optional[PipelineReportConfig] = None,
        resources: Optional[PipelineResources] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[ProjectPipeline]:
        &#34;&#34;&#34;Create a Nextflow pipeline within a project.


        :param project_id: (required)
        :type project_id: str
        :param code: The code of the pipeline (required)
        :type code: str
        :param description: The description of the pipeline (required)
        :type description: str
        :param main_nextflow_file: The main Nextflow file. (required)
        :type main_nextflow_file: bytearray
        :param parameters_xml_file: (required)
        :type parameters_xml_file: bytearray
        :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
        :type analysis_storage_id: str
        :param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
        :type pipeline_language_version_id: str
        :param nextflow_config_file: The Nextflow config file.
        :type nextflow_config_file: bytearray
        :param other_nextflow_files:
        :type other_nextflow_files: List[bytearray]
        :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
        :type metadata_model_file: bytearray
        :param links:
        :type links: Links
        :param version_comment:
        :type version_comment: str
        :param categories:
        :type categories: List[Optional[str]]
        :param html_documentation:
        :type html_documentation: str
        :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
        :type proprietary: bool
        :param report_configs:
        :type report_configs: PipelineReportConfig
        :param resources:
        :type resources: PipelineResources
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_pipeline_serialize(
            project_id=project_id,
            code=code,
            description=description,
            main_nextflow_file=main_nextflow_file,
            parameters_xml_file=parameters_xml_file,
            analysis_storage_id=analysis_storage_id,
            pipeline_language_version_id=pipeline_language_version_id,
            nextflow_config_file=nextflow_config_file,
            other_nextflow_files=other_nextflow_files,
            metadata_model_file=metadata_model_file,
            links=links,
            version_comment=version_comment,
            categories=categories,
            html_documentation=html_documentation,
            proprietary=proprietary,
            report_configs=report_configs,
            resources=resources,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;ProjectPipeline&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_nextflow_pipeline_without_preload_content(
        self,
        project_id: StrictStr,
        code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the pipeline&#34;)],
        description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the pipeline&#34;)],
        main_nextflow_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The main Nextflow file.&#34;)],
        parameters_xml_file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
        pipeline_language_version_id: Annotated[Optional[StrictStr], Field(description=&#34;The id of the Nextflow version to use for the pipeline.&#34;)] = None,
        nextflow_config_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The Nextflow config file.&#34;)] = None,
        other_nextflow_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
        metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
        links: Optional[Links] = None,
        version_comment: Optional[StrictStr] = None,
        categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
        html_documentation: Optional[StrictStr] = None,
        proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
        report_configs: Optional[PipelineReportConfig] = None,
        resources: Optional[PipelineResources] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Create a Nextflow pipeline within a project.


        :param project_id: (required)
        :type project_id: str
        :param code: The code of the pipeline (required)
        :type code: str
        :param description: The description of the pipeline (required)
        :type description: str
        :param main_nextflow_file: The main Nextflow file. (required)
        :type main_nextflow_file: bytearray
        :param parameters_xml_file: (required)
        :type parameters_xml_file: bytearray
        :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
        :type analysis_storage_id: str
        :param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
        :type pipeline_language_version_id: str
        :param nextflow_config_file: The Nextflow config file.
        :type nextflow_config_file: bytearray
        :param other_nextflow_files:
        :type other_nextflow_files: List[bytearray]
        :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
        :type metadata_model_file: bytearray
        :param links:
        :type links: Links
        :param version_comment:
        :type version_comment: str
        :param categories:
        :type categories: List[Optional[str]]
        :param html_documentation:
        :type html_documentation: str
        :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
        :type proprietary: bool
        :param report_configs:
        :type report_configs: PipelineReportConfig
        :param resources:
        :type resources: PipelineResources
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_nextflow_pipeline_serialize(
            project_id=project_id,
            code=code,
            description=description,
            main_nextflow_file=main_nextflow_file,
            parameters_xml_file=parameters_xml_file,
            analysis_storage_id=analysis_storage_id,
            pipeline_language_version_id=pipeline_language_version_id,
            nextflow_config_file=nextflow_config_file,
            other_nextflow_files=other_nextflow_files,
            metadata_model_file=metadata_model_file,
            links=links,
            version_comment=version_comment,
            categories=categories,
            html_documentation=html_documentation,
            proprietary=proprietary,
            report_configs=report_configs,
            resources=resources,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;ProjectPipeline&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_nextflow_pipeline_serialize(
        self,
        project_id,
        code,
        description,
        main_nextflow_file,
        parameters_xml_file,
        analysis_storage_id,
        pipeline_language_version_id,
        nextflow_config_file,
        other_nextflow_files,
        metadata_model_file,
        links,
        version_comment,
        categories,
        html_documentation,
        proprietary,
        report_configs,
        resources,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            &#39;otherNextflowFiles&#39;: &#39;csv&#39;,
            &#39;categories&#39;: &#39;csv&#39;,
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if code is not None:
            _form_params.append((&#39;code&#39;, code))
        if pipeline_language_version_id is not None:
            _form_params.append((&#39;pipelineLanguageVersionId&#39;, pipeline_language_version_id))
        if description is not None:
            _form_params.append((&#39;description&#39;, description))
        if main_nextflow_file is not None:
            _files[&#39;mainNextflowFile&#39;] = main_nextflow_file
        if nextflow_config_file is not None:
            _files[&#39;nextflowConfigFile&#39;] = nextflow_config_file
        if other_nextflow_files is not None:
            _files[&#39;otherNextflowFiles&#39;] = other_nextflow_files
        if parameters_xml_file is not None:
            _files[&#39;parametersXmlFile&#39;] = parameters_xml_file
        if metadata_model_file is not None:
            _files[&#39;metadataModelFile&#39;] = metadata_model_file
        if links is not None:
            _form_params.append((&#39;links&#39;, links))
        if version_comment is not None:
            _form_params.append((&#39;versionComment&#39;, version_comment))
        if categories is not None:
            _form_params.append((&#39;categories&#39;, categories))
        if html_documentation is not None:
            _form_params.append((&#39;htmlDocumentation&#39;, html_documentation))
        if analysis_storage_id is not None:
            _form_params.append((&#39;analysisStorageId&#39;, analysis_storage_id))
        if proprietary is not None:
            _form_params.append((&#39;proprietary&#39;, proprietary))
        if report_configs is not None:
            _form_params.append((&#39;reportConfigs&#39;, report_configs))
        if resources is not None:
            _form_params.append((&#39;resources&#39;, resources))
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;multipart/form-data&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines:createNextflowPipeline&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_project_pipeline_file(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to create a file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; PipelineFile:
        &#34;&#34;&#34;Create a file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to create a file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;PipelineFile&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_project_pipeline_file_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to create a file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[PipelineFile]:
        &#34;&#34;&#34;Create a file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to create a file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;PipelineFile&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_project_pipeline_file_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to create a file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Create a file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to create a file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._create_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;201&#39;: &#34;PipelineFile&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_project_pipeline_file_serialize(
        self,
        project_id,
        pipeline_id,
        content,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if content is not None:
            _files[&#39;content&#39;] = content
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;multipart/form-data&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/files&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_additional_project_pipeline_file(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to delete an additional file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Delete an additional input form file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to delete an additional file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the pipeline file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._delete_additional_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_additional_project_pipeline_file_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to delete an additional file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[None]:
        &#34;&#34;&#34;Delete an additional input form file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to delete an additional file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the pipeline file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._delete_additional_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_additional_project_pipeline_file_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to delete an additional file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Delete an additional input form file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to delete an additional file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the pipeline file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._delete_additional_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_additional_project_pipeline_file_serialize(
        self,
        project_id,
        pipeline_id,
        file_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        if file_id is not None:
            _path_params[&#39;fileId&#39;] = file_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;DELETE&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/inputForm/additionalFiles/{fileId}&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_project_pipeline_file(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to delete a file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Delete a file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to delete a file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the pipeline file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._delete_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_project_pipeline_file_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to delete a file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[None]:
        &#34;&#34;&#34;Delete a file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to delete a file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the pipeline file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._delete_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_project_pipeline_file_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to delete a file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Delete a file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to delete a file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the pipeline file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._delete_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_project_pipeline_file_serialize(
        self,
        project_id,
        pipeline_id,
        file_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        if file_id is not None:
            _path_params[&#39;fileId&#39;] = file_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;DELETE&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/files/{fileId}&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def download_additional_file_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the additional file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the additional file&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; bytearray:
        &#34;&#34;&#34;Download the contents of an additional input form file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve the additional file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the additional file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_additional_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def download_additional_file_content_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the additional file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the additional file&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[bytearray]:
        &#34;&#34;&#34;Download the contents of an additional input form file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve the additional file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the additional file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_additional_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def download_additional_file_content_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the additional file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the additional file&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Download the contents of an additional input form file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve the additional file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the additional file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_additional_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _download_additional_file_content_serialize(
        self,
        project_id,
        pipeline_id,
        file_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        if file_id is not None:
            _path_params[&#39;fileId&#39;] = file_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/octet-stream&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/inputForm/additionalFiles/{fileId}/content&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def download_input_form_file_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the input form file for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; bytearray:
        &#34;&#34;&#34;Download the contents of the input form file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve the input form file for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_input_form_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def download_input_form_file_content_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the input form file for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[bytearray]:
        &#34;&#34;&#34;Download the contents of the input form file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve the input form file for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_input_form_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def download_input_form_file_content_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the input form file for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Download the contents of the input form file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve the input form file for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_input_form_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _download_input_form_file_content_serialize(
        self,
        project_id,
        pipeline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/octet-stream&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/inputForm/inputFormFile&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def download_on_render_file_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the onRender file for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; bytearray:
        &#34;&#34;&#34;Download the contents of the onRender file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve the onRender file for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_on_render_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def download_on_render_file_content_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the onRender file for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[bytearray]:
        &#34;&#34;&#34;Download the contents of the onRender file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve the onRender file for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_on_render_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def download_on_render_file_content_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the onRender file for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Download the contents of the onRender file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve the onRender file for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_on_render_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _download_on_render_file_content_serialize(
        self,
        project_id,
        pipeline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/octet-stream&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/inputForm/onRenderFile&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def download_on_submit_file_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the onSubmit file for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; bytearray:
        &#34;&#34;&#34;Download the contents of the onSubmit file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve the onSubmit file for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_on_submit_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def download_on_submit_file_content_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the onSubmit file for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[bytearray]:
        &#34;&#34;&#34;Download the contents of the onSubmit file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve the onSubmit file for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_on_submit_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def download_on_submit_file_content_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the onSubmit file for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Download the contents of the onSubmit file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve the onSubmit file for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_on_submit_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _download_on_submit_file_content_serialize(
        self,
        project_id,
        pipeline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/octet-stream&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/inputForm/onSubmitFile&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def download_project_pipeline_file_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; bytearray:
        &#34;&#34;&#34;Download the contents of a pipeline file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
        :type pipeline_id: str
        :param file_id: The ID of the pipeline file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_project_pipeline_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def download_project_pipeline_file_content_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[bytearray]:
        &#34;&#34;&#34;Download the contents of a pipeline file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
        :type pipeline_id: str
        :param file_id: The ID of the pipeline file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_project_pipeline_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def download_project_pipeline_file_content_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Download the contents of a pipeline file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
        :type pipeline_id: str
        :param file_id: The ID of the pipeline file (required)
        :type file_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._download_project_pipeline_file_content_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;bytearray&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _download_project_pipeline_file_content_serialize(
        self,
        project_id,
        pipeline_id,
        file_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        if file_id is not None:
            _path_params[&#39;fileId&#39;] = file_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/octet-stream&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/files/{fileId}/content&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_project_pipeline(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ProjectPipelineV4:
        &#34;&#34;&#34;Retrieve a project pipeline.

        Retrieves a project pipeline. This can be a pipeline from a linked bundle or an entitled, unlinked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;ProjectPipelineV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_project_pipeline_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[ProjectPipelineV4]:
        &#34;&#34;&#34;Retrieve a project pipeline.

        Retrieves a project pipeline. This can be a pipeline from a linked bundle or an entitled, unlinked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;ProjectPipelineV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_project_pipeline_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve a project pipeline.

        Retrieves a project pipeline. This can be a pipeline from a linked bundle or an entitled, unlinked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;ProjectPipelineV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_project_pipeline_serialize(
        self,
        project_id,
        pipeline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_project_pipeline_additional_files(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; PipelineFileList:
        &#34;&#34;&#34;Retrieve additional input form files for a project pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_additional_files_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineFileList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_project_pipeline_additional_files_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[PipelineFileList]:
        &#34;&#34;&#34;Retrieve additional input form files for a project pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_additional_files_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineFileList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_project_pipeline_additional_files_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve additional input form files for a project pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_additional_files_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineFileList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_project_pipeline_additional_files_serialize(
        self,
        project_id,
        pipeline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/inputForm/additionalFiles&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_project_pipeline_configuration_parameters(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve input parameters for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; PipelineConfigurationParameterList:
        &#34;&#34;&#34;Retrieve configuration parameters for a project pipeline.

        The pipeline can originate from a linked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_configuration_parameters_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineConfigurationParameterList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_project_pipeline_configuration_parameters_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve input parameters for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[PipelineConfigurationParameterList]:
        &#34;&#34;&#34;Retrieve configuration parameters for a project pipeline.

        The pipeline can originate from a linked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_configuration_parameters_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineConfigurationParameterList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_project_pipeline_configuration_parameters_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve input parameters for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve configuration parameters for a project pipeline.

        The pipeline can originate from a linked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_configuration_parameters_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineConfigurationParameterList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_project_pipeline_configuration_parameters_serialize(
        self,
        project_id,
        pipeline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/configurationParameters&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_project_pipeline_files(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; PipelineFileList:
        &#34;&#34;&#34;Retrieve files for a project pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_files_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineFileList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_project_pipeline_files_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[PipelineFileList]:
        &#34;&#34;&#34;Retrieve files for a project pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_files_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineFileList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_project_pipeline_files_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve files for a project pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_files_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineFileList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_project_pipeline_files_serialize(
        self,
        project_id,
        pipeline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/files&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_project_pipeline_html_documentation(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve HTML documentation from&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; PipelineHtmlDocumentation:
        &#34;&#34;&#34;Retrieve HTML documentation for a project pipeline.

        Retrieve HTML documentation for a project pipeline. This can be a pipeline from a linked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve HTML documentation from (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_html_documentation_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineHtmlDocumentation&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_project_pipeline_html_documentation_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve HTML documentation from&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[PipelineHtmlDocumentation]:
        &#34;&#34;&#34;Retrieve HTML documentation for a project pipeline.

        Retrieve HTML documentation for a project pipeline. This can be a pipeline from a linked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve HTML documentation from (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_html_documentation_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineHtmlDocumentation&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_project_pipeline_html_documentation_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve HTML documentation from&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve HTML documentation for a project pipeline.

        Retrieve HTML documentation for a project pipeline. This can be a pipeline from a linked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve HTML documentation from (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_html_documentation_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineHtmlDocumentation&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_project_pipeline_html_documentation_serialize(
        self,
        project_id,
        pipeline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/documentation/HTML&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_project_pipeline_input_parameters(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve input parameters for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; InputParameterList:
        &#34;&#34;&#34;Retrieve input parameters for a project pipeline.

        The pipeline can originate from a linked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_input_parameters_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;InputParameterList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_project_pipeline_input_parameters_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve input parameters for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[InputParameterList]:
        &#34;&#34;&#34;Retrieve input parameters for a project pipeline.

        The pipeline can originate from a linked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_input_parameters_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;InputParameterList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_project_pipeline_input_parameters_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve input parameters for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve input parameters for a project pipeline.

        The pipeline can originate from a linked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_input_parameters_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;InputParameterList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_project_pipeline_input_parameters_serialize(
        self,
        project_id,
        pipeline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/inputParameters&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_project_pipeline_reference_sets(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline to retrieve reference sets for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ReferenceSetList:
        &#34;&#34;&#34;Retrieve the reference sets of a project pipeline.

        Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the pipeline to retrieve reference sets for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_reference_sets_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;ReferenceSetList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_project_pipeline_reference_sets_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline to retrieve reference sets for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[ReferenceSetList]:
        &#34;&#34;&#34;Retrieve the reference sets of a project pipeline.

        Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the pipeline to retrieve reference sets for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_reference_sets_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;ReferenceSetList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_project_pipeline_reference_sets_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline to retrieve reference sets for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve the reference sets of a project pipeline.

        Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the pipeline to retrieve reference sets for (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipeline_reference_sets_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;ReferenceSetList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_project_pipeline_reference_sets_serialize(
        self,
        project_id,
        pipeline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/referenceSets&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_project_pipelines(
        self,
        project_id: Annotated[StrictStr, Field(description=&#34;The ID of the project to retrieve pipelines for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ProjectPipelineList:
        &#34;&#34;&#34;Retrieve a list of project pipelines.

        Lists all pipelines that are available to the project.

        :param project_id: The ID of the project to retrieve pipelines for (required)
        :type project_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipelines_serialize(
            project_id=project_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;ProjectPipelineList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_project_pipelines_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description=&#34;The ID of the project to retrieve pipelines for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[ProjectPipelineList]:
        &#34;&#34;&#34;Retrieve a list of project pipelines.

        Lists all pipelines that are available to the project.

        :param project_id: The ID of the project to retrieve pipelines for (required)
        :type project_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipelines_serialize(
            project_id=project_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;ProjectPipelineList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_project_pipelines_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description=&#34;The ID of the project to retrieve pipelines for&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Retrieve a list of project pipelines.

        Lists all pipelines that are available to the project.

        :param project_id: The ID of the project to retrieve pipelines for (required)
        :type project_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._get_project_pipelines_serialize(
            project_id=project_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;ProjectPipelineList&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_project_pipelines_serialize(
        self,
        project_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v3+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;GET&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def link_pipeline_to_project(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Link a pipeline to a project.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the pipeline (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._link_pipeline_to_project_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def link_pipeline_to_project_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[None]:
        &#34;&#34;&#34;Link a pipeline to a project.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the pipeline (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._link_pipeline_to_project_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def link_pipeline_to_project_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Link a pipeline to a project.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the pipeline (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._link_pipeline_to_project_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _link_pipeline_to_project_serialize(
        self,
        project_id,
        pipeline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def release_project_pipeline(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Release a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the pipeline (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._release_project_pipeline_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def release_project_pipeline_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[None]:
        &#34;&#34;&#34;Release a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the pipeline (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._release_project_pipeline_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def release_project_pipeline_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Release a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the pipeline (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._release_project_pipeline_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _release_project_pipeline_serialize(
        self,
        project_id,
        pipeline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}:release&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def unlink_pipeline_from_project(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Unlink a pipeline from a project.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the pipeline (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._unlink_pipeline_from_project_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def unlink_pipeline_from_project_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[None]:
        &#34;&#34;&#34;Unlink a pipeline from a project.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the pipeline (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._unlink_pipeline_from_project_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def unlink_pipeline_from_project_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Unlink a pipeline from a project.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the pipeline (required)
        :type pipeline_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._unlink_pipeline_from_project_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;204&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _unlink_pipeline_from_project_serialize(
        self,
        project_id,
        pipeline_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;DELETE&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_additional_file(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the additional file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the additional file&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Update the contents of an additional input form file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update the additional file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the additional file (required)
        :type file_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_additional_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_additional_file_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the additional file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the additional file&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[None]:
        &#34;&#34;&#34;Update the contents of an additional input form file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update the additional file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the additional file (required)
        :type file_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_additional_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_additional_file_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the additional file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the additional file&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Update the contents of an additional input form file.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update the additional file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the additional file (required)
        :type file_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_additional_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_additional_file_serialize(
        self,
        project_id,
        pipeline_id,
        file_id,
        content,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        if file_id is not None:
            _path_params[&#39;fileId&#39;] = file_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if content is not None:
            _files[&#39;content&#39;] = content
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;multipart/form-data&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;PUT&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/inputForm/additionalFiles/{fileId}/content&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_general_attributes_project_pipeline(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update&#34;)],
        pipeline_update: PipelineUpdate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; PipelineV4:
        &#34;&#34;&#34;Update the general attributes of a project pipeline.

        Attributes which can be updated: - code - description - languageVersion - proprietary - resources 

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update (required)
        :type pipeline_id: str
        :param pipeline_update: (required)
        :type pipeline_update: PipelineUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_general_attributes_project_pipeline_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            pipeline_update=pipeline_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_general_attributes_project_pipeline_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update&#34;)],
        pipeline_update: PipelineUpdate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[PipelineV4]:
        &#34;&#34;&#34;Update the general attributes of a project pipeline.

        Attributes which can be updated: - code - description - languageVersion - proprietary - resources 

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update (required)
        :type pipeline_id: str
        :param pipeline_update: (required)
        :type pipeline_update: PipelineUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_general_attributes_project_pipeline_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            pipeline_update=pipeline_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_general_attributes_project_pipeline_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update&#34;)],
        pipeline_update: PipelineUpdate,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Update the general attributes of a project pipeline.

        Attributes which can be updated: - code - description - languageVersion - proprietary - resources 

        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update (required)
        :type pipeline_id: str
        :param pipeline_update: (required)
        :type pipeline_update: PipelineUpdate
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_general_attributes_project_pipeline_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            pipeline_update=pipeline_update,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: &#34;PipelineV4&#34;,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_general_attributes_project_pipeline_serialize(
        self,
        project_id,
        pipeline_id,
        pipeline_update,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if pipeline_update is not None:
            _body_params = pipeline_update


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;, 
                    &#39;application/vnd.illumina.v4+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;application/vnd.illumina.v4+json&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;POST&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/generalAttributes&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_input_form_file(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update a file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Update the contents of the input form file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update a file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_input_form_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_input_form_file_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update a file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[None]:
        &#34;&#34;&#34;Update the contents of the input form file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update a file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_input_form_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_input_form_file_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update a file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Update the contents of the input form file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update a file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_input_form_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_input_form_file_serialize(
        self,
        project_id,
        pipeline_id,
        content,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if content is not None:
            _files[&#39;content&#39;] = content
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;multipart/form-data&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;PUT&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/inputForm/inputFormFile&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_on_render_file(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the onRender file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Update the contents of the onRender file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update the onRender file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_on_render_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_on_render_file_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the onRender file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[None]:
        &#34;&#34;&#34;Update the contents of the onRender file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update the onRender file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_on_render_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_on_render_file_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the onRender file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Update the contents of the onRender file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update the onRender file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_on_render_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_on_render_file_serialize(
        self,
        project_id,
        pipeline_id,
        content,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if content is not None:
            _files[&#39;content&#39;] = content
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;multipart/form-data&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;PUT&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/inputForm/onRenderFile&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_on_submit_file(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the onSubmit file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Update the contents of the onSubmit file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update the onSubmit file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_on_submit_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_on_submit_file_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the onSubmit file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[None]:
        &#34;&#34;&#34;Update the contents of the onSubmit file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update the onSubmit file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_on_submit_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_on_submit_file_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the onSubmit file for&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Update the contents of the onSubmit file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update the onSubmit file for (required)
        :type pipeline_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_on_submit_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_on_submit_file_serialize(
        self,
        project_id,
        pipeline_id,
        content,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if content is not None:
            _files[&#39;content&#39;] = content
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;multipart/form-data&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;PUT&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/inputForm/onSubmitFile&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_project_pipeline_file(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update a file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; None:
        &#34;&#34;&#34;Update the contents of a file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update a file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the pipeline file (required)
        :type file_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_project_pipeline_file_with_http_info(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update a file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; ApiResponse[None]:
        &#34;&#34;&#34;Update the contents of a file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update a file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the pipeline file (required)
        :type file_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_project_pipeline_file_without_preload_content(
        self,
        project_id: StrictStr,
        pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update a file for&#34;)],
        file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
        content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -&gt; RESTResponseType:
        &#34;&#34;&#34;Update the contents of a file for a pipeline.


        :param project_id: (required)
        :type project_id: str
        :param pipeline_id: The ID of the project pipeline to update a file for (required)
        :type pipeline_id: str
        :param file_id: The ID of the pipeline file (required)
        :type file_id: str
        :param content: (required)
        :type content: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        &#34;&#34;&#34; # noqa: E501

        _param = self._update_project_pipeline_file_serialize(
            project_id=project_id,
            pipeline_id=pipeline_id,
            file_id=file_id,
            content=content,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            &#39;200&#39;: None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_project_pipeline_file_serialize(
        self,
        project_id,
        pipeline_id,
        file_id,
        content,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -&gt; RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params[&#39;projectId&#39;] = project_id
        if pipeline_id is not None:
            _path_params[&#39;pipelineId&#39;] = pipeline_id
        if file_id is not None:
            _path_params[&#39;fileId&#39;] = file_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if content is not None:
            _files[&#39;content&#39;] = content
        # process the body parameter


        # set the HTTP header `Accept`
        if &#39;Accept&#39; not in _header_params:
            _header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
                [
                    &#39;application/problem+json&#39;
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params[&#39;Content-Type&#39;] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        &#39;multipart/form-data&#39;
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params[&#39;Content-Type&#39;] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            &#39;JwtAuth&#39;, 
            &#39;ApiKeyAuth&#39;
        ]

        return self.api_client.param_serialize(
            method=&#39;PUT&#39;,
            resource_path=&#39;/api/projects/{projectId}/pipelines/{pipelineId}/files/{fileId}/content&#39;,
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )</code></pre>
</details>
<div class="desc"><p>NOTE: This class is auto generated by OpenAPI Generator
Ref: <a href="https://openapi-generator.tech">https://openapi-generator.tech</a></p>
<p>Do not edit the class manually.</p></div>
<h3>Methods</h3>
<dl>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_additional_project_pipeline_file"><code class="name flex">
<span>def <span class="ident">create_additional_project_pipeline_file</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ createÂ aÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â <a title="libica.openapi.v3.models.pipeline_file.PipelineFile" href="../models/pipeline_file.html#libica.openapi.v3.models.pipeline_file.PipelineFile">PipelineFile</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_additional_project_pipeline_file(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to create a file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; PipelineFile:
    &#34;&#34;&#34;Create an additional input form file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to create a file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_additional_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;PipelineFile&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Create an additional input form file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to create a file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_additional_project_pipeline_file_with_http_info"><code class="name flex">
<span>def <span class="ident">create_additional_project_pipeline_file_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ createÂ aÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[PipelineFile]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_additional_project_pipeline_file_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to create a file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[PipelineFile]:
    &#34;&#34;&#34;Create an additional input form file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to create a file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_additional_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;PipelineFile&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Create an additional input form file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to create a file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_additional_project_pipeline_file_without_preload_content"><code class="name flex">
<span>def <span class="ident">create_additional_project_pipeline_file_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ createÂ aÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_additional_project_pipeline_file_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to create a file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Create an additional input form file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to create a file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_additional_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;PipelineFile&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Create an additional input form file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to create a file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_json_pipeline"><code class="name flex">
<span>def <span class="ident">create_cwl_json_pipeline</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>code:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ codeÂ ofÂ theÂ CWLÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=255)])],<br>description:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ descriptionÂ ofÂ theÂ CWLÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=4000)])],<br>workflow_cwl_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ CWLÂ workflowÂ file.')],<br>input_form_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ JSONÂ basedÂ inputÂ form.')],<br>analysis_storage_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ storageÂ toÂ useÂ forÂ theÂ pipeline.')],<br>tool_cwl_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>on_render_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ fileÂ thatÂ willÂ renderÂ theÂ currentÂ stateÂ ofÂ theÂ inputÂ form.')]Â =Â None,<br>on_submit_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ fileÂ thatÂ willÂ submitÂ theÂ currentÂ stateÂ ofÂ theÂ inputÂ form.')]Â =Â None,<br>other_input_form_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>metadata_model_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ metadataÂ modelÂ jsonÂ file(contentsÂ canÂ beÂ retrievedÂ fromÂ theÂ controlplane).')]Â =Â None,<br>links:Â <a title="libica.openapi.v3.models.links.Links" href="../models/links.html#libica.openapi.v3.models.links.Links">Links</a>Â |Â NoneÂ =Â None,<br>version_comment:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>categories:Â Annotated[List[Annotated[str,Â Strict(strict=True)]Â |Â None],Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[MinLen(min_length=1),Â MaxLen(max_length=4000)])]Â |Â NoneÂ =Â None,<br>html_documentation:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>proprietary:Â Annotated[Annotated[bool,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ booleanÂ whichÂ indicatesÂ ifÂ theÂ codeÂ ofÂ thisÂ pipelineÂ isÂ proprietary')]Â =Â None,<br>report_configs:Â <a title="libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig" href="../models/pipeline_report_config.html#libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig">PipelineReportConfig</a>Â |Â NoneÂ =Â None,<br>resources:Â <a title="libica.openapi.v3.models.pipeline_resources.PipelineResources" href="../models/pipeline_resources.html#libica.openapi.v3.models.pipeline_resources.PipelineResources">PipelineResources</a>Â |Â NoneÂ =Â None) â€‘>Â <a title="libica.openapi.v3.models.project_pipeline_v4.ProjectPipelineV4" href="../models/project_pipeline_v4.html#libica.openapi.v3.models.project_pipeline_v4.ProjectPipelineV4">ProjectPipelineV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_json_pipeline(
    self,
    project_id: StrictStr,
    code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the CWL pipeline&#34;)],
    description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the CWL pipeline&#34;)],
    workflow_cwl_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The CWL workflow file.&#34;)],
    input_form_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The JSON based input form.&#34;)],
    analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
    tool_cwl_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    on_render_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will render the current state of the input form.&#34;)] = None,
    on_submit_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will submit the current state of the input form.&#34;)] = None,
    other_input_form_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
    links: Optional[Links] = None,
    version_comment: Optional[StrictStr] = None,
    categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
    html_documentation: Optional[StrictStr] = None,
    proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
    report_configs: Optional[PipelineReportConfig] = None,
    resources: Optional[PipelineResources] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ProjectPipelineV4:
    &#34;&#34;&#34;Create a JSON based CWL pipeline within a project.


    :param project_id: (required)
    :type project_id: str
    :param code: The code of the CWL pipeline (required)
    :type code: str
    :param description: The description of the CWL pipeline (required)
    :type description: str
    :param workflow_cwl_file: The CWL workflow file. (required)
    :type workflow_cwl_file: bytearray
    :param input_form_file: The JSON based input form. (required)
    :type input_form_file: bytearray
    :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
    :type analysis_storage_id: str
    :param tool_cwl_files:
    :type tool_cwl_files: List[bytearray]
    :param on_render_file: A file that will render the current state of the input form.
    :type on_render_file: bytearray
    :param on_submit_file: A file that will submit the current state of the input form.
    :type on_submit_file: bytearray
    :param other_input_form_files:
    :type other_input_form_files: List[bytearray]
    :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
    :type metadata_model_file: bytearray
    :param links:
    :type links: Links
    :param version_comment:
    :type version_comment: str
    :param categories:
    :type categories: List[Optional[str]]
    :param html_documentation:
    :type html_documentation: str
    :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
    :type proprietary: bool
    :param report_configs:
    :type report_configs: PipelineReportConfig
    :param resources:
    :type resources: PipelineResources
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_json_pipeline_serialize(
        project_id=project_id,
        code=code,
        description=description,
        workflow_cwl_file=workflow_cwl_file,
        input_form_file=input_form_file,
        analysis_storage_id=analysis_storage_id,
        tool_cwl_files=tool_cwl_files,
        on_render_file=on_render_file,
        on_submit_file=on_submit_file,
        other_input_form_files=other_input_form_files,
        metadata_model_file=metadata_model_file,
        links=links,
        version_comment=version_comment,
        categories=categories,
        html_documentation=html_documentation,
        proprietary=proprietary,
        report_configs=report_configs,
        resources=resources,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;ProjectPipelineV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Create a JSON based CWL pipeline within a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param code: The code of the CWL pipeline (required)
:type code: str
:param description: The description of the CWL pipeline (required)
:type description: str
:param workflow_cwl_file: The CWL workflow file. (required)
:type workflow_cwl_file: bytearray
:param input_form_file: The JSON based input form. (required)
:type input_form_file: bytearray
:param analysis_storage_id: The id of the storage to use for the pipeline. (required)
:type analysis_storage_id: str
:param tool_cwl_files:
:type tool_cwl_files: List[bytearray]
:param on_render_file: A file that will render the current state of the input form.
:type on_render_file: bytearray
:param on_submit_file: A file that will submit the current state of the input form.
:type on_submit_file: bytearray
:param other_input_form_files:
:type other_input_form_files: List[bytearray]
:param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
:type metadata_model_file: bytearray
:param links:
:type links: Links
:param version_comment:
:type version_comment: str
:param categories:
:type categories: List[Optional[str]]
:param html_documentation:
:type html_documentation: str
:param proprietary: A boolean which indicates if the code of this pipeline is proprietary
:type proprietary: bool
:param report_configs:
:type report_configs: PipelineReportConfig
:param resources:
:type resources: PipelineResources
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_json_pipeline_with_http_info"><code class="name flex">
<span>def <span class="ident">create_cwl_json_pipeline_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>code:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ codeÂ ofÂ theÂ CWLÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=255)])],<br>description:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ descriptionÂ ofÂ theÂ CWLÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=4000)])],<br>workflow_cwl_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ CWLÂ workflowÂ file.')],<br>input_form_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ JSONÂ basedÂ inputÂ form.')],<br>analysis_storage_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ storageÂ toÂ useÂ forÂ theÂ pipeline.')],<br>tool_cwl_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>on_render_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ fileÂ thatÂ willÂ renderÂ theÂ currentÂ stateÂ ofÂ theÂ inputÂ form.')]Â =Â None,<br>on_submit_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ fileÂ thatÂ willÂ submitÂ theÂ currentÂ stateÂ ofÂ theÂ inputÂ form.')]Â =Â None,<br>other_input_form_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>metadata_model_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ metadataÂ modelÂ jsonÂ file(contentsÂ canÂ beÂ retrievedÂ fromÂ theÂ controlplane).')]Â =Â None,<br>links:Â <a title="libica.openapi.v3.models.links.Links" href="../models/links.html#libica.openapi.v3.models.links.Links">Links</a>Â |Â NoneÂ =Â None,<br>version_comment:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>categories:Â Annotated[List[Annotated[str,Â Strict(strict=True)]Â |Â None],Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[MinLen(min_length=1),Â MaxLen(max_length=4000)])]Â |Â NoneÂ =Â None,<br>html_documentation:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>proprietary:Â Annotated[Annotated[bool,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ booleanÂ whichÂ indicatesÂ ifÂ theÂ codeÂ ofÂ thisÂ pipelineÂ isÂ proprietary')]Â =Â None,<br>report_configs:Â <a title="libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig" href="../models/pipeline_report_config.html#libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig">PipelineReportConfig</a>Â |Â NoneÂ =Â None,<br>resources:Â <a title="libica.openapi.v3.models.pipeline_resources.PipelineResources" href="../models/pipeline_resources.html#libica.openapi.v3.models.pipeline_resources.PipelineResources">PipelineResources</a>Â |Â NoneÂ =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[ProjectPipelineV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_json_pipeline_with_http_info(
    self,
    project_id: StrictStr,
    code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the CWL pipeline&#34;)],
    description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the CWL pipeline&#34;)],
    workflow_cwl_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The CWL workflow file.&#34;)],
    input_form_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The JSON based input form.&#34;)],
    analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
    tool_cwl_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    on_render_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will render the current state of the input form.&#34;)] = None,
    on_submit_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will submit the current state of the input form.&#34;)] = None,
    other_input_form_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
    links: Optional[Links] = None,
    version_comment: Optional[StrictStr] = None,
    categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
    html_documentation: Optional[StrictStr] = None,
    proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
    report_configs: Optional[PipelineReportConfig] = None,
    resources: Optional[PipelineResources] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[ProjectPipelineV4]:
    &#34;&#34;&#34;Create a JSON based CWL pipeline within a project.


    :param project_id: (required)
    :type project_id: str
    :param code: The code of the CWL pipeline (required)
    :type code: str
    :param description: The description of the CWL pipeline (required)
    :type description: str
    :param workflow_cwl_file: The CWL workflow file. (required)
    :type workflow_cwl_file: bytearray
    :param input_form_file: The JSON based input form. (required)
    :type input_form_file: bytearray
    :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
    :type analysis_storage_id: str
    :param tool_cwl_files:
    :type tool_cwl_files: List[bytearray]
    :param on_render_file: A file that will render the current state of the input form.
    :type on_render_file: bytearray
    :param on_submit_file: A file that will submit the current state of the input form.
    :type on_submit_file: bytearray
    :param other_input_form_files:
    :type other_input_form_files: List[bytearray]
    :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
    :type metadata_model_file: bytearray
    :param links:
    :type links: Links
    :param version_comment:
    :type version_comment: str
    :param categories:
    :type categories: List[Optional[str]]
    :param html_documentation:
    :type html_documentation: str
    :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
    :type proprietary: bool
    :param report_configs:
    :type report_configs: PipelineReportConfig
    :param resources:
    :type resources: PipelineResources
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_json_pipeline_serialize(
        project_id=project_id,
        code=code,
        description=description,
        workflow_cwl_file=workflow_cwl_file,
        input_form_file=input_form_file,
        analysis_storage_id=analysis_storage_id,
        tool_cwl_files=tool_cwl_files,
        on_render_file=on_render_file,
        on_submit_file=on_submit_file,
        other_input_form_files=other_input_form_files,
        metadata_model_file=metadata_model_file,
        links=links,
        version_comment=version_comment,
        categories=categories,
        html_documentation=html_documentation,
        proprietary=proprietary,
        report_configs=report_configs,
        resources=resources,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;ProjectPipelineV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Create a JSON based CWL pipeline within a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param code: The code of the CWL pipeline (required)
:type code: str
:param description: The description of the CWL pipeline (required)
:type description: str
:param workflow_cwl_file: The CWL workflow file. (required)
:type workflow_cwl_file: bytearray
:param input_form_file: The JSON based input form. (required)
:type input_form_file: bytearray
:param analysis_storage_id: The id of the storage to use for the pipeline. (required)
:type analysis_storage_id: str
:param tool_cwl_files:
:type tool_cwl_files: List[bytearray]
:param on_render_file: A file that will render the current state of the input form.
:type on_render_file: bytearray
:param on_submit_file: A file that will submit the current state of the input form.
:type on_submit_file: bytearray
:param other_input_form_files:
:type other_input_form_files: List[bytearray]
:param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
:type metadata_model_file: bytearray
:param links:
:type links: Links
:param version_comment:
:type version_comment: str
:param categories:
:type categories: List[Optional[str]]
:param html_documentation:
:type html_documentation: str
:param proprietary: A boolean which indicates if the code of this pipeline is proprietary
:type proprietary: bool
:param report_configs:
:type report_configs: PipelineReportConfig
:param resources:
:type resources: PipelineResources
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_json_pipeline_without_preload_content"><code class="name flex">
<span>def <span class="ident">create_cwl_json_pipeline_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>code:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ codeÂ ofÂ theÂ CWLÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=255)])],<br>description:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ descriptionÂ ofÂ theÂ CWLÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=4000)])],<br>workflow_cwl_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ CWLÂ workflowÂ file.')],<br>input_form_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ JSONÂ basedÂ inputÂ form.')],<br>analysis_storage_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ storageÂ toÂ useÂ forÂ theÂ pipeline.')],<br>tool_cwl_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>on_render_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ fileÂ thatÂ willÂ renderÂ theÂ currentÂ stateÂ ofÂ theÂ inputÂ form.')]Â =Â None,<br>on_submit_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ fileÂ thatÂ willÂ submitÂ theÂ currentÂ stateÂ ofÂ theÂ inputÂ form.')]Â =Â None,<br>other_input_form_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>metadata_model_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ metadataÂ modelÂ jsonÂ file(contentsÂ canÂ beÂ retrievedÂ fromÂ theÂ controlplane).')]Â =Â None,<br>links:Â <a title="libica.openapi.v3.models.links.Links" href="../models/links.html#libica.openapi.v3.models.links.Links">Links</a>Â |Â NoneÂ =Â None,<br>version_comment:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>categories:Â Annotated[List[Annotated[str,Â Strict(strict=True)]Â |Â None],Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[MinLen(min_length=1),Â MaxLen(max_length=4000)])]Â |Â NoneÂ =Â None,<br>html_documentation:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>proprietary:Â Annotated[Annotated[bool,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ booleanÂ whichÂ indicatesÂ ifÂ theÂ codeÂ ofÂ thisÂ pipelineÂ isÂ proprietary')]Â =Â None,<br>report_configs:Â <a title="libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig" href="../models/pipeline_report_config.html#libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig">PipelineReportConfig</a>Â |Â NoneÂ =Â None,<br>resources:Â <a title="libica.openapi.v3.models.pipeline_resources.PipelineResources" href="../models/pipeline_resources.html#libica.openapi.v3.models.pipeline_resources.PipelineResources">PipelineResources</a>Â |Â NoneÂ =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_json_pipeline_without_preload_content(
    self,
    project_id: StrictStr,
    code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the CWL pipeline&#34;)],
    description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the CWL pipeline&#34;)],
    workflow_cwl_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The CWL workflow file.&#34;)],
    input_form_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The JSON based input form.&#34;)],
    analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
    tool_cwl_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    on_render_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will render the current state of the input form.&#34;)] = None,
    on_submit_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will submit the current state of the input form.&#34;)] = None,
    other_input_form_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
    links: Optional[Links] = None,
    version_comment: Optional[StrictStr] = None,
    categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
    html_documentation: Optional[StrictStr] = None,
    proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
    report_configs: Optional[PipelineReportConfig] = None,
    resources: Optional[PipelineResources] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Create a JSON based CWL pipeline within a project.


    :param project_id: (required)
    :type project_id: str
    :param code: The code of the CWL pipeline (required)
    :type code: str
    :param description: The description of the CWL pipeline (required)
    :type description: str
    :param workflow_cwl_file: The CWL workflow file. (required)
    :type workflow_cwl_file: bytearray
    :param input_form_file: The JSON based input form. (required)
    :type input_form_file: bytearray
    :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
    :type analysis_storage_id: str
    :param tool_cwl_files:
    :type tool_cwl_files: List[bytearray]
    :param on_render_file: A file that will render the current state of the input form.
    :type on_render_file: bytearray
    :param on_submit_file: A file that will submit the current state of the input form.
    :type on_submit_file: bytearray
    :param other_input_form_files:
    :type other_input_form_files: List[bytearray]
    :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
    :type metadata_model_file: bytearray
    :param links:
    :type links: Links
    :param version_comment:
    :type version_comment: str
    :param categories:
    :type categories: List[Optional[str]]
    :param html_documentation:
    :type html_documentation: str
    :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
    :type proprietary: bool
    :param report_configs:
    :type report_configs: PipelineReportConfig
    :param resources:
    :type resources: PipelineResources
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_json_pipeline_serialize(
        project_id=project_id,
        code=code,
        description=description,
        workflow_cwl_file=workflow_cwl_file,
        input_form_file=input_form_file,
        analysis_storage_id=analysis_storage_id,
        tool_cwl_files=tool_cwl_files,
        on_render_file=on_render_file,
        on_submit_file=on_submit_file,
        other_input_form_files=other_input_form_files,
        metadata_model_file=metadata_model_file,
        links=links,
        version_comment=version_comment,
        categories=categories,
        html_documentation=html_documentation,
        proprietary=proprietary,
        report_configs=report_configs,
        resources=resources,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;ProjectPipelineV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Create a JSON based CWL pipeline within a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param code: The code of the CWL pipeline (required)
:type code: str
:param description: The description of the CWL pipeline (required)
:type description: str
:param workflow_cwl_file: The CWL workflow file. (required)
:type workflow_cwl_file: bytearray
:param input_form_file: The JSON based input form. (required)
:type input_form_file: bytearray
:param analysis_storage_id: The id of the storage to use for the pipeline. (required)
:type analysis_storage_id: str
:param tool_cwl_files:
:type tool_cwl_files: List[bytearray]
:param on_render_file: A file that will render the current state of the input form.
:type on_render_file: bytearray
:param on_submit_file: A file that will submit the current state of the input form.
:type on_submit_file: bytearray
:param other_input_form_files:
:type other_input_form_files: List[bytearray]
:param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
:type metadata_model_file: bytearray
:param links:
:type links: Links
:param version_comment:
:type version_comment: str
:param categories:
:type categories: List[Optional[str]]
:param html_documentation:
:type html_documentation: str
:param proprietary: A boolean which indicates if the code of this pipeline is proprietary
:type proprietary: bool
:param report_configs:
:type report_configs: PipelineReportConfig
:param resources:
:type resources: PipelineResources
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_pipeline"><code class="name flex">
<span>def <span class="ident">create_cwl_pipeline</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>code:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ codeÂ ofÂ theÂ CWLÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=255)])],<br>description:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ descriptionÂ ofÂ theÂ CWLÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=4000)])],<br>workflow_cwl_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ CWLÂ workflowÂ file.')],<br>parameters_xml_file:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],<br>analysis_storage_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ storageÂ toÂ useÂ forÂ theÂ pipeline.')],<br>tool_cwl_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>metadata_model_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ metadataÂ modelÂ jsonÂ file(contentsÂ canÂ beÂ retrievedÂ fromÂ theÂ controlplane).')]Â =Â None,<br>links:Â <a title="libica.openapi.v3.models.links.Links" href="../models/links.html#libica.openapi.v3.models.links.Links">Links</a>Â |Â NoneÂ =Â None,<br>version_comment:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>categories:Â Annotated[List[Annotated[str,Â Strict(strict=True)]Â |Â None],Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[MinLen(min_length=1),Â MaxLen(max_length=4000)])]Â |Â NoneÂ =Â None,<br>html_documentation:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>proprietary:Â Annotated[Annotated[bool,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ booleanÂ whichÂ indicatesÂ ifÂ theÂ codeÂ ofÂ thisÂ pipelineÂ isÂ proprietary')]Â =Â None,<br>report_configs:Â <a title="libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig" href="../models/pipeline_report_config.html#libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig">PipelineReportConfig</a>Â |Â NoneÂ =Â None,<br>resources:Â <a title="libica.openapi.v3.models.pipeline_resources.PipelineResources" href="../models/pipeline_resources.html#libica.openapi.v3.models.pipeline_resources.PipelineResources">PipelineResources</a>Â |Â NoneÂ =Â None) â€‘>Â <a title="libica.openapi.v3.models.project_pipeline.ProjectPipeline" href="../models/project_pipeline.html#libica.openapi.v3.models.project_pipeline.ProjectPipeline">ProjectPipeline</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_pipeline(
    self,
    project_id: StrictStr,
    code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the CWL pipeline&#34;)],
    description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the CWL pipeline&#34;)],
    workflow_cwl_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The CWL workflow file.&#34;)],
    parameters_xml_file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
    tool_cwl_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
    links: Optional[Links] = None,
    version_comment: Optional[StrictStr] = None,
    categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
    html_documentation: Optional[StrictStr] = None,
    proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
    report_configs: Optional[PipelineReportConfig] = None,
    resources: Optional[PipelineResources] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ProjectPipeline:
    &#34;&#34;&#34;Create a CWL pipeline within a project.


    :param project_id: (required)
    :type project_id: str
    :param code: The code of the CWL pipeline (required)
    :type code: str
    :param description: The description of the CWL pipeline (required)
    :type description: str
    :param workflow_cwl_file: The CWL workflow file. (required)
    :type workflow_cwl_file: bytearray
    :param parameters_xml_file: (required)
    :type parameters_xml_file: bytearray
    :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
    :type analysis_storage_id: str
    :param tool_cwl_files:
    :type tool_cwl_files: List[bytearray]
    :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
    :type metadata_model_file: bytearray
    :param links:
    :type links: Links
    :param version_comment:
    :type version_comment: str
    :param categories:
    :type categories: List[Optional[str]]
    :param html_documentation:
    :type html_documentation: str
    :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
    :type proprietary: bool
    :param report_configs:
    :type report_configs: PipelineReportConfig
    :param resources:
    :type resources: PipelineResources
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_pipeline_serialize(
        project_id=project_id,
        code=code,
        description=description,
        workflow_cwl_file=workflow_cwl_file,
        parameters_xml_file=parameters_xml_file,
        analysis_storage_id=analysis_storage_id,
        tool_cwl_files=tool_cwl_files,
        metadata_model_file=metadata_model_file,
        links=links,
        version_comment=version_comment,
        categories=categories,
        html_documentation=html_documentation,
        proprietary=proprietary,
        report_configs=report_configs,
        resources=resources,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;ProjectPipeline&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Create a CWL pipeline within a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param code: The code of the CWL pipeline (required)
:type code: str
:param description: The description of the CWL pipeline (required)
:type description: str
:param workflow_cwl_file: The CWL workflow file. (required)
:type workflow_cwl_file: bytearray
:param parameters_xml_file: (required)
:type parameters_xml_file: bytearray
:param analysis_storage_id: The id of the storage to use for the pipeline. (required)
:type analysis_storage_id: str
:param tool_cwl_files:
:type tool_cwl_files: List[bytearray]
:param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
:type metadata_model_file: bytearray
:param links:
:type links: Links
:param version_comment:
:type version_comment: str
:param categories:
:type categories: List[Optional[str]]
:param html_documentation:
:type html_documentation: str
:param proprietary: A boolean which indicates if the code of this pipeline is proprietary
:type proprietary: bool
:param report_configs:
:type report_configs: PipelineReportConfig
:param resources:
:type resources: PipelineResources
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_pipeline_with_http_info"><code class="name flex">
<span>def <span class="ident">create_cwl_pipeline_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>code:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ codeÂ ofÂ theÂ CWLÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=255)])],<br>description:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ descriptionÂ ofÂ theÂ CWLÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=4000)])],<br>workflow_cwl_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ CWLÂ workflowÂ file.')],<br>parameters_xml_file:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],<br>analysis_storage_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ storageÂ toÂ useÂ forÂ theÂ pipeline.')],<br>tool_cwl_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>metadata_model_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ metadataÂ modelÂ jsonÂ file(contentsÂ canÂ beÂ retrievedÂ fromÂ theÂ controlplane).')]Â =Â None,<br>links:Â <a title="libica.openapi.v3.models.links.Links" href="../models/links.html#libica.openapi.v3.models.links.Links">Links</a>Â |Â NoneÂ =Â None,<br>version_comment:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>categories:Â Annotated[List[Annotated[str,Â Strict(strict=True)]Â |Â None],Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[MinLen(min_length=1),Â MaxLen(max_length=4000)])]Â |Â NoneÂ =Â None,<br>html_documentation:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>proprietary:Â Annotated[Annotated[bool,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ booleanÂ whichÂ indicatesÂ ifÂ theÂ codeÂ ofÂ thisÂ pipelineÂ isÂ proprietary')]Â =Â None,<br>report_configs:Â <a title="libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig" href="../models/pipeline_report_config.html#libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig">PipelineReportConfig</a>Â |Â NoneÂ =Â None,<br>resources:Â <a title="libica.openapi.v3.models.pipeline_resources.PipelineResources" href="../models/pipeline_resources.html#libica.openapi.v3.models.pipeline_resources.PipelineResources">PipelineResources</a>Â |Â NoneÂ =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[ProjectPipeline]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_pipeline_with_http_info(
    self,
    project_id: StrictStr,
    code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the CWL pipeline&#34;)],
    description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the CWL pipeline&#34;)],
    workflow_cwl_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The CWL workflow file.&#34;)],
    parameters_xml_file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
    tool_cwl_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
    links: Optional[Links] = None,
    version_comment: Optional[StrictStr] = None,
    categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
    html_documentation: Optional[StrictStr] = None,
    proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
    report_configs: Optional[PipelineReportConfig] = None,
    resources: Optional[PipelineResources] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[ProjectPipeline]:
    &#34;&#34;&#34;Create a CWL pipeline within a project.


    :param project_id: (required)
    :type project_id: str
    :param code: The code of the CWL pipeline (required)
    :type code: str
    :param description: The description of the CWL pipeline (required)
    :type description: str
    :param workflow_cwl_file: The CWL workflow file. (required)
    :type workflow_cwl_file: bytearray
    :param parameters_xml_file: (required)
    :type parameters_xml_file: bytearray
    :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
    :type analysis_storage_id: str
    :param tool_cwl_files:
    :type tool_cwl_files: List[bytearray]
    :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
    :type metadata_model_file: bytearray
    :param links:
    :type links: Links
    :param version_comment:
    :type version_comment: str
    :param categories:
    :type categories: List[Optional[str]]
    :param html_documentation:
    :type html_documentation: str
    :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
    :type proprietary: bool
    :param report_configs:
    :type report_configs: PipelineReportConfig
    :param resources:
    :type resources: PipelineResources
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_pipeline_serialize(
        project_id=project_id,
        code=code,
        description=description,
        workflow_cwl_file=workflow_cwl_file,
        parameters_xml_file=parameters_xml_file,
        analysis_storage_id=analysis_storage_id,
        tool_cwl_files=tool_cwl_files,
        metadata_model_file=metadata_model_file,
        links=links,
        version_comment=version_comment,
        categories=categories,
        html_documentation=html_documentation,
        proprietary=proprietary,
        report_configs=report_configs,
        resources=resources,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;ProjectPipeline&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Create a CWL pipeline within a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param code: The code of the CWL pipeline (required)
:type code: str
:param description: The description of the CWL pipeline (required)
:type description: str
:param workflow_cwl_file: The CWL workflow file. (required)
:type workflow_cwl_file: bytearray
:param parameters_xml_file: (required)
:type parameters_xml_file: bytearray
:param analysis_storage_id: The id of the storage to use for the pipeline. (required)
:type analysis_storage_id: str
:param tool_cwl_files:
:type tool_cwl_files: List[bytearray]
:param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
:type metadata_model_file: bytearray
:param links:
:type links: Links
:param version_comment:
:type version_comment: str
:param categories:
:type categories: List[Optional[str]]
:param html_documentation:
:type html_documentation: str
:param proprietary: A boolean which indicates if the code of this pipeline is proprietary
:type proprietary: bool
:param report_configs:
:type report_configs: PipelineReportConfig
:param resources:
:type resources: PipelineResources
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_pipeline_without_preload_content"><code class="name flex">
<span>def <span class="ident">create_cwl_pipeline_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>code:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ codeÂ ofÂ theÂ CWLÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=255)])],<br>description:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ descriptionÂ ofÂ theÂ CWLÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=4000)])],<br>workflow_cwl_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ CWLÂ workflowÂ file.')],<br>parameters_xml_file:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],<br>analysis_storage_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ storageÂ toÂ useÂ forÂ theÂ pipeline.')],<br>tool_cwl_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>metadata_model_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ metadataÂ modelÂ jsonÂ file(contentsÂ canÂ beÂ retrievedÂ fromÂ theÂ controlplane).')]Â =Â None,<br>links:Â <a title="libica.openapi.v3.models.links.Links" href="../models/links.html#libica.openapi.v3.models.links.Links">Links</a>Â |Â NoneÂ =Â None,<br>version_comment:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>categories:Â Annotated[List[Annotated[str,Â Strict(strict=True)]Â |Â None],Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[MinLen(min_length=1),Â MaxLen(max_length=4000)])]Â |Â NoneÂ =Â None,<br>html_documentation:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>proprietary:Â Annotated[Annotated[bool,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ booleanÂ whichÂ indicatesÂ ifÂ theÂ codeÂ ofÂ thisÂ pipelineÂ isÂ proprietary')]Â =Â None,<br>report_configs:Â <a title="libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig" href="../models/pipeline_report_config.html#libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig">PipelineReportConfig</a>Â |Â NoneÂ =Â None,<br>resources:Â <a title="libica.openapi.v3.models.pipeline_resources.PipelineResources" href="../models/pipeline_resources.html#libica.openapi.v3.models.pipeline_resources.PipelineResources">PipelineResources</a>Â |Â NoneÂ =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_cwl_pipeline_without_preload_content(
    self,
    project_id: StrictStr,
    code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the CWL pipeline&#34;)],
    description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the CWL pipeline&#34;)],
    workflow_cwl_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The CWL workflow file.&#34;)],
    parameters_xml_file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
    tool_cwl_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
    links: Optional[Links] = None,
    version_comment: Optional[StrictStr] = None,
    categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
    html_documentation: Optional[StrictStr] = None,
    proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
    report_configs: Optional[PipelineReportConfig] = None,
    resources: Optional[PipelineResources] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Create a CWL pipeline within a project.


    :param project_id: (required)
    :type project_id: str
    :param code: The code of the CWL pipeline (required)
    :type code: str
    :param description: The description of the CWL pipeline (required)
    :type description: str
    :param workflow_cwl_file: The CWL workflow file. (required)
    :type workflow_cwl_file: bytearray
    :param parameters_xml_file: (required)
    :type parameters_xml_file: bytearray
    :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
    :type analysis_storage_id: str
    :param tool_cwl_files:
    :type tool_cwl_files: List[bytearray]
    :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
    :type metadata_model_file: bytearray
    :param links:
    :type links: Links
    :param version_comment:
    :type version_comment: str
    :param categories:
    :type categories: List[Optional[str]]
    :param html_documentation:
    :type html_documentation: str
    :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
    :type proprietary: bool
    :param report_configs:
    :type report_configs: PipelineReportConfig
    :param resources:
    :type resources: PipelineResources
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_cwl_pipeline_serialize(
        project_id=project_id,
        code=code,
        description=description,
        workflow_cwl_file=workflow_cwl_file,
        parameters_xml_file=parameters_xml_file,
        analysis_storage_id=analysis_storage_id,
        tool_cwl_files=tool_cwl_files,
        metadata_model_file=metadata_model_file,
        links=links,
        version_comment=version_comment,
        categories=categories,
        html_documentation=html_documentation,
        proprietary=proprietary,
        report_configs=report_configs,
        resources=resources,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;ProjectPipeline&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Create a CWL pipeline within a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param code: The code of the CWL pipeline (required)
:type code: str
:param description: The description of the CWL pipeline (required)
:type description: str
:param workflow_cwl_file: The CWL workflow file. (required)
:type workflow_cwl_file: bytearray
:param parameters_xml_file: (required)
:type parameters_xml_file: bytearray
:param analysis_storage_id: The id of the storage to use for the pipeline. (required)
:type analysis_storage_id: str
:param tool_cwl_files:
:type tool_cwl_files: List[bytearray]
:param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
:type metadata_model_file: bytearray
:param links:
:type links: Links
:param version_comment:
:type version_comment: str
:param categories:
:type categories: List[Optional[str]]
:param html_documentation:
:type html_documentation: str
:param proprietary: A boolean which indicates if the code of this pipeline is proprietary
:type proprietary: bool
:param report_configs:
:type report_configs: PipelineReportConfig
:param resources:
:type resources: PipelineResources
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_json_pipeline"><code class="name flex">
<span>def <span class="ident">create_nextflow_json_pipeline</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>code:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ codeÂ ofÂ theÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=255)])],<br>description:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ descriptionÂ ofÂ theÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=4000)])],<br>main_nextflow_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ mainÂ NextflowÂ file.')],<br>input_form_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ JSONÂ basedÂ inputÂ form.')],<br>analysis_storage_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ storageÂ toÂ useÂ forÂ theÂ pipeline.')],<br>pipeline_language_version_id:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ NextflowÂ versionÂ toÂ useÂ forÂ theÂ pipeline.')]Â =Â None,<br>nextflow_config_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ NextflowÂ configÂ file.')]Â =Â None,<br>other_nextflow_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>on_render_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ fileÂ thatÂ willÂ renderÂ theÂ currentÂ stateÂ ofÂ theÂ inputÂ form.')]Â =Â None,<br>on_submit_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ fileÂ thatÂ willÂ submitÂ theÂ currentÂ stateÂ ofÂ theÂ inputÂ form.')]Â =Â None,<br>other_input_form_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>metadata_model_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ metadataÂ modelÂ jsonÂ file(contentsÂ canÂ beÂ retrievedÂ fromÂ theÂ controlplane).')]Â =Â None,<br>links:Â <a title="libica.openapi.v3.models.links.Links" href="../models/links.html#libica.openapi.v3.models.links.Links">Links</a>Â |Â NoneÂ =Â None,<br>version_comment:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>categories:Â Annotated[List[Annotated[str,Â Strict(strict=True)]Â |Â None],Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[MinLen(min_length=1),Â MaxLen(max_length=4000)])]Â |Â NoneÂ =Â None,<br>html_documentation:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>proprietary:Â Annotated[Annotated[bool,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ booleanÂ whichÂ indicatesÂ ifÂ theÂ codeÂ ofÂ thisÂ pipelineÂ isÂ proprietary')]Â =Â None,<br>report_configs:Â <a title="libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig" href="../models/pipeline_report_config.html#libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig">PipelineReportConfig</a>Â |Â NoneÂ =Â None,<br>resources:Â <a title="libica.openapi.v3.models.pipeline_resources.PipelineResources" href="../models/pipeline_resources.html#libica.openapi.v3.models.pipeline_resources.PipelineResources">PipelineResources</a>Â |Â NoneÂ =Â None) â€‘>Â <a title="libica.openapi.v3.models.pipeline_v4.PipelineV4" href="../models/pipeline_v4.html#libica.openapi.v3.models.pipeline_v4.PipelineV4">PipelineV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_json_pipeline(
    self,
    project_id: StrictStr,
    code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the pipeline&#34;)],
    description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the pipeline&#34;)],
    main_nextflow_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The main Nextflow file.&#34;)],
    input_form_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The JSON based input form.&#34;)],
    analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
    pipeline_language_version_id: Annotated[Optional[StrictStr], Field(description=&#34;The id of the Nextflow version to use for the pipeline.&#34;)] = None,
    nextflow_config_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The Nextflow config file.&#34;)] = None,
    other_nextflow_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    on_render_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will render the current state of the input form.&#34;)] = None,
    on_submit_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will submit the current state of the input form.&#34;)] = None,
    other_input_form_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
    links: Optional[Links] = None,
    version_comment: Optional[StrictStr] = None,
    categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
    html_documentation: Optional[StrictStr] = None,
    proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
    report_configs: Optional[PipelineReportConfig] = None,
    resources: Optional[PipelineResources] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; PipelineV4:
    &#34;&#34;&#34;Create a JSON based Nextflow pipeline within a project.


    :param project_id: (required)
    :type project_id: str
    :param code: The code of the pipeline (required)
    :type code: str
    :param description: The description of the pipeline (required)
    :type description: str
    :param main_nextflow_file: The main Nextflow file. (required)
    :type main_nextflow_file: bytearray
    :param input_form_file: The JSON based input form. (required)
    :type input_form_file: bytearray
    :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
    :type analysis_storage_id: str
    :param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
    :type pipeline_language_version_id: str
    :param nextflow_config_file: The Nextflow config file.
    :type nextflow_config_file: bytearray
    :param other_nextflow_files:
    :type other_nextflow_files: List[bytearray]
    :param on_render_file: A file that will render the current state of the input form.
    :type on_render_file: bytearray
    :param on_submit_file: A file that will submit the current state of the input form.
    :type on_submit_file: bytearray
    :param other_input_form_files:
    :type other_input_form_files: List[bytearray]
    :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
    :type metadata_model_file: bytearray
    :param links:
    :type links: Links
    :param version_comment:
    :type version_comment: str
    :param categories:
    :type categories: List[Optional[str]]
    :param html_documentation:
    :type html_documentation: str
    :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
    :type proprietary: bool
    :param report_configs:
    :type report_configs: PipelineReportConfig
    :param resources:
    :type resources: PipelineResources
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_json_pipeline_serialize(
        project_id=project_id,
        code=code,
        description=description,
        main_nextflow_file=main_nextflow_file,
        input_form_file=input_form_file,
        analysis_storage_id=analysis_storage_id,
        pipeline_language_version_id=pipeline_language_version_id,
        nextflow_config_file=nextflow_config_file,
        other_nextflow_files=other_nextflow_files,
        on_render_file=on_render_file,
        on_submit_file=on_submit_file,
        other_input_form_files=other_input_form_files,
        metadata_model_file=metadata_model_file,
        links=links,
        version_comment=version_comment,
        categories=categories,
        html_documentation=html_documentation,
        proprietary=proprietary,
        report_configs=report_configs,
        resources=resources,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;PipelineV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Create a JSON based Nextflow pipeline within a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param code: The code of the pipeline (required)
:type code: str
:param description: The description of the pipeline (required)
:type description: str
:param main_nextflow_file: The main Nextflow file. (required)
:type main_nextflow_file: bytearray
:param input_form_file: The JSON based input form. (required)
:type input_form_file: bytearray
:param analysis_storage_id: The id of the storage to use for the pipeline. (required)
:type analysis_storage_id: str
:param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
:type pipeline_language_version_id: str
:param nextflow_config_file: The Nextflow config file.
:type nextflow_config_file: bytearray
:param other_nextflow_files:
:type other_nextflow_files: List[bytearray]
:param on_render_file: A file that will render the current state of the input form.
:type on_render_file: bytearray
:param on_submit_file: A file that will submit the current state of the input form.
:type on_submit_file: bytearray
:param other_input_form_files:
:type other_input_form_files: List[bytearray]
:param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
:type metadata_model_file: bytearray
:param links:
:type links: Links
:param version_comment:
:type version_comment: str
:param categories:
:type categories: List[Optional[str]]
:param html_documentation:
:type html_documentation: str
:param proprietary: A boolean which indicates if the code of this pipeline is proprietary
:type proprietary: bool
:param report_configs:
:type report_configs: PipelineReportConfig
:param resources:
:type resources: PipelineResources
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_json_pipeline_with_http_info"><code class="name flex">
<span>def <span class="ident">create_nextflow_json_pipeline_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>code:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ codeÂ ofÂ theÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=255)])],<br>description:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ descriptionÂ ofÂ theÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=4000)])],<br>main_nextflow_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ mainÂ NextflowÂ file.')],<br>input_form_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ JSONÂ basedÂ inputÂ form.')],<br>analysis_storage_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ storageÂ toÂ useÂ forÂ theÂ pipeline.')],<br>pipeline_language_version_id:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ NextflowÂ versionÂ toÂ useÂ forÂ theÂ pipeline.')]Â =Â None,<br>nextflow_config_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ NextflowÂ configÂ file.')]Â =Â None,<br>other_nextflow_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>on_render_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ fileÂ thatÂ willÂ renderÂ theÂ currentÂ stateÂ ofÂ theÂ inputÂ form.')]Â =Â None,<br>on_submit_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ fileÂ thatÂ willÂ submitÂ theÂ currentÂ stateÂ ofÂ theÂ inputÂ form.')]Â =Â None,<br>other_input_form_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>metadata_model_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ metadataÂ modelÂ jsonÂ file(contentsÂ canÂ beÂ retrievedÂ fromÂ theÂ controlplane).')]Â =Â None,<br>links:Â <a title="libica.openapi.v3.models.links.Links" href="../models/links.html#libica.openapi.v3.models.links.Links">Links</a>Â |Â NoneÂ =Â None,<br>version_comment:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>categories:Â Annotated[List[Annotated[str,Â Strict(strict=True)]Â |Â None],Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[MinLen(min_length=1),Â MaxLen(max_length=4000)])]Â |Â NoneÂ =Â None,<br>html_documentation:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>proprietary:Â Annotated[Annotated[bool,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ booleanÂ whichÂ indicatesÂ ifÂ theÂ codeÂ ofÂ thisÂ pipelineÂ isÂ proprietary')]Â =Â None,<br>report_configs:Â <a title="libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig" href="../models/pipeline_report_config.html#libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig">PipelineReportConfig</a>Â |Â NoneÂ =Â None,<br>resources:Â <a title="libica.openapi.v3.models.pipeline_resources.PipelineResources" href="../models/pipeline_resources.html#libica.openapi.v3.models.pipeline_resources.PipelineResources">PipelineResources</a>Â |Â NoneÂ =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[PipelineV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_json_pipeline_with_http_info(
    self,
    project_id: StrictStr,
    code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the pipeline&#34;)],
    description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the pipeline&#34;)],
    main_nextflow_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The main Nextflow file.&#34;)],
    input_form_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The JSON based input form.&#34;)],
    analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
    pipeline_language_version_id: Annotated[Optional[StrictStr], Field(description=&#34;The id of the Nextflow version to use for the pipeline.&#34;)] = None,
    nextflow_config_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The Nextflow config file.&#34;)] = None,
    other_nextflow_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    on_render_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will render the current state of the input form.&#34;)] = None,
    on_submit_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will submit the current state of the input form.&#34;)] = None,
    other_input_form_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
    links: Optional[Links] = None,
    version_comment: Optional[StrictStr] = None,
    categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
    html_documentation: Optional[StrictStr] = None,
    proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
    report_configs: Optional[PipelineReportConfig] = None,
    resources: Optional[PipelineResources] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[PipelineV4]:
    &#34;&#34;&#34;Create a JSON based Nextflow pipeline within a project.


    :param project_id: (required)
    :type project_id: str
    :param code: The code of the pipeline (required)
    :type code: str
    :param description: The description of the pipeline (required)
    :type description: str
    :param main_nextflow_file: The main Nextflow file. (required)
    :type main_nextflow_file: bytearray
    :param input_form_file: The JSON based input form. (required)
    :type input_form_file: bytearray
    :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
    :type analysis_storage_id: str
    :param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
    :type pipeline_language_version_id: str
    :param nextflow_config_file: The Nextflow config file.
    :type nextflow_config_file: bytearray
    :param other_nextflow_files:
    :type other_nextflow_files: List[bytearray]
    :param on_render_file: A file that will render the current state of the input form.
    :type on_render_file: bytearray
    :param on_submit_file: A file that will submit the current state of the input form.
    :type on_submit_file: bytearray
    :param other_input_form_files:
    :type other_input_form_files: List[bytearray]
    :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
    :type metadata_model_file: bytearray
    :param links:
    :type links: Links
    :param version_comment:
    :type version_comment: str
    :param categories:
    :type categories: List[Optional[str]]
    :param html_documentation:
    :type html_documentation: str
    :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
    :type proprietary: bool
    :param report_configs:
    :type report_configs: PipelineReportConfig
    :param resources:
    :type resources: PipelineResources
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_json_pipeline_serialize(
        project_id=project_id,
        code=code,
        description=description,
        main_nextflow_file=main_nextflow_file,
        input_form_file=input_form_file,
        analysis_storage_id=analysis_storage_id,
        pipeline_language_version_id=pipeline_language_version_id,
        nextflow_config_file=nextflow_config_file,
        other_nextflow_files=other_nextflow_files,
        on_render_file=on_render_file,
        on_submit_file=on_submit_file,
        other_input_form_files=other_input_form_files,
        metadata_model_file=metadata_model_file,
        links=links,
        version_comment=version_comment,
        categories=categories,
        html_documentation=html_documentation,
        proprietary=proprietary,
        report_configs=report_configs,
        resources=resources,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;PipelineV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Create a JSON based Nextflow pipeline within a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param code: The code of the pipeline (required)
:type code: str
:param description: The description of the pipeline (required)
:type description: str
:param main_nextflow_file: The main Nextflow file. (required)
:type main_nextflow_file: bytearray
:param input_form_file: The JSON based input form. (required)
:type input_form_file: bytearray
:param analysis_storage_id: The id of the storage to use for the pipeline. (required)
:type analysis_storage_id: str
:param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
:type pipeline_language_version_id: str
:param nextflow_config_file: The Nextflow config file.
:type nextflow_config_file: bytearray
:param other_nextflow_files:
:type other_nextflow_files: List[bytearray]
:param on_render_file: A file that will render the current state of the input form.
:type on_render_file: bytearray
:param on_submit_file: A file that will submit the current state of the input form.
:type on_submit_file: bytearray
:param other_input_form_files:
:type other_input_form_files: List[bytearray]
:param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
:type metadata_model_file: bytearray
:param links:
:type links: Links
:param version_comment:
:type version_comment: str
:param categories:
:type categories: List[Optional[str]]
:param html_documentation:
:type html_documentation: str
:param proprietary: A boolean which indicates if the code of this pipeline is proprietary
:type proprietary: bool
:param report_configs:
:type report_configs: PipelineReportConfig
:param resources:
:type resources: PipelineResources
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_json_pipeline_without_preload_content"><code class="name flex">
<span>def <span class="ident">create_nextflow_json_pipeline_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>code:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ codeÂ ofÂ theÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=255)])],<br>description:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ descriptionÂ ofÂ theÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=4000)])],<br>main_nextflow_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ mainÂ NextflowÂ file.')],<br>input_form_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ JSONÂ basedÂ inputÂ form.')],<br>analysis_storage_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ storageÂ toÂ useÂ forÂ theÂ pipeline.')],<br>pipeline_language_version_id:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ NextflowÂ versionÂ toÂ useÂ forÂ theÂ pipeline.')]Â =Â None,<br>nextflow_config_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ NextflowÂ configÂ file.')]Â =Â None,<br>other_nextflow_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>on_render_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ fileÂ thatÂ willÂ renderÂ theÂ currentÂ stateÂ ofÂ theÂ inputÂ form.')]Â =Â None,<br>on_submit_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ fileÂ thatÂ willÂ submitÂ theÂ currentÂ stateÂ ofÂ theÂ inputÂ form.')]Â =Â None,<br>other_input_form_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>metadata_model_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ metadataÂ modelÂ jsonÂ file(contentsÂ canÂ beÂ retrievedÂ fromÂ theÂ controlplane).')]Â =Â None,<br>links:Â <a title="libica.openapi.v3.models.links.Links" href="../models/links.html#libica.openapi.v3.models.links.Links">Links</a>Â |Â NoneÂ =Â None,<br>version_comment:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>categories:Â Annotated[List[Annotated[str,Â Strict(strict=True)]Â |Â None],Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[MinLen(min_length=1),Â MaxLen(max_length=4000)])]Â |Â NoneÂ =Â None,<br>html_documentation:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>proprietary:Â Annotated[Annotated[bool,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ booleanÂ whichÂ indicatesÂ ifÂ theÂ codeÂ ofÂ thisÂ pipelineÂ isÂ proprietary')]Â =Â None,<br>report_configs:Â <a title="libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig" href="../models/pipeline_report_config.html#libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig">PipelineReportConfig</a>Â |Â NoneÂ =Â None,<br>resources:Â <a title="libica.openapi.v3.models.pipeline_resources.PipelineResources" href="../models/pipeline_resources.html#libica.openapi.v3.models.pipeline_resources.PipelineResources">PipelineResources</a>Â |Â NoneÂ =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_json_pipeline_without_preload_content(
    self,
    project_id: StrictStr,
    code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the pipeline&#34;)],
    description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the pipeline&#34;)],
    main_nextflow_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The main Nextflow file.&#34;)],
    input_form_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The JSON based input form.&#34;)],
    analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
    pipeline_language_version_id: Annotated[Optional[StrictStr], Field(description=&#34;The id of the Nextflow version to use for the pipeline.&#34;)] = None,
    nextflow_config_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The Nextflow config file.&#34;)] = None,
    other_nextflow_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    on_render_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will render the current state of the input form.&#34;)] = None,
    on_submit_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;A file that will submit the current state of the input form.&#34;)] = None,
    other_input_form_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
    links: Optional[Links] = None,
    version_comment: Optional[StrictStr] = None,
    categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
    html_documentation: Optional[StrictStr] = None,
    proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
    report_configs: Optional[PipelineReportConfig] = None,
    resources: Optional[PipelineResources] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Create a JSON based Nextflow pipeline within a project.


    :param project_id: (required)
    :type project_id: str
    :param code: The code of the pipeline (required)
    :type code: str
    :param description: The description of the pipeline (required)
    :type description: str
    :param main_nextflow_file: The main Nextflow file. (required)
    :type main_nextflow_file: bytearray
    :param input_form_file: The JSON based input form. (required)
    :type input_form_file: bytearray
    :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
    :type analysis_storage_id: str
    :param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
    :type pipeline_language_version_id: str
    :param nextflow_config_file: The Nextflow config file.
    :type nextflow_config_file: bytearray
    :param other_nextflow_files:
    :type other_nextflow_files: List[bytearray]
    :param on_render_file: A file that will render the current state of the input form.
    :type on_render_file: bytearray
    :param on_submit_file: A file that will submit the current state of the input form.
    :type on_submit_file: bytearray
    :param other_input_form_files:
    :type other_input_form_files: List[bytearray]
    :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
    :type metadata_model_file: bytearray
    :param links:
    :type links: Links
    :param version_comment:
    :type version_comment: str
    :param categories:
    :type categories: List[Optional[str]]
    :param html_documentation:
    :type html_documentation: str
    :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
    :type proprietary: bool
    :param report_configs:
    :type report_configs: PipelineReportConfig
    :param resources:
    :type resources: PipelineResources
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_json_pipeline_serialize(
        project_id=project_id,
        code=code,
        description=description,
        main_nextflow_file=main_nextflow_file,
        input_form_file=input_form_file,
        analysis_storage_id=analysis_storage_id,
        pipeline_language_version_id=pipeline_language_version_id,
        nextflow_config_file=nextflow_config_file,
        other_nextflow_files=other_nextflow_files,
        on_render_file=on_render_file,
        on_submit_file=on_submit_file,
        other_input_form_files=other_input_form_files,
        metadata_model_file=metadata_model_file,
        links=links,
        version_comment=version_comment,
        categories=categories,
        html_documentation=html_documentation,
        proprietary=proprietary,
        report_configs=report_configs,
        resources=resources,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;PipelineV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Create a JSON based Nextflow pipeline within a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param code: The code of the pipeline (required)
:type code: str
:param description: The description of the pipeline (required)
:type description: str
:param main_nextflow_file: The main Nextflow file. (required)
:type main_nextflow_file: bytearray
:param input_form_file: The JSON based input form. (required)
:type input_form_file: bytearray
:param analysis_storage_id: The id of the storage to use for the pipeline. (required)
:type analysis_storage_id: str
:param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
:type pipeline_language_version_id: str
:param nextflow_config_file: The Nextflow config file.
:type nextflow_config_file: bytearray
:param other_nextflow_files:
:type other_nextflow_files: List[bytearray]
:param on_render_file: A file that will render the current state of the input form.
:type on_render_file: bytearray
:param on_submit_file: A file that will submit the current state of the input form.
:type on_submit_file: bytearray
:param other_input_form_files:
:type other_input_form_files: List[bytearray]
:param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
:type metadata_model_file: bytearray
:param links:
:type links: Links
:param version_comment:
:type version_comment: str
:param categories:
:type categories: List[Optional[str]]
:param html_documentation:
:type html_documentation: str
:param proprietary: A boolean which indicates if the code of this pipeline is proprietary
:type proprietary: bool
:param report_configs:
:type report_configs: PipelineReportConfig
:param resources:
:type resources: PipelineResources
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_pipeline"><code class="name flex">
<span>def <span class="ident">create_nextflow_pipeline</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>code:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ codeÂ ofÂ theÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=255)])],<br>description:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ descriptionÂ ofÂ theÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=4000)])],<br>main_nextflow_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ mainÂ NextflowÂ file.')],<br>parameters_xml_file:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],<br>analysis_storage_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ storageÂ toÂ useÂ forÂ theÂ pipeline.')],<br>pipeline_language_version_id:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ NextflowÂ versionÂ toÂ useÂ forÂ theÂ pipeline.')]Â =Â None,<br>nextflow_config_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ NextflowÂ configÂ file.')]Â =Â None,<br>other_nextflow_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>metadata_model_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ metadataÂ modelÂ jsonÂ file(contentsÂ canÂ beÂ retrievedÂ fromÂ theÂ controlplane).')]Â =Â None,<br>links:Â <a title="libica.openapi.v3.models.links.Links" href="../models/links.html#libica.openapi.v3.models.links.Links">Links</a>Â |Â NoneÂ =Â None,<br>version_comment:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>categories:Â Annotated[List[Annotated[str,Â Strict(strict=True)]Â |Â None],Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[MinLen(min_length=1),Â MaxLen(max_length=4000)])]Â |Â NoneÂ =Â None,<br>html_documentation:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>proprietary:Â Annotated[Annotated[bool,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ booleanÂ whichÂ indicatesÂ ifÂ theÂ codeÂ ofÂ thisÂ pipelineÂ isÂ proprietary')]Â =Â None,<br>report_configs:Â <a title="libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig" href="../models/pipeline_report_config.html#libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig">PipelineReportConfig</a>Â |Â NoneÂ =Â None,<br>resources:Â <a title="libica.openapi.v3.models.pipeline_resources.PipelineResources" href="../models/pipeline_resources.html#libica.openapi.v3.models.pipeline_resources.PipelineResources">PipelineResources</a>Â |Â NoneÂ =Â None) â€‘>Â <a title="libica.openapi.v3.models.project_pipeline.ProjectPipeline" href="../models/project_pipeline.html#libica.openapi.v3.models.project_pipeline.ProjectPipeline">ProjectPipeline</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_pipeline(
    self,
    project_id: StrictStr,
    code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the pipeline&#34;)],
    description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the pipeline&#34;)],
    main_nextflow_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The main Nextflow file.&#34;)],
    parameters_xml_file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
    pipeline_language_version_id: Annotated[Optional[StrictStr], Field(description=&#34;The id of the Nextflow version to use for the pipeline.&#34;)] = None,
    nextflow_config_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The Nextflow config file.&#34;)] = None,
    other_nextflow_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
    links: Optional[Links] = None,
    version_comment: Optional[StrictStr] = None,
    categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
    html_documentation: Optional[StrictStr] = None,
    proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
    report_configs: Optional[PipelineReportConfig] = None,
    resources: Optional[PipelineResources] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ProjectPipeline:
    &#34;&#34;&#34;Create a Nextflow pipeline within a project.


    :param project_id: (required)
    :type project_id: str
    :param code: The code of the pipeline (required)
    :type code: str
    :param description: The description of the pipeline (required)
    :type description: str
    :param main_nextflow_file: The main Nextflow file. (required)
    :type main_nextflow_file: bytearray
    :param parameters_xml_file: (required)
    :type parameters_xml_file: bytearray
    :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
    :type analysis_storage_id: str
    :param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
    :type pipeline_language_version_id: str
    :param nextflow_config_file: The Nextflow config file.
    :type nextflow_config_file: bytearray
    :param other_nextflow_files:
    :type other_nextflow_files: List[bytearray]
    :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
    :type metadata_model_file: bytearray
    :param links:
    :type links: Links
    :param version_comment:
    :type version_comment: str
    :param categories:
    :type categories: List[Optional[str]]
    :param html_documentation:
    :type html_documentation: str
    :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
    :type proprietary: bool
    :param report_configs:
    :type report_configs: PipelineReportConfig
    :param resources:
    :type resources: PipelineResources
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_pipeline_serialize(
        project_id=project_id,
        code=code,
        description=description,
        main_nextflow_file=main_nextflow_file,
        parameters_xml_file=parameters_xml_file,
        analysis_storage_id=analysis_storage_id,
        pipeline_language_version_id=pipeline_language_version_id,
        nextflow_config_file=nextflow_config_file,
        other_nextflow_files=other_nextflow_files,
        metadata_model_file=metadata_model_file,
        links=links,
        version_comment=version_comment,
        categories=categories,
        html_documentation=html_documentation,
        proprietary=proprietary,
        report_configs=report_configs,
        resources=resources,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;ProjectPipeline&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Create a Nextflow pipeline within a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param code: The code of the pipeline (required)
:type code: str
:param description: The description of the pipeline (required)
:type description: str
:param main_nextflow_file: The main Nextflow file. (required)
:type main_nextflow_file: bytearray
:param parameters_xml_file: (required)
:type parameters_xml_file: bytearray
:param analysis_storage_id: The id of the storage to use for the pipeline. (required)
:type analysis_storage_id: str
:param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
:type pipeline_language_version_id: str
:param nextflow_config_file: The Nextflow config file.
:type nextflow_config_file: bytearray
:param other_nextflow_files:
:type other_nextflow_files: List[bytearray]
:param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
:type metadata_model_file: bytearray
:param links:
:type links: Links
:param version_comment:
:type version_comment: str
:param categories:
:type categories: List[Optional[str]]
:param html_documentation:
:type html_documentation: str
:param proprietary: A boolean which indicates if the code of this pipeline is proprietary
:type proprietary: bool
:param report_configs:
:type report_configs: PipelineReportConfig
:param resources:
:type resources: PipelineResources
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_pipeline_with_http_info"><code class="name flex">
<span>def <span class="ident">create_nextflow_pipeline_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>code:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ codeÂ ofÂ theÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=255)])],<br>description:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ descriptionÂ ofÂ theÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=4000)])],<br>main_nextflow_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ mainÂ NextflowÂ file.')],<br>parameters_xml_file:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],<br>analysis_storage_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ storageÂ toÂ useÂ forÂ theÂ pipeline.')],<br>pipeline_language_version_id:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ NextflowÂ versionÂ toÂ useÂ forÂ theÂ pipeline.')]Â =Â None,<br>nextflow_config_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ NextflowÂ configÂ file.')]Â =Â None,<br>other_nextflow_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>metadata_model_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ metadataÂ modelÂ jsonÂ file(contentsÂ canÂ beÂ retrievedÂ fromÂ theÂ controlplane).')]Â =Â None,<br>links:Â <a title="libica.openapi.v3.models.links.Links" href="../models/links.html#libica.openapi.v3.models.links.Links">Links</a>Â |Â NoneÂ =Â None,<br>version_comment:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>categories:Â Annotated[List[Annotated[str,Â Strict(strict=True)]Â |Â None],Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[MinLen(min_length=1),Â MaxLen(max_length=4000)])]Â |Â NoneÂ =Â None,<br>html_documentation:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>proprietary:Â Annotated[Annotated[bool,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ booleanÂ whichÂ indicatesÂ ifÂ theÂ codeÂ ofÂ thisÂ pipelineÂ isÂ proprietary')]Â =Â None,<br>report_configs:Â <a title="libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig" href="../models/pipeline_report_config.html#libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig">PipelineReportConfig</a>Â |Â NoneÂ =Â None,<br>resources:Â <a title="libica.openapi.v3.models.pipeline_resources.PipelineResources" href="../models/pipeline_resources.html#libica.openapi.v3.models.pipeline_resources.PipelineResources">PipelineResources</a>Â |Â NoneÂ =Â None) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[ProjectPipeline]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_pipeline_with_http_info(
    self,
    project_id: StrictStr,
    code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the pipeline&#34;)],
    description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the pipeline&#34;)],
    main_nextflow_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The main Nextflow file.&#34;)],
    parameters_xml_file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
    pipeline_language_version_id: Annotated[Optional[StrictStr], Field(description=&#34;The id of the Nextflow version to use for the pipeline.&#34;)] = None,
    nextflow_config_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The Nextflow config file.&#34;)] = None,
    other_nextflow_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
    links: Optional[Links] = None,
    version_comment: Optional[StrictStr] = None,
    categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
    html_documentation: Optional[StrictStr] = None,
    proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
    report_configs: Optional[PipelineReportConfig] = None,
    resources: Optional[PipelineResources] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[ProjectPipeline]:
    &#34;&#34;&#34;Create a Nextflow pipeline within a project.


    :param project_id: (required)
    :type project_id: str
    :param code: The code of the pipeline (required)
    :type code: str
    :param description: The description of the pipeline (required)
    :type description: str
    :param main_nextflow_file: The main Nextflow file. (required)
    :type main_nextflow_file: bytearray
    :param parameters_xml_file: (required)
    :type parameters_xml_file: bytearray
    :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
    :type analysis_storage_id: str
    :param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
    :type pipeline_language_version_id: str
    :param nextflow_config_file: The Nextflow config file.
    :type nextflow_config_file: bytearray
    :param other_nextflow_files:
    :type other_nextflow_files: List[bytearray]
    :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
    :type metadata_model_file: bytearray
    :param links:
    :type links: Links
    :param version_comment:
    :type version_comment: str
    :param categories:
    :type categories: List[Optional[str]]
    :param html_documentation:
    :type html_documentation: str
    :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
    :type proprietary: bool
    :param report_configs:
    :type report_configs: PipelineReportConfig
    :param resources:
    :type resources: PipelineResources
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_pipeline_serialize(
        project_id=project_id,
        code=code,
        description=description,
        main_nextflow_file=main_nextflow_file,
        parameters_xml_file=parameters_xml_file,
        analysis_storage_id=analysis_storage_id,
        pipeline_language_version_id=pipeline_language_version_id,
        nextflow_config_file=nextflow_config_file,
        other_nextflow_files=other_nextflow_files,
        metadata_model_file=metadata_model_file,
        links=links,
        version_comment=version_comment,
        categories=categories,
        html_documentation=html_documentation,
        proprietary=proprietary,
        report_configs=report_configs,
        resources=resources,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;ProjectPipeline&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Create a Nextflow pipeline within a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param code: The code of the pipeline (required)
:type code: str
:param description: The description of the pipeline (required)
:type description: str
:param main_nextflow_file: The main Nextflow file. (required)
:type main_nextflow_file: bytearray
:param parameters_xml_file: (required)
:type parameters_xml_file: bytearray
:param analysis_storage_id: The id of the storage to use for the pipeline. (required)
:type analysis_storage_id: str
:param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
:type pipeline_language_version_id: str
:param nextflow_config_file: The Nextflow config file.
:type nextflow_config_file: bytearray
:param other_nextflow_files:
:type other_nextflow_files: List[bytearray]
:param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
:type metadata_model_file: bytearray
:param links:
:type links: Links
:param version_comment:
:type version_comment: str
:param categories:
:type categories: List[Optional[str]]
:param html_documentation:
:type html_documentation: str
:param proprietary: A boolean which indicates if the code of this pipeline is proprietary
:type proprietary: bool
:param report_configs:
:type report_configs: PipelineReportConfig
:param resources:
:type resources: PipelineResources
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_pipeline_without_preload_content"><code class="name flex">
<span>def <span class="ident">create_nextflow_pipeline_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>code:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ codeÂ ofÂ theÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=255)])],<br>description:Â Annotated[str,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ descriptionÂ ofÂ theÂ pipeline',Â metadata=[Strict(strict=True),Â MinLen(min_length=1),Â MaxLen(max_length=4000)])],<br>main_nextflow_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ mainÂ NextflowÂ file.')],<br>parameters_xml_file:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]],<br>analysis_storage_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ storageÂ toÂ useÂ forÂ theÂ pipeline.')],<br>pipeline_language_version_id:Â Annotated[Annotated[str,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ idÂ ofÂ theÂ NextflowÂ versionÂ toÂ useÂ forÂ theÂ pipeline.')]Â =Â None,<br>nextflow_config_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ NextflowÂ configÂ file.')]Â =Â None,<br>other_nextflow_files:Â List[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]]Â |Â NoneÂ =Â None,<br>metadata_model_file:Â Annotated[Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ metadataÂ modelÂ jsonÂ file(contentsÂ canÂ beÂ retrievedÂ fromÂ theÂ controlplane).')]Â =Â None,<br>links:Â <a title="libica.openapi.v3.models.links.Links" href="../models/links.html#libica.openapi.v3.models.links.Links">Links</a>Â |Â NoneÂ =Â None,<br>version_comment:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>categories:Â Annotated[List[Annotated[str,Â Strict(strict=True)]Â |Â None],Â FieldInfo(annotation=NoneType,Â required=True,Â metadata=[MinLen(min_length=1),Â MaxLen(max_length=4000)])]Â |Â NoneÂ =Â None,<br>html_documentation:Â Annotated[str,Â Strict(strict=True)]Â |Â NoneÂ =Â None,<br>proprietary:Â Annotated[Annotated[bool,Â Strict(strict=True)]Â |Â None,Â FieldInfo(annotation=NoneType,Â required=True,Â description='AÂ booleanÂ whichÂ indicatesÂ ifÂ theÂ codeÂ ofÂ thisÂ pipelineÂ isÂ proprietary')]Â =Â None,<br>report_configs:Â <a title="libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig" href="../models/pipeline_report_config.html#libica.openapi.v3.models.pipeline_report_config.PipelineReportConfig">PipelineReportConfig</a>Â |Â NoneÂ =Â None,<br>resources:Â <a title="libica.openapi.v3.models.pipeline_resources.PipelineResources" href="../models/pipeline_resources.html#libica.openapi.v3.models.pipeline_resources.PipelineResources">PipelineResources</a>Â |Â NoneÂ =Â None) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_nextflow_pipeline_without_preload_content(
    self,
    project_id: StrictStr,
    code: Annotated[str, Field(min_length=1, strict=True, max_length=255, description=&#34;The code of the pipeline&#34;)],
    description: Annotated[str, Field(min_length=1, strict=True, max_length=4000, description=&#34;The description of the pipeline&#34;)],
    main_nextflow_file: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description=&#34;The main Nextflow file.&#34;)],
    parameters_xml_file: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    analysis_storage_id: Annotated[StrictStr, Field(description=&#34;The id of the storage to use for the pipeline.&#34;)],
    pipeline_language_version_id: Annotated[Optional[StrictStr], Field(description=&#34;The id of the Nextflow version to use for the pipeline.&#34;)] = None,
    nextflow_config_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The Nextflow config file.&#34;)] = None,
    other_nextflow_files: Optional[List[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]]] = None,
    metadata_model_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description=&#34;The metadata model json file(contents can be retrieved from the controlplane).&#34;)] = None,
    links: Optional[Links] = None,
    version_comment: Optional[StrictStr] = None,
    categories: Optional[Annotated[List[Optional[StrictStr]], Field(min_length=1, max_length=4000)]] = None,
    html_documentation: Optional[StrictStr] = None,
    proprietary: Annotated[Optional[StrictBool], Field(description=&#34;A boolean which indicates if the code of this pipeline is proprietary&#34;)] = None,
    report_configs: Optional[PipelineReportConfig] = None,
    resources: Optional[PipelineResources] = None,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Create a Nextflow pipeline within a project.


    :param project_id: (required)
    :type project_id: str
    :param code: The code of the pipeline (required)
    :type code: str
    :param description: The description of the pipeline (required)
    :type description: str
    :param main_nextflow_file: The main Nextflow file. (required)
    :type main_nextflow_file: bytearray
    :param parameters_xml_file: (required)
    :type parameters_xml_file: bytearray
    :param analysis_storage_id: The id of the storage to use for the pipeline. (required)
    :type analysis_storage_id: str
    :param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
    :type pipeline_language_version_id: str
    :param nextflow_config_file: The Nextflow config file.
    :type nextflow_config_file: bytearray
    :param other_nextflow_files:
    :type other_nextflow_files: List[bytearray]
    :param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
    :type metadata_model_file: bytearray
    :param links:
    :type links: Links
    :param version_comment:
    :type version_comment: str
    :param categories:
    :type categories: List[Optional[str]]
    :param html_documentation:
    :type html_documentation: str
    :param proprietary: A boolean which indicates if the code of this pipeline is proprietary
    :type proprietary: bool
    :param report_configs:
    :type report_configs: PipelineReportConfig
    :param resources:
    :type resources: PipelineResources
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_nextflow_pipeline_serialize(
        project_id=project_id,
        code=code,
        description=description,
        main_nextflow_file=main_nextflow_file,
        parameters_xml_file=parameters_xml_file,
        analysis_storage_id=analysis_storage_id,
        pipeline_language_version_id=pipeline_language_version_id,
        nextflow_config_file=nextflow_config_file,
        other_nextflow_files=other_nextflow_files,
        metadata_model_file=metadata_model_file,
        links=links,
        version_comment=version_comment,
        categories=categories,
        html_documentation=html_documentation,
        proprietary=proprietary,
        report_configs=report_configs,
        resources=resources,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;ProjectPipeline&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Create a Nextflow pipeline within a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param code: The code of the pipeline (required)
:type code: str
:param description: The description of the pipeline (required)
:type description: str
:param main_nextflow_file: The main Nextflow file. (required)
:type main_nextflow_file: bytearray
:param parameters_xml_file: (required)
:type parameters_xml_file: bytearray
:param analysis_storage_id: The id of the storage to use for the pipeline. (required)
:type analysis_storage_id: str
:param pipeline_language_version_id: The id of the Nextflow version to use for the pipeline.
:type pipeline_language_version_id: str
:param nextflow_config_file: The Nextflow config file.
:type nextflow_config_file: bytearray
:param other_nextflow_files:
:type other_nextflow_files: List[bytearray]
:param metadata_model_file: The metadata model json file(contents can be retrieved from the controlplane).
:type metadata_model_file: bytearray
:param links:
:type links: Links
:param version_comment:
:type version_comment: str
:param categories:
:type categories: List[Optional[str]]
:param html_documentation:
:type html_documentation: str
:param proprietary: A boolean which indicates if the code of this pipeline is proprietary
:type proprietary: bool
:param report_configs:
:type report_configs: PipelineReportConfig
:param resources:
:type resources: PipelineResources
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_project_pipeline_file"><code class="name flex">
<span>def <span class="ident">create_project_pipeline_file</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ createÂ aÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â <a title="libica.openapi.v3.models.pipeline_file.PipelineFile" href="../models/pipeline_file.html#libica.openapi.v3.models.pipeline_file.PipelineFile">PipelineFile</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_project_pipeline_file(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to create a file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; PipelineFile:
    &#34;&#34;&#34;Create a file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to create a file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;PipelineFile&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Create a file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to create a file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_project_pipeline_file_with_http_info"><code class="name flex">
<span>def <span class="ident">create_project_pipeline_file_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ createÂ aÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[PipelineFile]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_project_pipeline_file_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to create a file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[PipelineFile]:
    &#34;&#34;&#34;Create a file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to create a file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;PipelineFile&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Create a file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to create a file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_project_pipeline_file_without_preload_content"><code class="name flex">
<span>def <span class="ident">create_project_pipeline_file_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ createÂ aÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def create_project_pipeline_file_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to create a file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Create a file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to create a file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._create_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;201&#39;: &#34;PipelineFile&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Create a file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to create a file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_additional_project_pipeline_file"><code class="name flex">
<span>def <span class="ident">delete_additional_project_pipeline_file</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ deleteÂ anÂ additionalÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ file')]) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def delete_additional_project_pipeline_file(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to delete an additional file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; None:
    &#34;&#34;&#34;Delete an additional input form file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to delete an additional file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the pipeline file (required)
    :type file_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._delete_additional_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Delete an additional input form file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to delete an additional file for (required)
:type pipeline_id: str
:param file_id: The ID of the pipeline file (required)
:type file_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_additional_project_pipeline_file_with_http_info"><code class="name flex">
<span>def <span class="ident">delete_additional_project_pipeline_file_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ deleteÂ anÂ additionalÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ file')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[NoneType]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def delete_additional_project_pipeline_file_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to delete an additional file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[None]:
    &#34;&#34;&#34;Delete an additional input form file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to delete an additional file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the pipeline file (required)
    :type file_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._delete_additional_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Delete an additional input form file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to delete an additional file for (required)
:type pipeline_id: str
:param file_id: The ID of the pipeline file (required)
:type file_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_additional_project_pipeline_file_without_preload_content"><code class="name flex">
<span>def <span class="ident">delete_additional_project_pipeline_file_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ deleteÂ anÂ additionalÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ file')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def delete_additional_project_pipeline_file_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to delete an additional file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Delete an additional input form file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to delete an additional file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the pipeline file (required)
    :type file_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._delete_additional_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Delete an additional input form file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to delete an additional file for (required)
:type pipeline_id: str
:param file_id: The ID of the pipeline file (required)
:type file_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_project_pipeline_file"><code class="name flex">
<span>def <span class="ident">delete_project_pipeline_file</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ deleteÂ aÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ file')]) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def delete_project_pipeline_file(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to delete a file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; None:
    &#34;&#34;&#34;Delete a file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to delete a file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the pipeline file (required)
    :type file_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._delete_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Delete a file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to delete a file for (required)
:type pipeline_id: str
:param file_id: The ID of the pipeline file (required)
:type file_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_project_pipeline_file_with_http_info"><code class="name flex">
<span>def <span class="ident">delete_project_pipeline_file_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ deleteÂ aÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ file')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[NoneType]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def delete_project_pipeline_file_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to delete a file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[None]:
    &#34;&#34;&#34;Delete a file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to delete a file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the pipeline file (required)
    :type file_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._delete_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Delete a file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to delete a file for (required)
:type pipeline_id: str
:param file_id: The ID of the pipeline file (required)
:type file_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_project_pipeline_file_without_preload_content"><code class="name flex">
<span>def <span class="ident">delete_project_pipeline_file_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ deleteÂ aÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ file')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def delete_project_pipeline_file_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to delete a file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Delete a file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to delete a file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the pipeline file (required)
    :type file_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._delete_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Delete a file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to delete a file for (required)
:type pipeline_id: str
:param file_id: The ID of the pipeline file (required)
:type file_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_additional_file_content"><code class="name flex">
<span>def <span class="ident">download_additional_file_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ theÂ additionalÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ additionalÂ file')]) â€‘>Â bytearray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_additional_file_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the additional file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the additional file&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; bytearray:
    &#34;&#34;&#34;Download the contents of an additional input form file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve the additional file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the additional file (required)
    :type file_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_additional_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Download the contents of an additional input form file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve the additional file for (required)
:type pipeline_id: str
:param file_id: The ID of the additional file (required)
:type file_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_additional_file_content_with_http_info"><code class="name flex">
<span>def <span class="ident">download_additional_file_content_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ theÂ additionalÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ additionalÂ file')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[bytearray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_additional_file_content_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the additional file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the additional file&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[bytearray]:
    &#34;&#34;&#34;Download the contents of an additional input form file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve the additional file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the additional file (required)
    :type file_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_additional_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Download the contents of an additional input form file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve the additional file for (required)
:type pipeline_id: str
:param file_id: The ID of the additional file (required)
:type file_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_additional_file_content_without_preload_content"><code class="name flex">
<span>def <span class="ident">download_additional_file_content_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ theÂ additionalÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ additionalÂ file')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_additional_file_content_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the additional file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the additional file&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Download the contents of an additional input form file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve the additional file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the additional file (required)
    :type file_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_additional_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Download the contents of an additional input form file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve the additional file for (required)
:type pipeline_id: str
:param file_id: The ID of the additional file (required)
:type file_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_input_form_file_content"><code class="name flex">
<span>def <span class="ident">download_input_form_file_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ theÂ inputÂ formÂ fileÂ for')]) â€‘>Â bytearray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_input_form_file_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the input form file for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; bytearray:
    &#34;&#34;&#34;Download the contents of the input form file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve the input form file for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_input_form_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Download the contents of the input form file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve the input form file for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_input_form_file_content_with_http_info"><code class="name flex">
<span>def <span class="ident">download_input_form_file_content_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ theÂ inputÂ formÂ fileÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[bytearray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_input_form_file_content_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the input form file for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[bytearray]:
    &#34;&#34;&#34;Download the contents of the input form file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve the input form file for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_input_form_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Download the contents of the input form file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve the input form file for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_input_form_file_content_without_preload_content"><code class="name flex">
<span>def <span class="ident">download_input_form_file_content_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ theÂ inputÂ formÂ fileÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_input_form_file_content_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the input form file for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Download the contents of the input form file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve the input form file for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_input_form_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Download the contents of the input form file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve the input form file for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_render_file_content"><code class="name flex">
<span>def <span class="ident">download_on_render_file_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ theÂ onRenderÂ fileÂ for')]) â€‘>Â bytearray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_on_render_file_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the onRender file for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; bytearray:
    &#34;&#34;&#34;Download the contents of the onRender file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve the onRender file for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_on_render_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Download the contents of the onRender file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve the onRender file for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_render_file_content_with_http_info"><code class="name flex">
<span>def <span class="ident">download_on_render_file_content_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ theÂ onRenderÂ fileÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[bytearray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_on_render_file_content_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the onRender file for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[bytearray]:
    &#34;&#34;&#34;Download the contents of the onRender file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve the onRender file for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_on_render_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Download the contents of the onRender file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve the onRender file for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_render_file_content_without_preload_content"><code class="name flex">
<span>def <span class="ident">download_on_render_file_content_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ theÂ onRenderÂ fileÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_on_render_file_content_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the onRender file for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Download the contents of the onRender file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve the onRender file for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_on_render_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Download the contents of the onRender file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve the onRender file for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_submit_file_content"><code class="name flex">
<span>def <span class="ident">download_on_submit_file_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ theÂ onSubmitÂ fileÂ for')]) â€‘>Â bytearray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_on_submit_file_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the onSubmit file for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; bytearray:
    &#34;&#34;&#34;Download the contents of the onSubmit file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve the onSubmit file for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_on_submit_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Download the contents of the onSubmit file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve the onSubmit file for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_submit_file_content_with_http_info"><code class="name flex">
<span>def <span class="ident">download_on_submit_file_content_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ theÂ onSubmitÂ fileÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[bytearray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_on_submit_file_content_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the onSubmit file for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[bytearray]:
    &#34;&#34;&#34;Download the contents of the onSubmit file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve the onSubmit file for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_on_submit_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Download the contents of the onSubmit file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve the onSubmit file for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_submit_file_content_without_preload_content"><code class="name flex">
<span>def <span class="ident">download_on_submit_file_content_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ theÂ onSubmitÂ fileÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_on_submit_file_content_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve the onSubmit file for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Download the contents of the onSubmit file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve the onSubmit file for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_on_submit_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Download the contents of the onSubmit file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve the onSubmit file for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_project_pipeline_file_content"><code class="name flex">
<span>def <span class="ident">download_project_pipeline_file_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ filesÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ file')]) â€‘>Â bytearray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_project_pipeline_file_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; bytearray:
    &#34;&#34;&#34;Download the contents of a pipeline file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
    :type pipeline_id: str
    :param file_id: The ID of the pipeline file (required)
    :type file_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_project_pipeline_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Download the contents of a pipeline file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve files for (required)
:type pipeline_id: str
:param file_id: The ID of the pipeline file (required)
:type file_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_project_pipeline_file_content_with_http_info"><code class="name flex">
<span>def <span class="ident">download_project_pipeline_file_content_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ filesÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ file')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[bytearray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_project_pipeline_file_content_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[bytearray]:
    &#34;&#34;&#34;Download the contents of a pipeline file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
    :type pipeline_id: str
    :param file_id: The ID of the pipeline file (required)
    :type file_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_project_pipeline_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Download the contents of a pipeline file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve files for (required)
:type pipeline_id: str
:param file_id: The ID of the pipeline file (required)
:type file_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_project_pipeline_file_content_without_preload_content"><code class="name flex">
<span>def <span class="ident">download_project_pipeline_file_content_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ filesÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ file')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def download_project_pipeline_file_content_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Download the contents of a pipeline file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
    :type pipeline_id: str
    :param file_id: The ID of the pipeline file (required)
    :type file_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._download_project_pipeline_file_content_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;bytearray&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Download the contents of a pipeline file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve files for (required)
:type pipeline_id: str
:param file_id: The ID of the pipeline file (required)
:type file_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline"><code class="name flex">
<span>def <span class="ident">get_project_pipeline</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieve')]) â€‘>Â <a title="libica.openapi.v3.models.project_pipeline_v4.ProjectPipelineV4" href="../models/project_pipeline_v4.html#libica.openapi.v3.models.project_pipeline_v4.ProjectPipelineV4">ProjectPipelineV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ProjectPipelineV4:
    &#34;&#34;&#34;Retrieve a project pipeline.

    Retrieves a project pipeline. This can be a pipeline from a linked bundle or an entitled, unlinked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;ProjectPipelineV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve a project pipeline.</p>
<p>Retrieves a project pipeline. This can be a pipeline from a linked bundle or an entitled, unlinked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_additional_files"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_additional_files</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ filesÂ for')]) â€‘>Â <a title="libica.openapi.v3.models.pipeline_file_list.PipelineFileList" href="../models/pipeline_file_list.html#libica.openapi.v3.models.pipeline_file_list.PipelineFileList">PipelineFileList</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_additional_files(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; PipelineFileList:
    &#34;&#34;&#34;Retrieve additional input form files for a project pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_additional_files_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineFileList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve additional input form files for a project pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve files for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_additional_files_with_http_info"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_additional_files_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ filesÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[PipelineFileList]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_additional_files_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[PipelineFileList]:
    &#34;&#34;&#34;Retrieve additional input form files for a project pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_additional_files_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineFileList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve additional input form files for a project pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve files for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_additional_files_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_additional_files_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ filesÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_additional_files_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve additional input form files for a project pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_additional_files_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineFileList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve additional input form files for a project pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve files for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_configuration_parameters"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_configuration_parameters</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ inputÂ parametersÂ for')]) â€‘>Â <a title="libica.openapi.v3.models.pipeline_configuration_parameter_list.PipelineConfigurationParameterList" href="../models/pipeline_configuration_parameter_list.html#libica.openapi.v3.models.pipeline_configuration_parameter_list.PipelineConfigurationParameterList">PipelineConfigurationParameterList</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_configuration_parameters(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve input parameters for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; PipelineConfigurationParameterList:
    &#34;&#34;&#34;Retrieve configuration parameters for a project pipeline.

    The pipeline can originate from a linked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_configuration_parameters_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineConfigurationParameterList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve configuration parameters for a project pipeline.</p>
<p>The pipeline can originate from a linked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_configuration_parameters_with_http_info"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_configuration_parameters_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ inputÂ parametersÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[PipelineConfigurationParameterList]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_configuration_parameters_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve input parameters for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[PipelineConfigurationParameterList]:
    &#34;&#34;&#34;Retrieve configuration parameters for a project pipeline.

    The pipeline can originate from a linked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_configuration_parameters_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineConfigurationParameterList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve configuration parameters for a project pipeline.</p>
<p>The pipeline can originate from a linked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_configuration_parameters_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_configuration_parameters_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ inputÂ parametersÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_configuration_parameters_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve input parameters for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve configuration parameters for a project pipeline.

    The pipeline can originate from a linked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_configuration_parameters_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineConfigurationParameterList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve configuration parameters for a project pipeline.</p>
<p>The pipeline can originate from a linked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_files"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_files</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ filesÂ for')]) â€‘>Â <a title="libica.openapi.v3.models.pipeline_file_list.PipelineFileList" href="../models/pipeline_file_list.html#libica.openapi.v3.models.pipeline_file_list.PipelineFileList">PipelineFileList</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_files(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; PipelineFileList:
    &#34;&#34;&#34;Retrieve files for a project pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_files_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineFileList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve files for a project pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve files for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_files_with_http_info"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_files_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ filesÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[PipelineFileList]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_files_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[PipelineFileList]:
    &#34;&#34;&#34;Retrieve files for a project pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_files_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineFileList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve files for a project pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve files for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_files_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_files_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ filesÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_files_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve files for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve files for a project pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve files for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_files_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineFileList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve files for a project pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve files for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_html_documentation"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_html_documentation</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ HTMLÂ documentationÂ from')]) â€‘>Â <a title="libica.openapi.v3.models.pipeline_html_documentation.PipelineHtmlDocumentation" href="../models/pipeline_html_documentation.html#libica.openapi.v3.models.pipeline_html_documentation.PipelineHtmlDocumentation">PipelineHtmlDocumentation</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_html_documentation(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve HTML documentation from&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; PipelineHtmlDocumentation:
    &#34;&#34;&#34;Retrieve HTML documentation for a project pipeline.

    Retrieve HTML documentation for a project pipeline. This can be a pipeline from a linked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve HTML documentation from (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_html_documentation_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineHtmlDocumentation&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve HTML documentation for a project pipeline.</p>
<p>Retrieve HTML documentation for a project pipeline. This can be a pipeline from a linked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve HTML documentation from (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_html_documentation_with_http_info"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_html_documentation_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ HTMLÂ documentationÂ from')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[PipelineHtmlDocumentation]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_html_documentation_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve HTML documentation from&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[PipelineHtmlDocumentation]:
    &#34;&#34;&#34;Retrieve HTML documentation for a project pipeline.

    Retrieve HTML documentation for a project pipeline. This can be a pipeline from a linked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve HTML documentation from (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_html_documentation_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineHtmlDocumentation&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve HTML documentation for a project pipeline.</p>
<p>Retrieve HTML documentation for a project pipeline. This can be a pipeline from a linked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve HTML documentation from (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_html_documentation_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_html_documentation_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ HTMLÂ documentationÂ from')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_html_documentation_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve HTML documentation from&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve HTML documentation for a project pipeline.

    Retrieve HTML documentation for a project pipeline. This can be a pipeline from a linked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve HTML documentation from (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_html_documentation_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineHtmlDocumentation&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve HTML documentation for a project pipeline.</p>
<p>Retrieve HTML documentation for a project pipeline. This can be a pipeline from a linked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve HTML documentation from (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_input_parameters"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_input_parameters</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ inputÂ parametersÂ for')]) â€‘>Â <a title="libica.openapi.v3.models.input_parameter_list.InputParameterList" href="../models/input_parameter_list.html#libica.openapi.v3.models.input_parameter_list.InputParameterList">InputParameterList</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_input_parameters(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve input parameters for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; InputParameterList:
    &#34;&#34;&#34;Retrieve input parameters for a project pipeline.

    The pipeline can originate from a linked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_input_parameters_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;InputParameterList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve input parameters for a project pipeline.</p>
<p>The pipeline can originate from a linked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_input_parameters_with_http_info"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_input_parameters_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ inputÂ parametersÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[InputParameterList]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_input_parameters_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve input parameters for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[InputParameterList]:
    &#34;&#34;&#34;Retrieve input parameters for a project pipeline.

    The pipeline can originate from a linked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_input_parameters_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;InputParameterList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve input parameters for a project pipeline.</p>
<p>The pipeline can originate from a linked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_input_parameters_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_input_parameters_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieveÂ inputÂ parametersÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_input_parameters_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve input parameters for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve input parameters for a project pipeline.

    The pipeline can originate from a linked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_input_parameters_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;InputParameterList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve input parameters for a project pipeline.</p>
<p>The pipeline can originate from a linked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve input parameters for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_reference_sets"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_reference_sets</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ toÂ retrieveÂ referenceÂ setsÂ for')]) â€‘>Â <a title="libica.openapi.v3.models.reference_set_list.ReferenceSetList" href="../models/reference_set_list.html#libica.openapi.v3.models.reference_set_list.ReferenceSetList">ReferenceSetList</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_reference_sets(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline to retrieve reference sets for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ReferenceSetList:
    &#34;&#34;&#34;Retrieve the reference sets of a project pipeline.

    Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the pipeline to retrieve reference sets for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_reference_sets_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;ReferenceSetList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve the reference sets of a project pipeline.</p>
<p>Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the pipeline to retrieve reference sets for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_reference_sets_with_http_info"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_reference_sets_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ toÂ retrieveÂ referenceÂ setsÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[ReferenceSetList]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_reference_sets_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline to retrieve reference sets for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[ReferenceSetList]:
    &#34;&#34;&#34;Retrieve the reference sets of a project pipeline.

    Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the pipeline to retrieve reference sets for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_reference_sets_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;ReferenceSetList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve the reference sets of a project pipeline.</p>
<p>Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the pipeline to retrieve reference sets for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_reference_sets_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_reference_sets_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ toÂ retrieveÂ referenceÂ setsÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_reference_sets_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline to retrieve reference sets for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve the reference sets of a project pipeline.

    Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the pipeline to retrieve reference sets for (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_reference_sets_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;ReferenceSetList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve the reference sets of a project pipeline.</p>
<p>Retrieve the reference sets of a project pipeline. This can be a pipeline from a linked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the pipeline to retrieve reference sets for (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_with_http_info"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieve')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[ProjectPipelineV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[ProjectPipelineV4]:
    &#34;&#34;&#34;Retrieve a project pipeline.

    Retrieves a project pipeline. This can be a pipeline from a linked bundle or an entitled, unlinked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;ProjectPipelineV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve a project pipeline.</p>
<p>Retrieves a project pipeline. This can be a pipeline from a linked bundle or an entitled, unlinked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_project_pipeline_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ retrieve')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipeline_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to retrieve&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve a project pipeline.

    Retrieves a project pipeline. This can be a pipeline from a linked bundle or an entitled, unlinked bundle.

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to retrieve (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipeline_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;ProjectPipelineV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve a project pipeline.</p>
<p>Retrieves a project pipeline. This can be a pipeline from a linked bundle or an entitled, unlinked bundle.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to retrieve (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipelines"><code class="name flex">
<span>def <span class="ident">get_project_pipelines</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ toÂ retrieveÂ pipelinesÂ for')]) â€‘>Â <a title="libica.openapi.v3.models.project_pipeline_list.ProjectPipelineList" href="../models/project_pipeline_list.html#libica.openapi.v3.models.project_pipeline_list.ProjectPipelineList">ProjectPipelineList</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipelines(
    self,
    project_id: Annotated[StrictStr, Field(description=&#34;The ID of the project to retrieve pipelines for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ProjectPipelineList:
    &#34;&#34;&#34;Retrieve a list of project pipelines.

    Lists all pipelines that are available to the project.

    :param project_id: The ID of the project to retrieve pipelines for (required)
    :type project_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipelines_serialize(
        project_id=project_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;ProjectPipelineList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Retrieve a list of project pipelines.</p>
<p>Lists all pipelines that are available to the project.</p>
<p>:param project_id: The ID of the project to retrieve pipelines for (required)
:type project_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipelines_with_http_info"><code class="name flex">
<span>def <span class="ident">get_project_pipelines_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ toÂ retrieveÂ pipelinesÂ for')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[ProjectPipelineList]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipelines_with_http_info(
    self,
    project_id: Annotated[StrictStr, Field(description=&#34;The ID of the project to retrieve pipelines for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[ProjectPipelineList]:
    &#34;&#34;&#34;Retrieve a list of project pipelines.

    Lists all pipelines that are available to the project.

    :param project_id: The ID of the project to retrieve pipelines for (required)
    :type project_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipelines_serialize(
        project_id=project_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;ProjectPipelineList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Retrieve a list of project pipelines.</p>
<p>Lists all pipelines that are available to the project.</p>
<p>:param project_id: The ID of the project to retrieve pipelines for (required)
:type project_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipelines_without_preload_content"><code class="name flex">
<span>def <span class="ident">get_project_pipelines_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ toÂ retrieveÂ pipelinesÂ for')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def get_project_pipelines_without_preload_content(
    self,
    project_id: Annotated[StrictStr, Field(description=&#34;The ID of the project to retrieve pipelines for&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Retrieve a list of project pipelines.

    Lists all pipelines that are available to the project.

    :param project_id: The ID of the project to retrieve pipelines for (required)
    :type project_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._get_project_pipelines_serialize(
        project_id=project_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;ProjectPipelineList&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Retrieve a list of project pipelines.</p>
<p>Lists all pipelines that are available to the project.</p>
<p>:param project_id: The ID of the project to retrieve pipelines for (required)
:type project_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.link_pipeline_to_project"><code class="name flex">
<span>def <span class="ident">link_pipeline_to_project</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipeline')]) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def link_pipeline_to_project(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; None:
    &#34;&#34;&#34;Link a pipeline to a project.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the pipeline (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._link_pipeline_to_project_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Link a pipeline to a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the pipeline (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.link_pipeline_to_project_with_http_info"><code class="name flex">
<span>def <span class="ident">link_pipeline_to_project_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipeline')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[NoneType]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def link_pipeline_to_project_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[None]:
    &#34;&#34;&#34;Link a pipeline to a project.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the pipeline (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._link_pipeline_to_project_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Link a pipeline to a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the pipeline (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.link_pipeline_to_project_without_preload_content"><code class="name flex">
<span>def <span class="ident">link_pipeline_to_project_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipeline')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def link_pipeline_to_project_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Link a pipeline to a project.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the pipeline (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._link_pipeline_to_project_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Link a pipeline to a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the pipeline (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.release_project_pipeline"><code class="name flex">
<span>def <span class="ident">release_project_pipeline</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipeline')]) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def release_project_pipeline(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; None:
    &#34;&#34;&#34;Release a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the pipeline (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._release_project_pipeline_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Release a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the pipeline (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.release_project_pipeline_with_http_info"><code class="name flex">
<span>def <span class="ident">release_project_pipeline_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipeline')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[NoneType]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def release_project_pipeline_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[None]:
    &#34;&#34;&#34;Release a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the pipeline (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._release_project_pipeline_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Release a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the pipeline (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.release_project_pipeline_without_preload_content"><code class="name flex">
<span>def <span class="ident">release_project_pipeline_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipeline')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def release_project_pipeline_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Release a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the pipeline (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._release_project_pipeline_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Release a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the pipeline (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.unlink_pipeline_from_project"><code class="name flex">
<span>def <span class="ident">unlink_pipeline_from_project</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipeline')]) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def unlink_pipeline_from_project(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; None:
    &#34;&#34;&#34;Unlink a pipeline from a project.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the pipeline (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._unlink_pipeline_from_project_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Unlink a pipeline from a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the pipeline (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.unlink_pipeline_from_project_with_http_info"><code class="name flex">
<span>def <span class="ident">unlink_pipeline_from_project_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipeline')]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[NoneType]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def unlink_pipeline_from_project_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[None]:
    &#34;&#34;&#34;Unlink a pipeline from a project.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the pipeline (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._unlink_pipeline_from_project_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Unlink a pipeline from a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the pipeline (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.unlink_pipeline_from_project_without_preload_content"><code class="name flex">
<span>def <span class="ident">unlink_pipeline_from_project_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipeline')]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def unlink_pipeline_from_project_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline&#34;)],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Unlink a pipeline from a project.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the pipeline (required)
    :type pipeline_id: str
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._unlink_pipeline_from_project_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;204&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Unlink a pipeline from a project.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the pipeline (required)
:type pipeline_id: str
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_additional_file"><code class="name flex">
<span>def <span class="ident">update_additional_file</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ theÂ additionalÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ additionalÂ file')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_additional_file(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the additional file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the additional file&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; None:
    &#34;&#34;&#34;Update the contents of an additional input form file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update the additional file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the additional file (required)
    :type file_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_additional_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Update the contents of an additional input form file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update the additional file for (required)
:type pipeline_id: str
:param file_id: The ID of the additional file (required)
:type file_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_additional_file_with_http_info"><code class="name flex">
<span>def <span class="ident">update_additional_file_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ theÂ additionalÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ additionalÂ file')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[NoneType]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_additional_file_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the additional file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the additional file&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[None]:
    &#34;&#34;&#34;Update the contents of an additional input form file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update the additional file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the additional file (required)
    :type file_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_additional_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Update the contents of an additional input form file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update the additional file for (required)
:type pipeline_id: str
:param file_id: The ID of the additional file (required)
:type file_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_additional_file_without_preload_content"><code class="name flex">
<span>def <span class="ident">update_additional_file_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ theÂ additionalÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ additionalÂ file')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_additional_file_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the additional file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the additional file&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Update the contents of an additional input form file.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update the additional file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the additional file (required)
    :type file_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_additional_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Update the contents of an additional input form file.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update the additional file for (required)
:type pipeline_id: str
:param file_id: The ID of the additional file (required)
:type file_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_general_attributes_project_pipeline"><code class="name flex">
<span>def <span class="ident">update_general_attributes_project_pipeline</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ update')],<br>pipeline_update:Â <a title="libica.openapi.v3.models.pipeline_update.PipelineUpdate" href="../models/pipeline_update.html#libica.openapi.v3.models.pipeline_update.PipelineUpdate">PipelineUpdate</a>) â€‘>Â <a title="libica.openapi.v3.models.pipeline_v4.PipelineV4" href="../models/pipeline_v4.html#libica.openapi.v3.models.pipeline_v4.PipelineV4">PipelineV4</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_general_attributes_project_pipeline(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update&#34;)],
    pipeline_update: PipelineUpdate,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; PipelineV4:
    &#34;&#34;&#34;Update the general attributes of a project pipeline.

    Attributes which can be updated: - code - description - languageVersion - proprietary - resources 

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update (required)
    :type pipeline_id: str
    :param pipeline_update: (required)
    :type pipeline_update: PipelineUpdate
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_general_attributes_project_pipeline_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        pipeline_update=pipeline_update,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Update the general attributes of a project pipeline.</p>
<p>Attributes which can be updated: - code - description - languageVersion - proprietary - resources </p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update (required)
:type pipeline_id: str
:param pipeline_update: (required)
:type pipeline_update: PipelineUpdate
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_general_attributes_project_pipeline_with_http_info"><code class="name flex">
<span>def <span class="ident">update_general_attributes_project_pipeline_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ update')],<br>pipeline_update:Â <a title="libica.openapi.v3.models.pipeline_update.PipelineUpdate" href="../models/pipeline_update.html#libica.openapi.v3.models.pipeline_update.PipelineUpdate">PipelineUpdate</a>) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[PipelineV4]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_general_attributes_project_pipeline_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update&#34;)],
    pipeline_update: PipelineUpdate,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[PipelineV4]:
    &#34;&#34;&#34;Update the general attributes of a project pipeline.

    Attributes which can be updated: - code - description - languageVersion - proprietary - resources 

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update (required)
    :type pipeline_id: str
    :param pipeline_update: (required)
    :type pipeline_update: PipelineUpdate
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_general_attributes_project_pipeline_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        pipeline_update=pipeline_update,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Update the general attributes of a project pipeline.</p>
<p>Attributes which can be updated: - code - description - languageVersion - proprietary - resources </p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update (required)
:type pipeline_id: str
:param pipeline_update: (required)
:type pipeline_update: PipelineUpdate
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_general_attributes_project_pipeline_without_preload_content"><code class="name flex">
<span>def <span class="ident">update_general_attributes_project_pipeline_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ update')],<br>pipeline_update:Â <a title="libica.openapi.v3.models.pipeline_update.PipelineUpdate" href="../models/pipeline_update.html#libica.openapi.v3.models.pipeline_update.PipelineUpdate">PipelineUpdate</a>) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_general_attributes_project_pipeline_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update&#34;)],
    pipeline_update: PipelineUpdate,
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Update the general attributes of a project pipeline.

    Attributes which can be updated: - code - description - languageVersion - proprietary - resources 

    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update (required)
    :type pipeline_id: str
    :param pipeline_update: (required)
    :type pipeline_update: PipelineUpdate
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_general_attributes_project_pipeline_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        pipeline_update=pipeline_update,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: &#34;PipelineV4&#34;,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Update the general attributes of a project pipeline.</p>
<p>Attributes which can be updated: - code - description - languageVersion - proprietary - resources </p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update (required)
:type pipeline_id: str
:param pipeline_update: (required)
:type pipeline_update: PipelineUpdate
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_input_form_file"><code class="name flex">
<span>def <span class="ident">update_input_form_file</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ aÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_input_form_file(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update a file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; None:
    &#34;&#34;&#34;Update the contents of the input form file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update a file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_input_form_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Update the contents of the input form file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update a file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_input_form_file_with_http_info"><code class="name flex">
<span>def <span class="ident">update_input_form_file_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ aÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[NoneType]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_input_form_file_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update a file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[None]:
    &#34;&#34;&#34;Update the contents of the input form file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update a file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_input_form_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Update the contents of the input form file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update a file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_input_form_file_without_preload_content"><code class="name flex">
<span>def <span class="ident">update_input_form_file_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ aÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_input_form_file_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update a file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Update the contents of the input form file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update a file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_input_form_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Update the contents of the input form file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update a file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_render_file"><code class="name flex">
<span>def <span class="ident">update_on_render_file</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ theÂ onRenderÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_on_render_file(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the onRender file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; None:
    &#34;&#34;&#34;Update the contents of the onRender file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update the onRender file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_on_render_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Update the contents of the onRender file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update the onRender file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_render_file_with_http_info"><code class="name flex">
<span>def <span class="ident">update_on_render_file_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ theÂ onRenderÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[NoneType]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_on_render_file_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the onRender file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[None]:
    &#34;&#34;&#34;Update the contents of the onRender file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update the onRender file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_on_render_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Update the contents of the onRender file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update the onRender file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_render_file_without_preload_content"><code class="name flex">
<span>def <span class="ident">update_on_render_file_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ theÂ onRenderÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_on_render_file_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the onRender file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Update the contents of the onRender file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update the onRender file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_on_render_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Update the contents of the onRender file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update the onRender file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_submit_file"><code class="name flex">
<span>def <span class="ident">update_on_submit_file</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ theÂ onSubmitÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_on_submit_file(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the onSubmit file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; None:
    &#34;&#34;&#34;Update the contents of the onSubmit file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update the onSubmit file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_on_submit_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Update the contents of the onSubmit file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update the onSubmit file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_submit_file_with_http_info"><code class="name flex">
<span>def <span class="ident">update_on_submit_file_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ theÂ onSubmitÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[NoneType]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_on_submit_file_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the onSubmit file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[None]:
    &#34;&#34;&#34;Update the contents of the onSubmit file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update the onSubmit file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_on_submit_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Update the contents of the onSubmit file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update the onSubmit file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_submit_file_without_preload_content"><code class="name flex">
<span>def <span class="ident">update_on_submit_file_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ theÂ onSubmitÂ fileÂ for')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_on_submit_file_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update the onSubmit file for&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Update the contents of the onSubmit file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update the onSubmit file for (required)
    :type pipeline_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_on_submit_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Update the contents of the onSubmit file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update the onSubmit file for (required)
:type pipeline_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_project_pipeline_file"><code class="name flex">
<span>def <span class="ident">update_project_pipeline_file</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ aÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ file')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_project_pipeline_file(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update a file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; None:
    &#34;&#34;&#34;Update the contents of a file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update a file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the pipeline file (required)
    :type file_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    ).data</code></pre>
</details>
<div class="desc"><p>Update the contents of a file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update a file for (required)
:type pipeline_id: str
:param file_id: The ID of the pipeline file (required)
:type file_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_project_pipeline_file_with_http_info"><code class="name flex">
<span>def <span class="ident">update_project_pipeline_file_with_http_info</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ aÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ file')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â <a title="libica.openapi.v3.api_response.ApiResponse" href="../api_response.html#libica.openapi.v3.api_response.ApiResponse">ApiResponse</a>[NoneType]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_project_pipeline_file_with_http_info(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update a file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; ApiResponse[None]:
    &#34;&#34;&#34;Update the contents of a file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update a file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the pipeline file (required)
    :type file_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    response_data.read()
    return self.api_client.response_deserialize(
        response_data=response_data,
        response_types_map=_response_types_map,
    )</code></pre>
</details>
<div class="desc"><p>Update the contents of a file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update a file for (required)
:type pipeline_id: str
:param file_id: The ID of the pipeline file (required)
:type file_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
<dt id="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_project_pipeline_file_without_preload_content"><code class="name flex">
<span>def <span class="ident">update_project_pipeline_file_without_preload_content</span></span>(<span>self,<br>project_id:Â Annotated[str,Â Strict(strict=True)],<br>pipeline_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ projectÂ pipelineÂ toÂ updateÂ aÂ fileÂ for')],<br>file_id:Â Annotated[str,Â Strict(strict=True),Â FieldInfo(annotation=NoneType,Â required=True,Â description='TheÂ IDÂ ofÂ theÂ pipelineÂ file')],<br>content:Â Annotated[bytes,Â Strict(strict=True)]Â |Â Annotated[str,Â Strict(strict=True)]Â |Â Tuple[Annotated[str,Â Strict(strict=True)],Â Annotated[bytes,Â Strict(strict=True)]]) â€‘>Â urllib3.response.HTTPResponse</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_call
def update_project_pipeline_file_without_preload_content(
    self,
    project_id: StrictStr,
    pipeline_id: Annotated[StrictStr, Field(description=&#34;The ID of the project pipeline to update a file for&#34;)],
    file_id: Annotated[StrictStr, Field(description=&#34;The ID of the pipeline file&#34;)],
    content: Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]],
    _request_timeout: Union[
        None,
        Annotated[StrictFloat, Field(gt=0)],
        Tuple[
            Annotated[StrictFloat, Field(gt=0)],
            Annotated[StrictFloat, Field(gt=0)]
        ]
    ] = None,
    _request_auth: Optional[Dict[StrictStr, Any]] = None,
    _content_type: Optional[StrictStr] = None,
    _headers: Optional[Dict[StrictStr, Any]] = None,
    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
) -&gt; RESTResponseType:
    &#34;&#34;&#34;Update the contents of a file for a pipeline.


    :param project_id: (required)
    :type project_id: str
    :param pipeline_id: The ID of the project pipeline to update a file for (required)
    :type pipeline_id: str
    :param file_id: The ID of the pipeline file (required)
    :type file_id: str
    :param content: (required)
    :type content: bytearray
    :param _request_timeout: timeout setting for this request. If one
                             number provided, it will be total request
                             timeout. It can also be a pair (tuple) of
                             (connection, read) timeouts.
    :type _request_timeout: int, tuple(int, int), optional
    :param _request_auth: set to override the auth_settings for an a single
                          request; this effectively ignores the
                          authentication in the spec for a single request.
    :type _request_auth: dict, optional
    :param _content_type: force content-type for the request.
    :type _content_type: str, Optional
    :param _headers: set to override the headers for a single
                     request; this effectively ignores the headers
                     in the spec for a single request.
    :type _headers: dict, optional
    :param _host_index: set to override the host_index for a single
                        request; this effectively ignores the host_index
                        in the spec for a single request.
    :type _host_index: int, optional
    :return: Returns the result object.
    &#34;&#34;&#34; # noqa: E501

    _param = self._update_project_pipeline_file_serialize(
        project_id=project_id,
        pipeline_id=pipeline_id,
        file_id=file_id,
        content=content,
        _request_auth=_request_auth,
        _content_type=_content_type,
        _headers=_headers,
        _host_index=_host_index
    )

    _response_types_map: Dict[str, Optional[str]] = {
        &#39;200&#39;: None,
    }
    response_data = self.api_client.call_api(
        *_param,
        _request_timeout=_request_timeout
    )
    return response_data.response</code></pre>
</details>
<div class="desc"><p>Update the contents of a file for a pipeline.</p>
<p>:param project_id: (required)
:type project_id: str
:param pipeline_id: The ID of the project pipeline to update a file for (required)
:type pipeline_id: str
:param file_id: The ID of the pipeline file (required)
:type file_id: str
:param content: (required)
:type content: bytearray
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:type _request_timeout: int, tuple(int, int), optional
:param _request_auth: set to override the auth_settings for an a single
request; this effectively ignores the
authentication in the spec for a single request.
:type _request_auth: dict, optional
:param _content_type: force content-type for the request.
:type _content_type: str, Optional
:param _headers: set to override the headers for a single
request; this effectively ignores the headers
in the spec for a single request.
:type _headers: dict, optional
:param _host_index: set to override the host_index for a single
request; this effectively ignores the host_index
in the spec for a single request.
:type _host_index: int, optional
:return: Returns the result object.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="libica.openapi.v3.api" href="index.html">libica.openapi.v3.api</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi">ProjectPipelineApi</a></code></h4>
<ul class="">
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_additional_project_pipeline_file" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_additional_project_pipeline_file">create_additional_project_pipeline_file</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_additional_project_pipeline_file_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_additional_project_pipeline_file_with_http_info">create_additional_project_pipeline_file_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_additional_project_pipeline_file_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_additional_project_pipeline_file_without_preload_content">create_additional_project_pipeline_file_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_json_pipeline" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_json_pipeline">create_cwl_json_pipeline</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_json_pipeline_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_json_pipeline_with_http_info">create_cwl_json_pipeline_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_json_pipeline_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_json_pipeline_without_preload_content">create_cwl_json_pipeline_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_pipeline" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_pipeline">create_cwl_pipeline</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_pipeline_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_pipeline_with_http_info">create_cwl_pipeline_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_pipeline_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_cwl_pipeline_without_preload_content">create_cwl_pipeline_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_json_pipeline" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_json_pipeline">create_nextflow_json_pipeline</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_json_pipeline_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_json_pipeline_with_http_info">create_nextflow_json_pipeline_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_json_pipeline_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_json_pipeline_without_preload_content">create_nextflow_json_pipeline_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_pipeline" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_pipeline">create_nextflow_pipeline</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_pipeline_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_pipeline_with_http_info">create_nextflow_pipeline_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_pipeline_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_nextflow_pipeline_without_preload_content">create_nextflow_pipeline_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_project_pipeline_file" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_project_pipeline_file">create_project_pipeline_file</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_project_pipeline_file_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_project_pipeline_file_with_http_info">create_project_pipeline_file_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_project_pipeline_file_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.create_project_pipeline_file_without_preload_content">create_project_pipeline_file_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_additional_project_pipeline_file" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_additional_project_pipeline_file">delete_additional_project_pipeline_file</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_additional_project_pipeline_file_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_additional_project_pipeline_file_with_http_info">delete_additional_project_pipeline_file_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_additional_project_pipeline_file_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_additional_project_pipeline_file_without_preload_content">delete_additional_project_pipeline_file_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_project_pipeline_file" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_project_pipeline_file">delete_project_pipeline_file</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_project_pipeline_file_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_project_pipeline_file_with_http_info">delete_project_pipeline_file_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_project_pipeline_file_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.delete_project_pipeline_file_without_preload_content">delete_project_pipeline_file_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_additional_file_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_additional_file_content">download_additional_file_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_additional_file_content_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_additional_file_content_with_http_info">download_additional_file_content_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_additional_file_content_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_additional_file_content_without_preload_content">download_additional_file_content_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_input_form_file_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_input_form_file_content">download_input_form_file_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_input_form_file_content_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_input_form_file_content_with_http_info">download_input_form_file_content_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_input_form_file_content_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_input_form_file_content_without_preload_content">download_input_form_file_content_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_render_file_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_render_file_content">download_on_render_file_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_render_file_content_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_render_file_content_with_http_info">download_on_render_file_content_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_render_file_content_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_render_file_content_without_preload_content">download_on_render_file_content_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_submit_file_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_submit_file_content">download_on_submit_file_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_submit_file_content_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_submit_file_content_with_http_info">download_on_submit_file_content_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_submit_file_content_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_on_submit_file_content_without_preload_content">download_on_submit_file_content_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_project_pipeline_file_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_project_pipeline_file_content">download_project_pipeline_file_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_project_pipeline_file_content_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_project_pipeline_file_content_with_http_info">download_project_pipeline_file_content_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_project_pipeline_file_content_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.download_project_pipeline_file_content_without_preload_content">download_project_pipeline_file_content_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline">get_project_pipeline</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_additional_files" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_additional_files">get_project_pipeline_additional_files</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_additional_files_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_additional_files_with_http_info">get_project_pipeline_additional_files_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_additional_files_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_additional_files_without_preload_content">get_project_pipeline_additional_files_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_configuration_parameters" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_configuration_parameters">get_project_pipeline_configuration_parameters</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_configuration_parameters_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_configuration_parameters_with_http_info">get_project_pipeline_configuration_parameters_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_configuration_parameters_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_configuration_parameters_without_preload_content">get_project_pipeline_configuration_parameters_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_files" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_files">get_project_pipeline_files</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_files_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_files_with_http_info">get_project_pipeline_files_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_files_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_files_without_preload_content">get_project_pipeline_files_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_html_documentation" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_html_documentation">get_project_pipeline_html_documentation</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_html_documentation_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_html_documentation_with_http_info">get_project_pipeline_html_documentation_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_html_documentation_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_html_documentation_without_preload_content">get_project_pipeline_html_documentation_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_input_parameters" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_input_parameters">get_project_pipeline_input_parameters</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_input_parameters_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_input_parameters_with_http_info">get_project_pipeline_input_parameters_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_input_parameters_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_input_parameters_without_preload_content">get_project_pipeline_input_parameters_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_reference_sets" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_reference_sets">get_project_pipeline_reference_sets</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_reference_sets_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_reference_sets_with_http_info">get_project_pipeline_reference_sets_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_reference_sets_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_reference_sets_without_preload_content">get_project_pipeline_reference_sets_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_with_http_info">get_project_pipeline_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipeline_without_preload_content">get_project_pipeline_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipelines" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipelines">get_project_pipelines</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipelines_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipelines_with_http_info">get_project_pipelines_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipelines_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.get_project_pipelines_without_preload_content">get_project_pipelines_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.link_pipeline_to_project" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.link_pipeline_to_project">link_pipeline_to_project</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.link_pipeline_to_project_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.link_pipeline_to_project_with_http_info">link_pipeline_to_project_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.link_pipeline_to_project_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.link_pipeline_to_project_without_preload_content">link_pipeline_to_project_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.release_project_pipeline" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.release_project_pipeline">release_project_pipeline</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.release_project_pipeline_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.release_project_pipeline_with_http_info">release_project_pipeline_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.release_project_pipeline_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.release_project_pipeline_without_preload_content">release_project_pipeline_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.unlink_pipeline_from_project" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.unlink_pipeline_from_project">unlink_pipeline_from_project</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.unlink_pipeline_from_project_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.unlink_pipeline_from_project_with_http_info">unlink_pipeline_from_project_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.unlink_pipeline_from_project_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.unlink_pipeline_from_project_without_preload_content">unlink_pipeline_from_project_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_additional_file" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_additional_file">update_additional_file</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_additional_file_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_additional_file_with_http_info">update_additional_file_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_additional_file_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_additional_file_without_preload_content">update_additional_file_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_general_attributes_project_pipeline" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_general_attributes_project_pipeline">update_general_attributes_project_pipeline</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_general_attributes_project_pipeline_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_general_attributes_project_pipeline_with_http_info">update_general_attributes_project_pipeline_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_general_attributes_project_pipeline_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_general_attributes_project_pipeline_without_preload_content">update_general_attributes_project_pipeline_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_input_form_file" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_input_form_file">update_input_form_file</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_input_form_file_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_input_form_file_with_http_info">update_input_form_file_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_input_form_file_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_input_form_file_without_preload_content">update_input_form_file_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_render_file" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_render_file">update_on_render_file</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_render_file_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_render_file_with_http_info">update_on_render_file_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_render_file_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_render_file_without_preload_content">update_on_render_file_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_submit_file" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_submit_file">update_on_submit_file</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_submit_file_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_submit_file_with_http_info">update_on_submit_file_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_submit_file_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_on_submit_file_without_preload_content">update_on_submit_file_without_preload_content</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_project_pipeline_file" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_project_pipeline_file">update_project_pipeline_file</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_project_pipeline_file_with_http_info" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_project_pipeline_file_with_http_info">update_project_pipeline_file_with_http_info</a></code></li>
<li><code><a title="libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_project_pipeline_file_without_preload_content" href="#libica.openapi.v3.api.project_pipeline_api.ProjectPipelineApi.update_project_pipeline_file_without_preload_content">update_project_pipeline_file_without_preload_content</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
